[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen, hilfreich ist der w-Pseudocode",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nHier stehen die Lernziele",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Einleitung",
    "text": "Einleitung\nEinleitungstext",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "Die Erzeugung und Auswertung von Daten ist ein zentraler Bestandteil wissenschaftlicher Forschung. Die computergest√ºtzte Datenanalyse erm√∂glicht es, gro√üe Datenmengen (teil-)automatisiert auszuwerten. Gut lesbare Skriptsprachen wie Python sorgen f√ºr eine nachvollziehbare Datenverarbeitung und erm√∂glichen es, Analysen ‚Äúauf Knopfdruck‚Äù zu wiederholen oder anzupassen.\n\n\n\n\nLogo der Programmiersprache Python\n\n\nPython Logo von Python Software Foundation steht unter der GPLv3. Die Wort-Bild-Marke ist markenrechtlich gesch√ºtzt: https://www.python.org/psf/trademarks/. Das Werk ist abrufbar auf wikimedia. 2008\n\n¬†\nAls Skriptsprache werden Python-Programme nicht in ein fertiges Programm √ºbersetzt, sondern von einem sogenannten Interpreter, der die Programmanweisungen in Maschinencode f√ºr das jeweilige Computersystem √ºbersetzt, ausgef√ºhrt. Dadurch kann das Skript auf verschiedenen Computersystemen ausgef√ºhrt werden. Zwar sind interpretierte Sprachen langsamer als fertig √ºbersetzte Programme. Bei rechenintensiven Alogrithmen helfen jedoch spezialisierte Pakete, die Rechenleistung von Python deutlich zu steigern und diesen Unterschied fast ganz auszugleichen.\nPython kommt als schlichte Konsole daher. Zahlreiche Funktionen wie Codeformatierung, Codevervollst√§ndigung und Fehleranalyse werden durch eine sogenannte integrierte Entwicklungsumgebung (integrated development environment, IDE) bereitgestellt.\n\n\n\n\n\nProgrammentwicklung mit Python\n\n\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "Python-Code.html",
    "href": "Python-Code.html",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code m√ºssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# blo√ü nicht √ºbertreiben\n# print(\"Python ist gro√üartig!\") # das ist √ºbertrieben\nprint(\"Python ist ziemlich gut.\") # das ist realistisch\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#formatierung",
    "href": "Python-Code.html#formatierung",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder Doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengeh√∂rigen Code-Block. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#datentypen",
    "href": "Python-Code.html#datentypen",
    "title": "2¬† Python-Code",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nPython ist eine objektorientierte Programmiersprache. Ein Objekt ist eine Einheit mit bestimmten Eigenschaften und Verhaltensweisen. Jedes Objekt geh√∂rt zu einer Klasse, die die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Die Klasse ist die Vorlage f√ºr jedes Objekt der Klasse. In Python werden Klassen (class) auch Typen (type) genannt (In den Anf√§ngen von Python waren Klassen und Typen noch verschieden).\n\nprint(type(2), 2+2 )\nprint(type('a'), 'a'+'a')\nprint(type(True), True+True)\n\n&lt;class 'int'&gt; 4\n&lt;class 'str'&gt; aa\n&lt;class 'bool'&gt; 2\n\n\nPython kennt sehr viele Datentypen mit unterschiedlichen Eigenschaften und Verhaltensweisen. In diesem Abschnitt werden die f√ºr die Datenanalyse wichtigen Datentypen vorgestellt.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\nDie print-Funktion haben Sie bereits kennengelernt. Quelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-und-objekte",
    "href": "Python-Code.html#klassen-typen-und-objekte",
    "title": "2¬† Python-Code",
    "section": "2.2 Klassen, Typen und Objekte",
    "text": "2.2 Klassen, Typen und Objekte\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt geh√∂rt zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Objekte ‚Äúerben‚Äù die Eigenschaften der Klasse, zu der sie geh√∂ren. In Python werden Klassen (class) auch Typen (type) genannt (In den Anf√§ngen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.\n\nZahlen\n‚Ä¶\n\n\nZahlen\nZu den Zahlen geh√∂ren Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.\n\n\nAufgaben Zahlen\nL√∂sen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\nùü£ + ùü§6 / ùüß = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nMusterl√∂sung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / gr√∂√üer als / gr√∂√üer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis¬†2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nL√∂sen Sie die Aufgaben mit Python.\n\nIst das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\nIst es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichefolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichefolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Mit dem Steuerzeichen \\\\ funktionieren auch die gleichen \\\"Anf√ºhrungszeichen\\\" wie die umschlie√üenden.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nMit dem Steuerzeichen \\ funktionieren auch die gleichen \"Anf√ºhrungszeichen\" wie die umschlie√üenden.\nErst ein    Tabstopp, dann eine\nneue Zeile.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#logische-operationen",
    "href": "Python-Code.html#logische-operationen",
    "title": "2¬† Python-Code schreiben",
    "section": "2.4 Logische Operationen",
    "text": "2.4 Logische Operationen\nZu den logischen Operationen geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / gr√∂√üer als\n\n\n&lt;=, &gt;=\nkleiner / gr√∂√üer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nerg√§nzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\nstring-formating mit f-strings\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#gleitkommazahlen",
    "href": "Python-Code.html#gleitkommazahlen",
    "title": "2¬† Python-Code schreiben",
    "section": "2.3 Gleitkommazahlen",
    "text": "2.3 Gleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch von 0.1 ist in Dezimalschreibweise 3602879701896397 / 2^55). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\nAbhilfe schafft in diesem Fall die Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()‚Ä¶ ein paar Funktionen f√ºr die Ausgabe von strings ohne ‚Äô‚Äô und ohne ,\n\nprint(format(0.1, ‚Äò.17g‚Äô)) # 17 signifikante Stellen\nprint(format(0.1, ‚Äò.17f‚Äô)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nOperationen mit Zahlen, dann √úbungsaufgaben Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche gr√∂√üer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann √úbungsaufgaben Zwei Divisionen vergleichen, welche gr√∂√üer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code-schreiben",
    "href": "Python-Code.html#python-code-schreiben",
    "title": "2¬† Python-Code schreiben",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder Doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengeh√∂rigen Code-Block. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#ausgabe-formatieren",
    "href": "Python-Code.html#ausgabe-formatieren",
    "title": "2¬† Python-Code",
    "section": "2.4 Ausgabe formatieren",
    "text": "2.4 Ausgabe formatieren\nFunktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()‚Ä¶ ein paar Funktionen f√ºr die Ausgabe von strings ohne ‚Äô‚Äô und ohne ,\n\nprint(format(0.1, ‚Äò.17g‚Äô)) # 17 signifikante Stellen\nprint(format(0.1, ‚Äò.17f‚Äô)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#arithmetische-operatoren",
    "href": "Python-Code.html#arithmetische-operatoren",
    "title": "2¬† Python-Code schreiben",
    "section": "2.3 Arithmetische Operatoren",
    "text": "2.3 Arithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#aufgaben-rechenoperationen",
    "href": "Python-Code.html#aufgaben-rechenoperationen",
    "title": "2¬† Python-Code schreiben",
    "section": "2.4 Aufgaben Rechenoperationen",
    "text": "2.4 Aufgaben Rechenoperationen\nL√∂sen Sie die folgenden Aufgaben 1. 4 + 2 * 4 = ? 2. 2 hoch 12? 3. Was ist der Rest aus 315 geteilt durch 4? 4. ùü£+ùü§6/ùüß Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche gr√∂√üer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann √úbungsaufgaben Zwei Divisionen vergleichen, welche gr√∂√üer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden\n\n\nLogische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / gr√∂√üer als\n\n\n&lt;=, &gt;=\nkleiner / gr√∂√üer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nerg√§nzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\n\n\nZeichenketten",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#variablen",
    "href": "Python-Code.html#variablen",
    "title": "2¬† Python-Code",
    "section": "2.3 Variablen",
    "text": "2.3 Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Typ der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nErkl√§ren, warum Sie bereits Variablen erstellt und verwendet haben‚Ä¶ Python has no command for declaring a variable.\nA variable is created the moment you first assign a value to it.\nVariables do not need to be declared with any particular type, and can even change type after they have been set.\n\nBenennung von Variablen\nsprechende Variablen Die Benennung von Variablen ist (meist) dem jeweiligen Programmierer √ºberlassen, es empfiehlt sich jedoch selbsterkl√§rende Variablennamen zu vergeben. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\nUnter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden.\nZeigen, wie man den Typ einer Variable bestimmt und √§ndert. (type(x), int(), ord() ‚Ä¶ das ist im m-EsD)",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code",
    "href": "Python-Code.html#python-code",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder Doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengeh√∂rigen Code-Block. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  }
]