[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen, hilfreich ist der w-Pseudocode",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nHier stehen die Lernziele",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "Einleitung",
    "text": "Einleitung\nEinleitungstext",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1  Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "Die Erzeugung und Auswertung von Daten ist ein zentraler Bestandteil wissenschaftlicher Forschung. Die computergestützte Datenanalyse ermöglicht es, große Datenmengen (teil-)automatisiert auszuwerten. Gut lesbare Skriptsprachen wie Python sorgen für eine nachvollziehbare Datenverarbeitung und ermöglichen es, Analysen “auf Knopfdruck” zu wiederholen oder anzupassen.\n\n\n\n\nLogo der Programmiersprache Python\n\n\nPython Logo von Python Software Foundation steht unter der GPLv3. Die Wort-Bild-Marke ist markenrechtlich geschützt: https://www.python.org/psf/trademarks/. Das Werk ist abrufbar auf wikimedia. 2008\n\n \nAls Skriptsprache werden Pythonprogramme nicht in ein fertiges Programm übersetzt, sondern von einem sogenannten Interpreter, der die Programmanweisungen in Maschinencode für das jeweilige Computersystem übersetzt, ausgeführt. Dadurch kann das Skript auf verschiedenen Computersystemen ausgeführt werden. Zwar sind interpretierte Sprachen langsamer als fertig übersetzte Programme. Bei rechenintensiven Alogrithmen helfen jedoch spezialisierte Pakete, die Rechenleistung von Python deutlich zu steigern und diesen Unterschied fast ganz auszugleichen.\nPython kommt als schlichte Konsole daher. Zahlreiche Funktionen wie Codeformatierung, Codevervollständigung und Fehleranalyse werden durch eine sogenannte integrierte Entwicklungsumgebung bereitgestellt.\n\n\n\n\n\nProgrammentwicklung mit Python\n\n\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "Python-Code.html",
    "href": "Python-Code.html",
    "title": "2  Python-Code",
    "section": "",
    "text": "2.1 Formatierung\nBei der Formatierung von Python-Code müssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# bloß nicht übertreiben\n# print(\"Python ist großartig!\") # das ist übertrieben\nprint(\"Python ist ziemlich gut.\") # das ist realistisch\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#formatierung",
    "href": "Python-Code.html#formatierung",
    "title": "2  Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren können direkt eingegeben werden. Text muss in einfache oder Doppelte Anführungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgeführt werden soll, oder Erläuterungen.\n\n\n\nAusdrücke müssen in einer Zeile stehen. Längere Ausdrücke können mit dem Zeichen \\ über mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() können Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einrückung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengehörigen Code-Block. Die for-Schleife führt alle Anweisungen im eingerückten Ausführungsblock aus. Die folgende, nicht eingerückte Zeile markiert den Beginn einer neuen, nicht zur Schleife gehörigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#datentypen",
    "href": "Python-Code.html#datentypen",
    "title": "2  Python-Code",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nPython ist eine objektorientierte Programmiersprache. Ein Objekt ist eine Einheit mit bestimmten Eigenschaften und Verhaltensweisen. Jedes Objekt gehört zu einer Klasse, die die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Die Klasse ist die Vorlage für jedes Objekt der Klasse. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden).\n\nprint(type(2), 2+2 )\nprint(type('a'), 'a'+'a')\nprint(type(True), True+True)\n\n&lt;class 'int'&gt; 4\n&lt;class 'str'&gt; aa\n&lt;class 'bool'&gt; 2\n\n\nPython kennt sehr viele Datentypen mit unterschiedlichen Eigenschaften und Verhaltensweisen. In diesem Abschnitt werden die für die Datenanalyse wichtigen Datentypen vorgestellt.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \nDie print-Funktion haben Sie bereits kennengelernt. Quelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-und-objekte",
    "href": "Python-Code.html#klassen-typen-und-objekte",
    "title": "2  Python-Code",
    "section": "2.2 Klassen, Typen und Objekte",
    "text": "2.2 Klassen, Typen und Objekte\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt gehört zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt. In Python werden Klassen (class) auch Typen (type) genannt (In den Anfängen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abhängig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 1 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + für die Klassen Ganzzahlen (‘int’) und Zeichenketten (‘str’) definiert ist. Python kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von Максим Пе ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n \nIn diesem Abschnitt werden die für die Datenanalyse wichtigsten Datentypen vorgestellt.\n\nZahlen\n…\n\n\nZahlen\nZu den Zahlen gehören Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardmäßig im Dezimalsystem eingegeben und können positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDarüber hinaus können Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#logische-operationen",
    "href": "Python-Code.html#logische-operationen",
    "title": "2  Python-Code",
    "section": "2.4 Logische Operationen",
    "text": "2.4 Logische Operationen\nZu den logischen Operationen gehören die logischen Verknüpfungen and, or und not. Darüber hinaus können auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / größer als\n\n\n&lt;=, &gt;=\nkleiner / größer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nergänzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\nstring-formating mit f-strings\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‘Datenanalyse mit Python’.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#gleitkommazahlen",
    "href": "Python-Code.html#gleitkommazahlen",
    "title": "2  Python-Code",
    "section": "2.3 Gleitkommazahlen",
    "text": "2.3 Gleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise zählt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Binärsystem arbeiten, können Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Binär ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen müssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Binärbruch von 0.1 ist in Dezimalschreibweise 3602879701896397 / 2^55). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Binärapproximation repräsentiert werden. Python gibt zwar die jeweils kürzeste Dezimalzahl aus, da Berechnungen aber binär durchgeführt werden, kann sich bei Berechnungen die nächste Binärapproximation und damit die zugehörige kürzeste Dezimalzahl ändern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die kürzeste Dezimalzahl zur Binärapproximation\nprint(format(0.1, '.17g')) # Die nächstlängere Dezimalzahl zur selben Binärapproximation\nprint(0.3 - 0.2) # binär gerechnet, ändert sich die Binärapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungewöhnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\nAbhilfe schafft in diesem Fall die Funktion round(Wert, Stellen). Querverweis f-strings\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nOperationen mit Zahlen, dann Übungsaufgaben Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche größer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir später genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 größer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False können mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 größer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False können mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist nützlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zurück.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir später kennenlernen. Boolsche Werte können die Ausführung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgeführt werden, wenn ein Sammeltyp auch Werte enthält.\n\nmeine_Liste = ['Äpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir müssen {meine_Liste} einkaufen.\")\n\nWir müssen ['Äpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann Übungsaufgaben Zwei Divisionen vergleichen, welche größer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python-Code</span>"
    ]
  }
]