[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen, hilfreich ist der w-Pseudocode\nQuerverweis auf:\n\nw-NumPy\nw-Pandas",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Bausteine werden die Grundz√ºge der Programmierung mit Python vermittelt. In diesem Baustein lernen Sie ‚Ä¶\n\nGrundbegriffe der objektorientierten Programmierung.\nPython-Code zu schreiben, Variablen zu erstellen, Operationen durchzuf√ºhren und die Ausgabe zu formatieren.\ndie Dokumentation zu lesen und zu verwenden\ndie exklusive Z√§hlweise von Python kennen.\nden Unterschied zwischen Funktionen und Methoden kennen und wie eigene Funktionen geschrieben werden.\nModule und Pakete laden",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#einleitung",
    "href": "index.html#einleitung",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Einleitung",
    "text": "Einleitung\nEinleitungstext",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "einleitung.html",
    "href": "einleitung.html",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "1.1 Grundbegriffe der objektorientierten Programmierung\nPython ist eine objektorientierte Programmiersprache. Die objektorientierte Programmierung ist ein System, um Ordnung in komplexe Computerprogramme zu bringen. In diesem Abschnitt werden die Grundbegriffe der objektorientierten Programmierung mit Python vermittelt. Sie erfahren, was der Unterschied zwischen einem Objekt, einer Klasse und dem Datentyp ist.\n√úberarbeiten: den Aufklapper Attribute k√∂nnte man in dieses Kapitel verschieben und auch erg√§nzen, wie man sich mit dir() die verf√ºgbaren Methoden eines Objekts ausgeben lassen kann. Eine gute Vorlage ist das Skript von Lukas",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "Python-Code.html",
    "href": "Python-Code.html",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code m√ºssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# blo√ü nicht √ºbertreiben\n# print(\"Python ist gro√üartig!\") # das ist √ºbertrieben\nprint(\"Python ist ziemlich gut.\") # das ist realistisch\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nIn dem obenstehenden Beispiel werden Variablen angelegt. Mit Variablen besch√§ftigten wir uns sp√§ter in diesem Abschnitt. Trotzdem m√∂chte ich Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir kommen sp√§ter darauf zur√ºck.\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#formatierung",
    "href": "Python-Code.html#formatierung",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder Doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengeh√∂rigen Code-Block. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#datentypen",
    "href": "Python-Code.html#datentypen",
    "title": "2¬† Python-Code",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nPython ist eine objektorientierte Programmiersprache. Ein Objekt ist eine Einheit mit bestimmten Eigenschaften und Verhaltensweisen. Jedes Objekt geh√∂rt zu einer Klasse, die die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Die Klasse ist die Vorlage f√ºr jedes Objekt der Klasse. In Python werden Klassen (class) auch Typen (type) genannt (In den Anf√§ngen von Python waren Klassen und Typen noch verschieden).\n\nprint(type(2), 2+2 )\nprint(type('a'), 'a'+'a')\nprint(type(True), True+True)\n\n&lt;class 'int'&gt; 4\n&lt;class 'str'&gt; aa\n&lt;class 'bool'&gt; 2\n\n\nPython kennt sehr viele Datentypen mit unterschiedlichen Eigenschaften und Verhaltensweisen. In diesem Abschnitt werden die f√ºr die Datenanalyse wichtigen Datentypen vorgestellt.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\nDie print-Funktion haben Sie bereits kennengelernt. Quelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-und-objekte",
    "href": "Python-Code.html#klassen-typen-und-objekte",
    "title": "2¬† Python-Code",
    "section": "2.2 Klassen, Typen und Objekte",
    "text": "2.2 Klassen, Typen und Objekte\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt geh√∂rt zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt. Objekte ‚Äúerben‚Äù die Eigenschaften der Klasse, zu der sie geh√∂ren. In Python werden Klassen (class) auch Typen (type) genannt (In den Anf√§ngen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.\n\nZahlen\nZu den Zahlen geh√∂ren Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.\n\n\nAufgaben Zahlen\nL√∂sen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\nùü£ + ùü§6 / ùüß = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nMusterl√∂sung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und geh√∂ren in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / gr√∂√üer als / gr√∂√üer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis¬†2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nL√∂sen Sie die Aufgaben mit Python.\n\nIst das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\nIst es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichefolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichefolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Mit dem Steuerzeichen \\\\ funktionieren auch die gleichen \\\"Anf√ºhrungszeichen\\\" wie die umschlie√üenden.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nMit dem Steuerzeichen \\ funktionieren auch die gleichen \"Anf√ºhrungszeichen\" wie die umschlie√üenden.\nErst ein    Tabstopp, dann eine\nneue Zeile.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#logische-operationen",
    "href": "Python-Code.html#logische-operationen",
    "title": "2¬† Python-Code schreiben",
    "section": "2.4 Logische Operationen",
    "text": "2.4 Logische Operationen\nZu den logischen Operationen geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / gr√∂√üer als\n\n\n&lt;=, &gt;=\nkleiner / gr√∂√üer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nerg√§nzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\nstring-formating mit f-strings\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#gleitkommazahlen",
    "href": "Python-Code.html#gleitkommazahlen",
    "title": "2¬† Python-Code schreiben",
    "section": "2.3 Gleitkommazahlen",
    "text": "2.3 Gleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-7, \"oder\", 1e+7)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n1e-07 oder 10000000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch von 0.1 ist in Dezimalschreibweise 3602879701896397 / 2^55). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\nAbhilfe schafft in diesem Fall die Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()‚Ä¶ ein paar Funktionen f√ºr die Ausgabe von strings ohne ‚Äô‚Äô und ohne ,\n\nprint(format(0.1, ‚Äò.17g‚Äô)) # 17 signifikante Stellen\nprint(format(0.1, ‚Äò.17f‚Äô)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nOperationen mit Zahlen, dann √úbungsaufgaben Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche gr√∂√üer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann √úbungsaufgaben Zwei Divisionen vergleichen, welche gr√∂√üer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code-schreiben",
    "href": "Python-Code.html#python-code-schreiben",
    "title": "2¬† Python-Code schreiben",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder Doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengeh√∂rigen Code-Block. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#ausgabe-formatieren",
    "href": "Python-Code.html#ausgabe-formatieren",
    "title": "2¬† Python-Code",
    "section": "2.3 Ausgabe formatieren",
    "text": "2.3 Ausgabe formatieren\nMit sogenannten f-Strings k√∂nnen formatierte Zeichenketten erstellt werden. Formatierte Zeichenketten werden mit einem vorgesetzten f vor den Anf√ºhrungsstrichen erstellt. Werte und Variablen k√∂nnen durch Platzhalter eingesetzt werden, die mit geschweiften Klammern {} angegeben und mit Formattierungsinformationen versehen werden. Das Formatierungsformat innerhalb der geschweiften Klammer ist, vereinfacht dargestellt:\n{Variablenname:PlatzbedarfAusgabetyp}\nEin f-String mit Platzhaltern ohne Formatierungsinformationen:\n\nzahl1 = 5\nzahl2 = 7\nverh√§ltnis = zahl1 / zahl2\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.7142857142857143.\n\n\nDie Anzahl der darzustellenden Nachkommastellen kann wie folgt festgelegt werden: {verh√§ltnis:.2f}.\n\n: leitet die Formatierungsbefehle ein.\n. gibt an, dass Formatierungsinformationen f√ºr die Darstellung hinter dem Dezimaltrennzeichen folgen.\n2 ist der Wert f√ºr die darzustellenden Nachkommastellen.\nf spezifiziert die Darstellung einer Gleitkommazahl ‚Äòfloat‚Äô.\n\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:.2f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.71.\n\n\nDas gleiche ist mit einem Wert m√∂glich:\n\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:.3f}.\")\n\nDas Verh√§ltnis ist genauer 0.714.\n\n\nEin Wert f√ºr die insgesamt darzustellenden Stellen wird vor dem Dezimaltrennzeichen √ºbergeben {verh√§ltnis:7.2f} bzw. inklusive f√ºhrender Nullen {verh√§ltnis:07.2f}:\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:7.2f}.\")\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:07.3f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist    0.71.\nDas Verh√§ltnis ist genauer 000.714.\n\n\nDas Dezimaltrennzeichen z√§hlt als eine Stelle.\nH√§ufig verwendete Formatierung sind:\n\nganze ZahlenGleitkommazahlenZeichenketten\n\n\nGanze Zahlen haben den Ausgabetyp d.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nnd\nn-Stellen werden f√ºr die Ausgabe verwendet\n\n\n0nd\nAusgabe von n-Stellen, wobei die Leerstellen mit Nullen aufgef√ºllt werden.\n\n\n+d\nAusgabe des Vorzeichens auch bei positiven Zahlen\n\n\n\n\n\nGleitkommazahlen haben die Ausgabetypen f und e.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\n.mf\nm-Stellen werden f√ºr die Nachkommastellen genutzt.\n\n\nn.mf\nInsgesamt werden n-Stellen verwendet, wobei m-Stellen f√ºr die Nachkommastellen genutzt werden.\n\n\nn.me\nGenauso, aber die Ausgabe erfolgt in exponentieller Schreibweise.\n\n\n\n\n\nZeichenketten haben den Ausgabetyp s.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nns\nInsgesamt werden n-Stellen verwendet.\n\n\n&lt;ns, &gt;ns, ^ns\nGenauso, jedoch wird die Zeichenkette linksb√ºndig, rechtsb√ºndig bzw. zentriert platziert.\n\n\n\n\n\n\n(Arnold 2023b)\n**Funktionen wie round(), format() und string-Methoden wie .upper .lower ins n√§chste Kapitel schieben‚Ä¶ sie sind eine gute Einleitung f√ºr die objektorientierte Programmierung (manche funktionieren nur mit Zahlen, andere nur mit Zeichen).\nZahlen: Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()‚Ä¶ ein paar Funktionen f√ºr die Ausgabe von strings ohne ‚Äô‚Äô und ohne ,\n\nprint(format(0.1, ‚Äò.17g‚Äô)) # 17 signifikante Stellen\nprint(format(0.1, ‚Äò.17f‚Äô)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nWie kann man die Exponentialschreibeweise ein- / ausschalten?\nMit f-strings{} k√∂nnen Werte und Variablen in eine Zeichenfolge eingesetzt werden.\n\nprint(\"Ich muss einkaufen gehen.\")\nprint(f\"Ich muss {'√Ñpfel'} einkaufen gehen.\")\n\neinkauf = '√Ñpfel'\nprint(f\"Ich muss {einkauf} einkaufen gehen.\")\n\nIch muss einkaufen gehen.\nIch muss √Ñpfel einkaufen gehen.\nIch muss √Ñpfel einkaufen gehen.\n\n\nStrings: Methoden .lower(), .upper(), .title() https://www.w3schools.com/python/python_ref_string.asp\nAls n√§chstes Kapitel: Sammeltypen (Liste, Tupel, Dict) Hinweis: Strings sind in Python eine Sequenz von Zeichen (Zeichenfolge), die unver√§nderlich ist (immutable). Bei der Arbeit mit strings f√§llt das nicht unbedingt auf. Beispiel erg√§nzen, bei dem ein string ver√§ndert wird. Tats√§chlich wird aber immer ein neuer string angelegt.\nUm auf Elemente einer Zeichenfolge zuzugreifen, wird der Slicing-Operator [] verwendet. Als n√§chstes Kapitel: Funktionen if, while, for ‚Ä¶, eigene Funktionen schreiben\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#arithmetische-operatoren",
    "href": "Python-Code.html#arithmetische-operatoren",
    "title": "2¬† Python-Code schreiben",
    "section": "2.3 Arithmetische Operatoren",
    "text": "2.3 Arithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#aufgaben-rechenoperationen",
    "href": "Python-Code.html#aufgaben-rechenoperationen",
    "title": "2¬† Python-Code schreiben",
    "section": "2.4 Aufgaben Rechenoperationen",
    "text": "2.4 Aufgaben Rechenoperationen\nL√∂sen Sie die folgenden Aufgaben 1. 4 + 2 * 4 = ? 2. 2 hoch 12? 3. Was ist der Rest aus 315 geteilt durch 4? 4. ùü£+ùü§6/ùüß Rendite 20 Jahre lang mit 3 Prozent, 30 Jahre mit 2 Prozent welche gr√∂√üer ist.\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenkette\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\nlogische Operationen, dann √úbungsaufgaben Zwei Divisionen vergleichen, welche gr√∂√üer ist.\nDatentyp muss noch von Klasse / Typ unterschieden werden\n\n\nLogische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool.\n\n\n\nOperand\nBeschreibung\n\n\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\nnot\nlogisches NICHT\n\n\n&lt;, &gt;\nkleiner / gr√∂√üer als\n\n\n&lt;=, &gt;=\nkleiner / gr√∂√üer gleich\n\n\n==, !=\ngleich / ungleich\n\n\n\nerg√§nzen: Hinweis auf bitwise AND (&), NOT (~), XOR (^)\n\n\nZeichenketten",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code schreiben</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#variablen",
    "href": "Python-Code.html#variablen",
    "title": "2¬† Python-Code",
    "section": "2.3 Variablen",
    "text": "2.3 Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‚Äòfloat‚Äô zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder √ºbersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAufl√∂sung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich ‚Äúsprechende‚Äù, das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchl√ºsselw√∂rter und Funktionsnamen\n\n\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable f√ºr den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.1: Musterl√∂sung Aufgaben Variablen",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#python-code",
    "href": "Python-Code.html#python-code",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen oder Tabstopps kennzeichnet einen zusammengeh√∂rigen Code-Block. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#klassen-typen-objekte-und-datentypen",
    "href": "Python-Code.html#klassen-typen-objekte-und-datentypen",
    "title": "2¬† Python-Code",
    "section": "2.2 Klassen, Typen, Objekte und Datentypen",
    "text": "2.2 Klassen, Typen, Objekte und Datentypen\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt geh√∂rt zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt, etwa welche Daten gespeichert und welche Funktionen ausgef√ºhrt werden k√∂nnen. Objekte ‚Äúerben‚Äù die Eigenschaften der Klasse, zu der sie geh√∂ren. In Python werden Klassen (class) auch Typen (type) genannt (In den Anf√§ngen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\n\nDatentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert ‚Äú1‚Äù ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Auspr√§gung einer kategorialen Variablen repr√§sentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa f√ºr die Klasse der Ganzzahlen ‚Äòint‚Äô und den Datentyp ‚Äòint‚Äô. Jedes Objekt geh√∂rt zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und geh√∂ren einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp.\n\ntype(print)\n\nbuiltin_function_or_method\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einf√ºhren, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‚Äòfloat32‚Äô) und 64 Bit Speicherplatzbedarf (Datentyp ‚Äòfloat64‚Äô). Objekte vom Datentyp float32 und float64 geh√∂ren zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit k√∂nnen gr√∂√üere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel¬†2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine f√ºr die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.\n\n\nZahlen\nZu den Zahlen geh√∂ren Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n0.001 oder 1000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.\n\n\nAufgaben Zahlen\nL√∂sen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\nùü£ + ùü§6 / ùüß = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nMusterl√∂sung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und geh√∂ren in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary werden wir sp√§ter kennenlernen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / gr√∂√üer als / gr√∂√üer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis¬†2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint(5 & 10)\nprint(10 &gt; False &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\n0\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nL√∂sen Sie die Aufgaben mit Python.\n\nIst das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\nIst es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichenfolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichenfolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Das Steuerzeichen \\\\ erm√∂glicht die gleichen \\\"Anf√ºhrungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nDas Steuerzeichen \\ erm√∂glicht die gleichen \"Anf√ºhrungszeichen\" in der Ausgabe von print.\nErst ein    Tabstopp, dann eine\nneue Zeile.\n\n\nEin vorangestelltes r bewirkt, dass das Steuerzeichen \\ nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\nDie Daten liegen unter: C:  olle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\n\n\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_26864\\2438942157.py:1: SyntaxWarning: invalid escape sequence '\\w'\n  print(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\n\n\n\nOperationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n# string + string\nprint('a' + 'b') # -, *, / funktionieren nicht\nprint(\"\\n\")\n\n# string + Zahl\nprint(15 * 'a') # +, -, / funktionieren nicht\nprint(\"\\n\")\n\n# logische Operatoren\nprint('a' &lt; 'b', 'a' &gt;= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n\nab\n\n\naaaaaaaaaaaaaaa\n\n\nTrue False True\na b\n\n\n\n\nAufgaben Zeichenfolgen\nL√∂sen Sie die Aufgaben mit Python.\n\nWas passiert, wenn Sie die Zeichenfolge ‚ÄúPython‚Äù mit ‚Äúfor beginners‚Äù addieren?\nErzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge ‚Äútick tack‚Äù.\nWelche Zeichenfolge ist kleiner, ‚ÄúAachen‚Äù oder ‚ÄúBern‚Äù. Warum ist das so, wie werden Zeichenfolgen verglichen?\nGeben Sie den Dateipfad aus: ‚Äú~_daten‚Äù\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.1: Musterl√∂sung Aufgaben Zeichenfolgen\n\n\n\n\n\n\n\n\n\n\n\nVariablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‚Äòfloat‚Äô zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder √ºbersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAufl√∂sung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich ‚Äúsprechende‚Äù, das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchl√ºsselw√∂rter und Funktionsnamen\n\n\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable f√ºr den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.2: Musterl√∂sung Aufgaben Variablen\n\n\n\n\n\n\n\n\n\n(Arnold 2023a)",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "Python-Code.html#aufgaben-zeichenfolgen",
    "href": "Python-Code.html#aufgaben-zeichenfolgen",
    "title": "2¬† Python-Code",
    "section": "2.3 Aufgaben Zeichenfolgen",
    "text": "2.3 Aufgaben Zeichenfolgen\n\nVariablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‚Äòfloat‚Äô zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder √ºbersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAufl√∂sung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich ‚Äúsprechende‚Äù, das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchl√ºsselw√∂rter und Funktionsnamen\n\n\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable f√ºr den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.1: Musterl√∂sung Aufgaben Variablen",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html",
    "href": "python-code.html",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code m√ºssen nur wenige Punkte beachtet werden.\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n# Ein reiner Kommentar\n# print(\"Python ist gro√üartig!\") # auskommentierter Code, gefolgt von einem Kommentar\nprint(\"Python ist ziemlich gut.\") # auszuf√ºhrender Code, gefolgt von einem Kommentar\n\nPython ist ziemlich gut.\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\nIn dem obenstehenden Beispiel werden Variablen angelegt. Mit Variablen besch√§ftigten wir uns sp√§ter in diesem Abschnitt. Trotzdem m√∂chte ich Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir kommen sp√§ter darauf zur√ºck.\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html#python-code",
    "href": "python-code.html#python-code",
    "title": "2¬† Python-Code",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen kennzeichnet einen zusammengeh√∂rigen Code-Block. Innerhalb eines Code-Blocks muss immer die gleiche Anzahl Leerzeichen verwendet werden. Es muss mindestens ein Leerzeichen gesetzt werden, ansonsten ist die Anzahl der Leerzeichen beliebig. √úblich sind 2 oder 4 Leerzeichen. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html#klassen-typen-objekte-und-datentypen",
    "href": "python-code.html#klassen-typen-objekte-und-datentypen",
    "title": "2¬† Python-Code",
    "section": "2.2 Klassen, Typen, Objekte und Datentypen",
    "text": "2.2 Klassen, Typen, Objekte und Datentypen\nPython ist eine objektorientierte Programmiersprache. Jedes Objekt geh√∂rt zu einer Klasse, die als Blaupause die Eigenschaften und Verhaltensweisen des Objekts bestimmt, etwa welche Daten gespeichert und welche Funktionen ausgef√ºhrt werden k√∂nnen. Objekte ‚Äúerben‚Äù die Eigenschaften der Klasse, zu der sie geh√∂ren. In Python werden Klassen (class) auch Typen (type) genannt (In den Anf√§ngen von Python waren Klassen und Typen noch verschieden). Ein kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + 'a', \"Zeichen werden verkettet.\")\nprint(type(True and False), True + False + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; aa Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, also nicht existenten Werten:\n\ntry:\n  None + None\nexcept TypeError as error:\n  print(error)\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Typen (Klassen).\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\n\nDatentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert ‚Äú1‚Äù ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Auspr√§gung einer kategorialen Variablen repr√§sentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa f√ºr die Klasse der Ganzzahlen ‚Äòint‚Äô und den Datentyp ‚Äòint‚Äô. Jedes Objekt geh√∂rt zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und geh√∂ren einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp.\n\ntype(print)\n\nbuiltin_function_or_method\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einf√ºhren, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‚Äòfloat32‚Äô) und 64 Bit Speicherplatzbedarf (Datentyp ‚Äòfloat64‚Äô). Objekte vom Datentyp float32 und float64 geh√∂ren zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit k√∂nnen gr√∂√üere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel¬†2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine f√ºr die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.\n\n\nZahlen\nZu den Zahlen geh√∂ren Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n0.001 oder 1000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05\n\n\n\n\n\nArithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.\n\n\nAufgaben Zahlen\nL√∂sen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\nùü£ + ùü§6 / ùüß = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.1: Musterl√∂sung Zahlen\n\n\n\n\n\n\n\n\n\n\n\nBoolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und geh√∂ren in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary lernen wir in den folgenden Kapiteln kennen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.\n\n\n\n\nLogische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / gr√∂√üer als / gr√∂√üer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis¬†2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint(5 & 10)\nprint(10 &gt; False &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\n0\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].\n\n\n\n\n\n\n\n\nAufgaben boolsche Werte\nL√∂sen Sie die Aufgaben mit Python.\n\nIst das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\nIst es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.\n\n\n\nZeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\nprint('eine x-beliebige Zeichenfolge')\nprint(\"noch eine x-beliebige Zeichenfolge\")\n\neine x-beliebige Zeichenfolge\nnoch eine x-beliebige Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Das Steuerzeichen \\\\ erm√∂glicht die gleichen \\\"Anf√ºhrungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nDas Steuerzeichen \\ erm√∂glicht die gleichen \"Anf√ºhrungszeichen\" in der Ausgabe von print.\nErst ein    Tabstopp, dann eine\nneue Zeile.\n\n\nEin vorangestelltes r bewirkt, dass das Steuerzeichen \\ nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\nDie Daten liegen unter: C:  olle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\n\n\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\w'\nC:\\Users\\mapoe004\\AppData\\Local\\Temp\\ipykernel_15736\\2438942157.py:1: SyntaxWarning: invalid escape sequence '\\w'\n  print(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\n\n\n\nOperationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n# string + string\nprint('a' + 'b') # -, *, / funktionieren nicht\nprint(\"\\n\")\n\n# string + Zahl\nprint(15 * 'a') # +, -, / funktionieren nicht\nprint(\"\\n\")\n\n# logische Operatoren\nprint('a' &lt; 'b', 'a' &gt;= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n\nab\n\n\naaaaaaaaaaaaaaa\n\n\nTrue False True\na b\n\n\n\n\nAufgaben Zeichenfolgen\nL√∂sen Sie die Aufgaben mit Python.\n\nWas passiert, wenn Sie die Zeichenfolge ‚ÄúPython‚Äù mit ‚Äúfor beginners‚Äù addieren?\nErzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge ‚Äútick tack‚Äù.\nWelche Zeichenfolge ist kleiner, ‚ÄúAachen‚Äù oder ‚ÄúBern‚Äù. Warum ist das so, wie werden Zeichenfolgen verglichen?\nGeben Sie den Dateipfad aus: ‚Äú~_daten‚Äù\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.2: Musterl√∂sung Aufgaben Zeichenfolgen\n\n\n\n\n\n\n\n\n\n\n\nVariablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‚Äòfloat‚Äô zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder √ºbersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAufl√∂sung\n\n\n\n\n\n\nprint(type(var_3), type(variable1), type(a))\n\n&lt;class 'bool'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich ‚Äúsprechende‚Äù, das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchl√ºsselw√∂rter und Funktionsnamen\n\n\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen problemslos neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.\n\n\n\n\n\nAufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable f√ºr den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.3: Musterl√∂sung Aufgaben Variablen\n\n\n\n\n\n\n\n\n\n(Arnold 2023a)",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "python-code.html#ausgabe-formatieren",
    "href": "python-code.html#ausgabe-formatieren",
    "title": "2¬† Python-Code",
    "section": "2.3 Ausgabe formatieren",
    "text": "2.3 Ausgabe formatieren\nMit sogenannten f-Strings k√∂nnen formatierte Zeichenketten erstellt werden. Formatierte Zeichenketten werden mit einem vorgesetzten f vor den Anf√ºhrungsstrichen erstellt. Werte und Variablen k√∂nnen durch Platzhalter eingesetzt werden, die mit geschweiften Klammern {} angegeben und mit Formattierungsinformationen versehen werden. Das Formatierungsformat innerhalb der geschweiften Klammer ist, vereinfacht dargestellt:\n{Variablenname:PlatzbedarfAusgabetyp}\nEin f-String mit Platzhaltern ohne Formatierungsinformationen:\n\nzahl1 = 5\nzahl2 = 7\nverh√§ltnis = zahl1 / zahl2\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.7142857142857143.\n\n\nDie Anzahl der darzustellenden Nachkommastellen kann wie folgt festgelegt werden: {verh√§ltnis:.2f}.\n\n: leitet die Formatierungsbefehle ein.\n. gibt an, dass Formatierungsinformationen f√ºr die Darstellung hinter dem Dezimaltrennzeichen folgen.\n2 ist der Wert f√ºr die darzustellenden Nachkommastellen.\nf spezifiziert die Darstellung einer Gleitkommazahl ‚Äòfloat‚Äô.\n\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:.2f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.71.\n\n\nDas gleiche ist mit einem Wert m√∂glich:\n\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:.3f}.\")\n\nDas Verh√§ltnis ist genauer 0.714.\n\n\nEin Wert f√ºr die insgesamt darzustellenden Stellen wird vor dem Dezimaltrennzeichen √ºbergeben {verh√§ltnis:7.2f} bzw. inklusive f√ºhrender Nullen {verh√§ltnis:07.2f}:\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:7.2f}.\")\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:07.3f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist    0.71.\nDas Verh√§ltnis ist genauer 000.714.\n\n\nDas Dezimaltrennzeichen z√§hlt als eine Stelle.\nH√§ufig verwendete Formatierung sind:\n\nganze ZahlenGleitkommazahlenZeichenketten\n\n\nGanze Zahlen haben den Ausgabetyp d.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nnd\nn-Stellen werden f√ºr die Ausgabe verwendet\n\n\n0nd\nAusgabe von n-Stellen, wobei die Leerstellen mit Nullen aufgef√ºllt werden.\n\n\n+d\nAusgabe des Vorzeichens auch bei positiven Zahlen\n\n\n\n\n\nGleitkommazahlen haben die Ausgabetypen f und e.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\n.mf\nm-Stellen werden f√ºr die Nachkommastellen genutzt.\n\n\nn.mf\nInsgesamt werden n-Stellen verwendet, wobei m-Stellen f√ºr die Nachkommastellen genutzt werden.\n\n\nn.me\nGenauso, aber die Ausgabe erfolgt in exponentieller Schreibweise.\n\n\n\n\n\nZeichenketten haben den Ausgabetyp s.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nns\nInsgesamt werden n-Stellen verwendet.\n\n\n&lt;ns, &gt;ns, ^ns\nGenauso, jedoch wird die Zeichenkette linksb√ºndig, rechtsb√ºndig bzw. zentriert platziert.\n\n\n\n\n\n\nEine Auflistung aller verf√ºgbaren Ausgabetypen findet sich in der Python Dokumentation.\n\nAufgaben Ausgabe\n\n‚ÄúGleitkommazahlen k√∂nnen nat√ºrlich, z. B. {1015.39:12.4f}, oder wissenschaftlich, {1015.39:e}, dargestellt werden.‚Äù\n\n\nVer√§ndern Sie die nat√ºrliche Schreibwese so, dass nur noch eine Stelle nach dem Komma angezeigt wird. Was f√§llt auf?\nVer√§ndern Sie die wissenschaftliche Schreibweise so, dass anstelle von e die Zehnerbasis als E geschrieben wird.\n\n\nWandeln Sie die Zahl 1015.39 in eine Zeichenkette um und stellen Sie diese mit 12 Stellen rechtsb√ºndig dar.\nGeben Sie mit Hilfe der formatierten Zeichenketten eine Tabelle aus, welche die Spalten \\(x\\), \\(x^2\\) und \\(x^3\\) f√ºr ganze Zahlen zwischen -2 und 2 auflistet.\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.4: Musterl√∂sung Ausgabe\n\n\n\n\n\n\n\n\n\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Python-Code</span>"
    ]
  },
  {
    "objectID": "funktionen.html",
    "href": "funktionen.html",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "",
    "text": "3.1 Funktionen und Methoden\nIn Python gibt es zwei Arten von Funktionen: Funktionen und Methoden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-und-methoden",
    "href": "funktionen.html#funktionen-und-methoden",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "",
    "text": "Funktionen\nFunktionen werden √ºber ihren Funktionsnamen gefolgt von runden Klammern () aufgerufen. Ein Beispiel ist die Funktion print(), der Objekte unabh√§ngig von ihrem Datentyp √ºbergeben werden k√∂nnen.\n\nvar_str = 'ABC'\nvar_int = 26\nvar_bool = True\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_str))\nprint(\"Die Variable var_2 hat den Typ\", type(var_int))\nprint(\"Die Variable var_3 hat den Typ\", type(var_bool))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nFunktionen m√ºssen immer einen Wert zur√ºckgeben. Wenn Funktionen keinen Wert zur√ºckgeben k√∂nnen oder sollen, wird der Wert None zur√ºckgegeben, der nicht existente Werte kennzeichnet.\n\nres = print( 15 )\nprint(res)\n\n15\nNone\n\n\n\n\nMethoden\nMethoden sind eine Besonderheit objektorientierter Programmiersprachen. Im vorherigen Kapitel wurde erl√§utert, dass in Python Variablen bzw. Objekte abh√§ngig von den in ihnen gespeicherten Werte einen passenden Datentyp erhalten. Methoden sind Funktionen, die zu einem bestimmten Datentyp geh√∂ren. Methoden werden getrennt durch einen Punkt . hinter Objekten mit ihrem Namen aufgerufen: variable.methode bzw. (wert).methode. Beispielsweise sind .upper(), .lower() und .title f√ºr Zeichenfolgen definierte Methoden.\n\ntoller_text = \"Python 3.12 ist gro√üartig.\"\n\nprint(toller_text.upper())\nprint(toller_text.lower())\nprint(toller_text.title(), \"\\n\")\n\nprint((\"Mit in Klammern gesetzten Werten klappt es auch.\").upper())\n\nPYTHON 3.12 IST GROSSARTIG.\npython 3.12 ist gro√üartig.\nPython 3.12 Ist Gro√üartig. \n\nMIT IN KLAMMERN GESETZTEN WERTEN KLAPPT ES AUCH.\n\n\nF√ºr Objekte mit einem unpassenden Datentyp sind Methoden wie .lower() nicht verf√ºgbar.\n\nprint((1).upper())\n\n\n\n'int' object has no attribute 'upper'\n\n\nMethoden k√∂nnen verkettet und so nacheinander ausgef√ºhrt werden. In diesem Beispiel wird die Zeichenfolge ‚ÄòKatze‚Äô klein geschrieben, dann die H√§ufigkeit des Buchstabens ‚Äòk‚Äô gez√§hlt und schlie√ülich gepr√ºft, ob der H√§ufigkeitswert eine Ganzzahl ist.\n\nprint('Katze'.lower().count('k').is_integer())\n\nTrue\n\n\nWelche Methoden f√ºr ein Objekt verf√ºgbar sind, kann mit der Funktion dir(objekt) bestimmt werden. Die Ausgabe der Funktion ist aber h√§ufig sehr umfangreich. Um die relevanten Eintr√§ge auszuw√§hlen, muss die Ausgabe gefiltert werden. Notwendig ist das aber nicht - Interessierte schauen in Beispiel¬†3.1.\n\n\n\n\n\n\nBeispiel¬†3.1: Methoden eines Objekts bestimmen\n\n\n\n\n\nMit der Funktion dir(objekt) k√∂nnen die verf√ºgbaren Methoden eines Objekts ausgegeben werden. Dabei werden jedoch auch die Attribute und die Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel f√ºr die Ganzzahl 1:\n\nprint(dir(1))\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']\n\n\nUm die Ausgabe auf Methoden einzugrenzen, kann folgende Funktion verwendet werden:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if callable (getattr(objekt, attr))]\nprint(attribute)\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'from_bytes', 'is_integer', 'to_bytes']\n\n\nMit doppelten Unterstrichen umschlossene Methoden sind f√ºr die Klasse definierte Methoden. Folgende Funktion entfernt Methoden mit doppelten Unterstrichen aus der Ausgabe:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(attribute)\n\n['as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'from_bytes', 'is_integer', 'to_bytes']\n\n\nIm Fall einer Ganzzahl k√∂nnen Methoden (zur Abgrenzung von Gleitkommazahlen in umschlie√üenden Klammern) wie folgt aufgerufen werden:\n\n(1).as_integer_ratio()\n\n(1, 1)\n\n\nDie Methoden des Objekts ‚Äòtoller_text‚Äô:\n\nobjekt = toller_text\n\nattribute = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(attribute)\n\n['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-schreiben",
    "href": "funktionen.html#funktionen-schreiben",
    "title": "3¬† Funktionen",
    "section": "3.3 Funktionen schreiben",
    "text": "3.3 Funktionen schreiben\nIch glaube, hier oder sp√§testens im n√§chsten Kapitel sollte das Lesen der Dokumentation trainiert werden?!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufruf",
    "href": "funktionen.html#aufruf",
    "title": "3¬† Funktionen",
    "section": "3.2 Aufruf",
    "text": "3.2 Aufruf\nFunktionen werden √ºber ihren Funktionsnamen gefolgt von runden Klammern () aufgerufen. Dies kennen Sie bereits aus den vorherigen Kapiteln. Getrennt durch Kommata k√∂nnen mehrere Argumente √ºbergeben werden.\n\nprint(\"Die Funktion print wurde schon oft gezeigt.\", \"Das zweite Funktionsargument.\")\n\nDie Funktion print wurde schon oft gezeigt. Das zweite Funktionsargument.\n\n\nArgumente steuern die Programmausf√ºhrung. Die f√ºr die Funktion print() verf√ºgbaren Argumente stehen in der Dokumentation der Funktion.\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n‚Ä¶ erkl√§ren: verpflichtende und optionale Argumente, positionale und Schl√ºsselwortargumente\n\nverpflichtende und optionale Argumente Was gibt es f√ºr Argumente: verpflichtende und optionale Argumente: Welche Argumente muss man √ºbergeben (die ohne =), welche kann man √ºbergeben (die mit =).\npositionale und Schl√ºsselwortargumente\n\nAm Beispiel print: Das Argument *objects nimmt die Elemente entgegen, die mit print ausgegeben werden sollen. Das Sternchen * signalisiert zum einen, dass eine beliebige Anzahl an Argumenten an das Argument *objects √ºbergeben werden kann. Zum anderen zeigt das Sternchen * an, dass es sich um ein positionales Argument handelt. Die Elemente, die mit print ausgegeben werden sollen, m√ºssen an erster Stelle stehen.\n‚Ä¶ demgegen√ºber Schl√ºsselwortargumente die k√∂nnen √ºberall stehen - in diesem Fall au√üer an der ersten Stelle, denn dort muss das positionale Objekt *objects stehen.\n\nDie Eingabe von Daten erfolgt mit dem Funktionsaufruf Verarbeitung: Steuerung √ºber Argumente Ausgabe: return-statement\n\nFunktionen ‚Ä¶\n\nhaben einen Funktionsnamen gefolgt von runden Klammern (), √ºber den Sie aufgerufen werden.\n\nm√ºssen immer einen Wert zur√ºckgeben. Wenn Funktionen keinen Wert zur√ºckgeben k√∂nnen oder sollen, wird der Wert None zur√ºckgegeben, der nicht existente Werte kennzeichnet.\n\nwichtiger Tipp: die vorausgef√ºllten Werte sind leider nicht immer die default-Werte",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#argumente-geh√∂ren-zum-aufruf",
    "href": "funktionen.html#argumente-geh√∂ren-zum-aufruf",
    "title": "3¬† Funktionen",
    "section": "3.3 Argumente geh√∂ren zum Aufruf",
    "text": "3.3 Argumente geh√∂ren zum Aufruf\nFunktionen k√∂nnen Argumente entgegennehmen, die die Programmausf√ºhrung steuern.\n\n\n\n\n\n\nTipp¬†3.2: Dokumentation\n\n\n\n\n\nverpflichtende und optionale Argumente: Welche Argumente muss man √ºbergeben (die ohne =), welche kann man √ºbergeben (die mit =). Einige Funktionen haben dutzende dokumentierte Argumente und k√∂nnen √ºber die Platzhalter *args und **kwargs weitere Argumente aufnehmen. Bedeutung des Sterns: (Aus glob:) Das Argument pathname kann als Schl√ºsselwort oder positional √ºbergeben werden, die √ºbrigen Argumente m√ºssen als Schl√ºsselwort √ºbergeben werden (dies signalisiert das Zeichen *) Das *, das positionale Argumente von Schl√ºsselwortargumenten trennt, kommt in der Dokumentation immer nur einmal vor. Erkl√§rung *args und **kwargs siehe https://book.pythontips.com/en/latest/args_and_kwargs.html\nwichtig ist auch: leider sind die Startwerte in der Funktionsdokumentation nicht (immer) die default-Werte ‚Äî da habe ich ein Beispiel in meiner zuerledigen Liste ‚Äî daraus kann man gleich eine Aufgabe machen, den default-Wert heraussuchen zu lassen.\n\n\n\nIn den bisherigen Kapiteln haben Sie bereits die Funktion print() kennengelernt, mit der (formatierte) Zeichenfolgen, Variablen und Werte ausgegeben werden k√∂nnen.\n\nprint(\"Die Funktion print gibt Zeichenfolgen, Variablen und Werte aus.\")\n\nDie Funktion print gibt Zeichenfolgen, Variablen und Werte aus.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#ausgabe",
    "href": "funktionen.html#ausgabe",
    "title": "3¬† Funktionen",
    "section": "3.3 Ausgabe",
    "text": "3.3 Ausgabe\nFunktionen m√ºssen immer einen Wert zur√ºckgeben. Wenn Funktionen keinen Wert zur√ºckgeben k√∂nnen oder sollen, wird der Wert None zur√ºckgegeben, der nicht existente Werte kennzeichnet.\n\nres = print( 15 )\nprint(res)\n\n15\nNone",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#eigene-funktionen-schreiben",
    "href": "funktionen.html#eigene-funktionen-schreiben",
    "title": "3¬† Funktionen",
    "section": "3.4 Eigene Funktionen schreiben",
    "text": "3.4 Eigene Funktionen schreiben\nIt‚Äôs important to note that the optional argument must always appear after any required arguments when defining the function\nusing positional Arguments\n*args wird verwendet, um eine variable Anzahl von nicht-schl√ºsselwortlichen Argumenten zu empfangen. Innerhalb der Funktion wird args als eine Tuple behandelt, die alle √ºbergebenen Argumente enth√§lt.\nusing Keyword Arguments in Python\n**kwargs ist √§hnlich wie *args, aber es wird verwendet, um eine variable Anzahl von schl√ºsselwortbasierten Argumenten zu empfangen. Innerhalb der Funktion wird kwargs als ein Dictionary behandelt.\nKeyword arguments allow developers to specify which arguments should have which values when calling a Python function. This is especially useful if order isn‚Äôt important. To use keyword arguments, pass in a dictionary with the keyword and its associated value as an argument. For example:\nmy_dict = {‚Äúoptional_arg1‚Äù: 42} func_name(required_arg1, required_arg2, **my_dict)\nAusgabe: return-statement\n\nKontrollstrukturen\n\nFallunterscheidung if\n\n\nSchleifen while, for\n\n\n\nlambda",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html",
    "href": "sammeltypen.html",
    "title": "4¬† Sammeltypen",
    "section": "",
    "text": "4.1 Listen\nWie alle Typen in Python, werden Listen durch Zuweisung erstellt. Bei der Definition einer Liste, werden die Elemente durch [] eingeklammert und mit Kommata , getrennt. Listen k√∂nnen mit dem +-Operator verkettet werden. * verkettet eine Liste n-mal.\ntext_variable = 'abc'\n\nliste1 = [1, 'xy', True, text_variable]\nprint(liste1)\n\n# Listen k√∂nnen auch Listen enthalten\nliste2 = [None, liste1]\nprint(liste2)\n\n# Listen k√∂nnen mit + und * verkettet werden\nprint(liste1 + liste2)\nprint(liste1 * 2)\n\n[1, 'xy', True, 'abc']\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', 1, 'xy', True, 'abc']\nEine leere Liste kann durch Zuweisung von [] erstellt werden.\nleere_liste = []\nprint(leere_liste)\n\n[]",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-und-methoden-1",
    "href": "funktionen.html#funktionen-und-methoden-1",
    "title": "3¬† Funktionen",
    "section": "3.4 Funktionen und Methoden",
    "text": "3.4 Funktionen und Methoden\nZahlen: Funktion round(Wert, Stellen). Hier Querverweis auf Outputformatierung: f-strings, die bereits verwendete Funktion format(), round()‚Ä¶ ein paar Funktionen f√ºr die Ausgabe von strings ohne ‚Äô‚Äô und ohne ,\n\nprint(format(0.1, ‚Äò.17g‚Äô)) # 17 signifikante Stellen\nprint(format(0.1, ‚Äò.17f‚Äô)) # 17 Stellen nach dem Komma\n\n\nprint(round(0.1 + 0.2, 2))\n\n0.3\n\n\nStrings: Methoden .lower(), .upper(), .title() https://www.w3schools.com/python/python_ref_string.asp\nAls n√§chstes Kapitel: Programmsteuerung\n\nFallunterscheidung if\n\n\nSchleifen while, for",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#argumente",
    "href": "funktionen.html#argumente",
    "title": "3¬† Funktionen",
    "section": "3.2 Argumente",
    "text": "3.2 Argumente\nVielen Funktionen und Methoden k√∂nnen getrennt durch Kommata mehrere Argumente √ºbergeben werden. Argumente steuern die Programmausf√ºhrung. Argumente werden auch als Parameter bezeichnet.\n\nprint(\"Die Funktion print wurde schon oft gezeigt.\", \"Das ist das zweite Argument.\")\n\nDie Funktion print wurde schon oft gezeigt. Das ist das zweite Argument.\n\n\nDie f√ºr die Funktion print() verf√ºgbaren Argumente stehen in der Dokumentation der Funktion.\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n\nArgumente ohne vorangestelltes Gleichheitszeichen = m√ºssen beim Funktions- bzw. Methodenaufruf √ºbergeben werden. Argumente mit vorangestellten Gleichheitszeichen = k√∂nnen beim Aufruf √ºbergeben werden, es handelt sich um optionale Argumente.\nArgumente k√∂nnen in Python entweder als positionales Argument √ºbergeben werden, das hei√üt Python ordnet Eingaben entsprechend ihrer Reihenfolge Argumenten zu. Alternativ k√∂nnen Argumente als Schl√ºsselwort √ºbergeben werden, die Zuordnung von Eingaben erfolgt √ºber den Namen des Arguments.\ndas vorangestellte Sternchen vor einem Argument *objects entspricht einem Platzhalter f√ºr eine beliebige Anzahl von Argumenten.\n\n*objects ist also ein positionales Argument (es steht immer an erster Stelle), das keinen Standardwert hat und dem beliebig viele Argumente √ºbergeben werden k√∂nnen (n Eingaben stehen also an den ersten n-Stellen). Dadurch, dass beliebig viele Argumente √ºbergeben werden k√∂nnen, funktioniert auch ein leerer Aufruf der Funktion print(), obwohl das Argument *objects verpflichtend √ºbergeben werden muss.\nDie weiteren Argumente der Funktion print k√∂nnen als Schl√ºsselwort √ºbergeben werden. Die Werte hinter dem Gleichheitszeichen zeigen die Standardwerte (default value) der Argumente an. Diese werden verwendet, wenn ein Argument nicht explizit beim Aufruf √ºbergeben wird.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n1_x_2_x_3\n\n\n\n\n\n\n\n\nL√∂sung\n\n\n\n\n\n\nprint(1, 2, 3, sep = \"_x_\")\n\n\n\n\n\n\n\n\n\n\nTipp¬†3.2: Standardwert None\n\n\n\n\n\nEinige Funktionen verwenden das Schl√ºsselwort None zur Kennzeichnung des Standardwerts. Ein Beispiel ist die NumPy-Funktion numpy.loadtxt().\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, *, quotechar=None, like=None)\nF√ºr das Argument delimiter ist als Standardwert das Schl√ºsselwort None eingetragen. Wie der Funktionsbeschreibung zu entnehmen ist, ist der Standartwert tats√§chlich das Leerzeichen: ‚ÄúThe default is whitespace.‚Äù\nAuch das Argument usecols hat den Standarwert None. Dies bedeutet aber: ‚ÄúThe default, None, results in all columns being read.‚Äù\n\n\n\nVielen Funktionen k√∂nnen beliebig viele Argumente positional oder als Schl√ºsselwort √ºbergeben werden. Im Allgemeinen wird dies durch die Schl√ºsselw√∂rter *args (positionale Argumente) und **kwargs (key word arguments, Schl√ºsselwortargumente) angezeigt (weitere Informationen dazu finden Sie hier).\n\n\n\n\n\n\nTipp¬†3.3: Bedeutung der Argumente * und /\n\n\n\n\n\nDie Argumente * und / zeigen an, welche Argumente positional und welche per Schl√ºsselwort √ºbergeben werden k√∂nnen bzw. m√ºssen.\n\n\n\n\n\n\n\n\n\nLinke Seite\nTrennzeichen\nRechte Seite\n\n\n\n\nnur positionale Argumente\n/\npositionale oder Schl√ºsselwortargumente\n\n\npositionale oder Schl√ºsselwortargumente\n*\nnur Schl√ºsselwortargumente\n\n\n\nhttps://realpython.com/python-asterisk-and-slash-special-parameters/\nBeide Steuerzeichen k√∂nnen innerhalb einer Funktionsdefinition vorkommen, allerdings nur in der Reihenfolge / und *. Im umgekehrten Fall w√§re es unm√∂glich, Argumente zu √ºbergeben.\n\nEin Beispiel ist die Funktion glob aus dem gleichnamigen Modul.\nglob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)\nDas Argument pathname kann positional (an erster Stelle) oder als Schl√ºsselwort √ºbergeben werden. Die √ºbrigen Argumente m√ºssen als Schl√ºsselwortargumente √ºbergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufgaben-funktionen",
    "href": "funktionen.html#aufgaben-funktionen",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.3 Aufgaben Funktionen",
    "text": "3.3 Aufgaben Funktionen\n\nRichtig oder falsch: Methoden stehen abh√§ngig vom Datentyp eines Werts oder eines Objekts zur Verf√ºgung.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n\n1_x_2_x_3\n\n\n\nSchlagen Sie in der Dokumentation die Funktion bool() nach.\n\n\nWelche Parameter nimmt die Funktion entgegen und welche davon sind optional?\nWelche Argumente werden positional und welche als Schl√ºssel√ºbergeben? Ist die Art der √úbergabe w√§hlbar oder festgelegt?\n\n\n\n\n\n\n\nL√∂sungen\n\n\n\n\n\nAufgabe 1: richtig\nAufgabe 2\n\nprint(1, 2, 3, sep = \"_x_\")\n\nAufgabe 3: Die Funktion bool() hat ein optionales Argument object mit dem Standardwert False. Das Argument muss positional √ºbergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#kontrollstrukturen",
    "href": "funktionen.html#kontrollstrukturen",
    "title": "3¬† Funktionen",
    "section": "4.1 Kontrollstrukturen",
    "text": "4.1 Kontrollstrukturen\n\nFallunterscheidung if\n\n\nSchleifen while, for",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#parameter",
    "href": "funktionen.html#parameter",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.2 Parameter",
    "text": "3.2 Parameter\nVielen Funktionen und Methoden k√∂nnen getrennt durch Kommata mehrere Parameter √ºbergeben werden (Die Werte, die als Parameter √ºbergeben werden, werden Argumente genannt, Python-Dokumentation). Parameter steuern die Programmausf√ºhrung. Die f√ºr die Funktion print() verf√ºgbaren Parameter stehen in der Dokumentation der Funktion:\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n*objects, sep, end, file und flush sind die Parameter der Funktion print().\n\nParameter ohne vorangestelltes Gleichheitszeichen = m√ºssen beim Funktions- bzw. Methodenaufruf √ºbergeben werden. Parameter mit vorangestellten Gleichheitszeichen = k√∂nnen beim Aufruf √ºbergeben werden, es handelt sich um optionale Parameter.\nDie Werte hinter dem Gleichheitszeichen zeigen die Standardwerte (default value) der Parameter an. Diese werden verwendet, wenn ein Argument nicht explizit beim Aufruf √ºbergeben wird.\n\n\n\n\n\n\n\nTipp¬†3.2: Ausnahmen bei Standardwerten\n\n\n\n\n\nBei den in der Funktionsdefinition genannten Werten handelt es sich nicht immer um die tats√§chlichen Standardwerte. Es empfiehlt sich deshalb, wenn eine Funktion verwendet wird, die Beschreibung der Parameter zu lesen.\nEinige Funktionen verwenden das Schl√ºsselwort None zur Kennzeichnung des Standardwerts. Der Wert None dient dabei als Platzhalter. Ein Beispiel ist die NumPy-Funktion numpy.loadtxt().\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, /\n              skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, /\n              *, quotechar=None, like=None)\n\nF√ºr den Parameter delimiter ist als Standardwert das Schl√ºsselwort None eingetragen. Wie der Funktionsbeschreibung zu entnehmen ist, ist der Standartwert tats√§chlich das Leerzeichen: ‚ÄúThe default is whitespace.‚Äù\nAuch der Parameter usecols hat den Standarwert None: ‚ÄúThe default, None, results in all columns being read.‚Äù\n\nEin weiteres Beispiel ist die Funktion pandas.read_csv(). Einige Argumente haben den Standardwert &lt;no_default&gt;. (Im Folgenden werden nur ausgew√§hlte Parameter gezeigt).\npandas.read_csv(sep=&lt;no_default&gt;, verbose=&lt;no_default&gt;)\nAus der Beschreibung k√∂nnen die tats√§chlichen Standardwerte abgelesen werden:\nsep : str, default ‚Äò,‚Äô\nverbose : bool, default False\n\n\n\n\nArgumente k√∂nnen in Python entweder als positionales Argument √ºbergeben werden, das hei√üt, Python erwartet Argumente in einer feststehenden Reihenfolge entsprechend der Parameter der Funktionsdefinition. Alternativ k√∂nnen Argumente als Schl√ºsselwort √ºbergeben werden, die Zuordnung von Eingaben erfolgt √ºber den Namen des Parameters. Standardm√§√üig k√∂nnen Argumente positional oder per Schl√ºsselwort √ºbergeben werden. Abweichungen davon werden durch die Symbole * und / gekennzeichnet (siehe folgenden Tipp).\n\n\n\n\n\n\n\nTipp¬†3.3: Positionale und Schl√ºsselwortargumente, *args und **kwargs\n\n\n\n\n\nDie Symbole * und / zeigen an, welche Parameter positional und welche per Schl√ºsselwort √ºbergeben werden k√∂nnen bzw. m√ºssen.\n\n\n\n\n\n\n\n\n\nLinke Seite\nTrennzeichen\nRechte Seite\n\n\n\n\nnur positionale Argumente\n/\npositionale oder Schl√ºsselwortargumente\n\n\npositionale oder Schl√ºsselwortargumente\n*\nnur Schl√ºsselwortargumente\n\n\n\n(https://realpython.com/python-asterisk-and-slash-special-parameters/)\n\n¬†\nEin Beispiel f√ºr das Trennzeichen * ist die Funktion glob aus dem gleichnamigen Modul. Der Parameter pathname kann positional (an erster Stelle) oder als Schl√ºsselwort √ºbergeben werden. Die √ºbrigen Parameter m√ºssen als Schl√ºsselwortargumente √ºbergeben werden.\nglob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)\nBeide Steuerzeichen k√∂nnen innerhalb einer Funktionsdefinition vorkommen, allerdings nur in der Reihenfolge / und *. Im umgekehrten Fall w√§re es unm√∂glich, Argumente zu √ºbergeben. Ein Beispiel ist die Funktion sorted. Der erste Parameter muss positional √ºbergeben werden, die Parameter key und reverse m√ºssen als Schl√ºsselworte √ºbergeben werden.\nsorted(iterable, /, *, key=None, reverse=False)¬∂\n\n\n\n\n\n\nAusnahmen\n\n\n\nEinige Funktionen weichen von der Systematik ab, beispielsweise die Funktionen min() und max(). Diese sind (u. a.) in der Form definiert:\nmin(iterable, *, key=None)\nmax(iterable, *, key=None)\nBeide Funktionen akzeptieren den Parameter iterable aber nicht als Schl√ºsselwort.\n\n\nVielen Funktionen k√∂nnen beliebig viele Argumente positional oder als Schl√ºsselwort √ºbergeben werden. Im Allgemeinen wird dies durch die Schl√ºsselw√∂rter *args (positionale Argumente) und **kwargs (key word arguments, Schl√ºsselwortargumente) angezeigt. Der Unterschied wird durch das eine bzw. die beiden Sternchen markiert, die Schl√ºsselw√∂rter selbst sind austauschbar (wie bei der Funktion print(*objects)). Das Schl√ºsselwort *args entspricht zugleich dem Symbol * in der Funktionsdefinition, d.¬†h. rechts davon d√ºrfen nur Schl√ºsselwortargumente stehen. Weitere Informationen dazu finden Sie hier.\n\n\n\nIn der Funktionsdefinition von print() ist *objects also ein positionaler Parameter (dieser steht immer an erster Stelle), der keinen Standardwert hat und dem beliebig viele Argumente √ºbergeben werden k√∂nnen (n Eingaben stehen an den ersten n-Stellen). Die weiteren Parameter der Funktion print() sind optional und m√ºssen als Schl√ºsselwort √ºbergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufgaben-funktionen-und-methoden",
    "href": "funktionen.html#aufgaben-funktionen-und-methoden",
    "title": "3¬† Funktionen und Methoden",
    "section": "3.3 Aufgaben Funktionen und Methoden",
    "text": "3.3 Aufgaben Funktionen und Methoden\n\nRichtig oder falsch: Methoden stehen abh√§ngig vom Datentyp eines Werts oder eines Objekts zur Verf√ºgung.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n\n1_x_2_x_3\n\n\n\nSchlagen Sie die Funktion bool() nach.\n\n\nWelche Parameter nimmt die Funktion entgegen und welche davon sind optional?\nWelche Argumente werden positional und welche als Schl√ºssel√ºbergeben? Ist die Art der √úbergabe w√§hlbar oder festgelegt?\n\n\nErstellen Sie eine Variable vom Datentyp ‚Äòstr‚Äô.\n\n\n\n\n\n\n\nL√∂sungen\n\n\n\n\n\nAufgabe 1: richtig\nAufgabe 2\n\nprint(1, 2, 3, sep = \"_x_\")\n\nAufgabe 3: Die Funktion bool() hat ein optionales Argument object mit dem Standardwert False. Das Argument muss positional √ºbergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen und Methoden</span>"
    ]
  },
  {
    "objectID": "funktionen.html#flusskontrolle",
    "href": "funktionen.html#flusskontrolle",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.4 Flusskontrolle",
    "text": "3.4 Flusskontrolle\nDie Flusskontrolle erm√∂glicht es, die Ausf√ºhrung von Programmteilen zu steuern. Anweisungen k√∂nnen √ºbersprungen oder mehrfach ausgef√ºhrt werden.\n\nAbzweigungen\nAbzweigungen erm√∂glichen eine Fallunterscheidung, bei der verschiedene Teile des Skripts ausgef√ºhrt werden.\nIn Python werden Abzweigungen mit dem Schl√ºsselwort if eingeleitet. Dieses wird von der Abzweigbedingung gefolgt und mit einem Doppelpunkt : abgeschlossen. Falls die Abzweigbedingung wahr ist, wird der einger√ºckte Anweisungsblock ausgef√ºhrt.\nif Bedingung:\n    Anweisungsblock\n\n# Beispiel: Zahl kleiner als ein Schwellwert\n\na = 7\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\n\nDie Zahl 7 ist kleiner als 10.\n\n\nEs ist auch m√∂glich einen alternativen Anweisungsblock zu definieren, welcher ausgef√ºhrt wird, wenn die Bedingung falsch ist. Dieser wird mit dem else Schl√ºsselwort umgesetzt.\nif Bedingung:\n    # Bedingung ist wahr\n    Anweisungsblock\nelse:\n    # Bedingung ist falsch\n    Anweisungsblock\n\n# Beispiel: Zahl kleiner als ein Schwellwert mit alternativer Ausgabe\n\na = 13\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\nelse:\n    print( 'Die Zahl', a, 'ist nicht kleiner als 10.')\n\nDie Zahl 13 ist nicht kleiner als 10.\n\n\nEs k√∂nnen auch mehrere Bedingungen √ºbergeben werden.\n\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20\n\na = 1\nif a &lt; 20 and a &gt; 10:\n    print( 'Die Zahl', a, 'liegt zwischen 10 und 20.')\nelse:\n    print( 'Die Zahl', a, 'liegt nicht zwischen 10 und 20.')\n\nDie Zahl 1 liegt nicht zwischen 10 und 20.\n\n\nSchlie√ülich k√∂nnen mehrere alternative Bedingungen gepr√ºft werden. Dies ist zum einen durch das Verschachteln von Abzweigungen m√∂glich.\n\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit verschachtelten Abzweigungen\n\na = 12\nif a &gt; 10:\n    print( 'Die Zahl', a, 'ist gr√∂√üer als 10.' )\n    \n    if a &lt; 20:\n        print( 'Die Zahl', a, 'ist kleiner als 20.' )\n        print( 'Damit liegt die Zahl zwischen 10 und 20.')\n    else:\n        print( 'Die Zahl', a, 'ist gr√∂√üer als 20 und liegt nicht im gesuchten Wertebereich.' )\nelse:\n        print( 'Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\n\nDie Zahl 12 ist gr√∂√üer als 10.\nDie Zahl 12 ist kleiner als 20.\nDamit liegt die Zahl zwischen 10 und 20.\n\n\nZum anderen ist dies mit dem Schl√ºsselwort elif m√∂glich.\n\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit elif\n\na = 112\nif a &lt; 20 and a &gt; 10:\n  print('Die Zahl', a, 'liegt zwischen 10 und 20.')\nelif a &lt; 10:\n  print('Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\nelif a &gt; 20 and a &lt;= 100:\n  print('Die Zahl', a, 'ist gr√∂√üer als 20, aber nicht gr√∂√üer als 100.')\nelif a &gt; 20 and a &lt;= 1000:\n  print('Die Zahl', a, 'ist gr√∂√üer als 20, aber nicht gr√∂√üer als 1000.')\nelse:\n  print('Die Zahl', a, 'liegt nicht zwischen 10 und 20 und ist gr√∂√üer als 1000.')\n\nDie Zahl 112 ist gr√∂√üer als 20, aber nicht gr√∂√üer als 1000.\n\n\n\n\nSchleifen\nSchleifen erm√∂glichen es, Anweisungen zu wiederholen. In Python k√∂nnen while- und for-Schleifen definiert werden. Beide ben√∂tigen:\n\neinen Schleifenkopf, welcher die Ausf√ºhrung des Anweisungsblocks steuert, und\neinen Anweisungsblock, also eine Gruppe von Anweisungen, welche bei jedem Schleifendurchlauf ausgef√ºhrt werden.\n\nDie while-Schleife kommt mit nur einer Bedingung im Schleifenkopf aus und ist die allgemeinere von beiden. Jede for-Schleife kann zu einer while-Schleife umgeschrieben werden (indem ein Z√§hler in den Anweisungsblock integriert wird.) Welcher der beiden Typen verwendet wird, h√§ngt von der jeweiligen Aufgabe ab.\n\nwhile-Schleifen\nEine while-Schleife f√ºhrt den Anweisungsblock immer wieder aus, solange die Ausf√ºhrbedingung wahr ist. Die Schleife wird mit dem Schl√ºsselwort while eingeleitet, gefolgt von der Ausf√ºhrbedingung. Dieser Schleifenkopf wird mit einem Doppelpunkt : abgeschlossen. Darunter wird der einger√ºckte Anweisungsblock definiert.\nwhile Bedingung:\n    Anweisungsblock\nBeim Beginn der Schleife und nach jedem Durchlauf wird die Bedingung gepr√ºft. Ist sie wahr, so wird der Anweisungsblock ausgef√ºhrt, wenn nicht, ist die Schleife beendet und die n√§chste Anweisung au√üerhalb der Schleife wird ausgef√ºhrt.\n\n# Beispiel: Erh√∂hen eines Variablenwertes\n\n# Setzte Startwert\na = 5\n\n# Definiere Schleife, welche solange ausgef√ºhrt \n# wird, wie a kleiner als 10 ist\nwhile a &lt;= 10:\n    # Anweisungsblock der Schleife:\n    \n    # 1. Ausgabe des aktuellen Werts von a \n    print('aktueller Wert von a', a)\n    \n    # 2. Erh√∂hung von a um Eins\n    a += 1\n\n# Ausgabe des Wertes nach der Schleife\nprint('Wert von a nach der Schleife', a)\n\naktueller Wert von a 5\naktueller Wert von a 6\naktueller Wert von a 7\naktueller Wert von a 8\naktueller Wert von a 9\naktueller Wert von a 10\nWert von a nach der Schleife 11\n\n\n\n\n\n\n\n\nHinweis¬†3.1: Endlosschleife\n\n\n\n\n\nwhile-Schleifen f√ºhren zu einer Endlosschleife, wenn die Abbruchbedingung nicht erreicht werden kann. Beispielsweise fehlt in der folgenden Schleife eine M√∂glichkeit f√ºr die Laufvariable x den Wert 5 zu erreichen.\n\nx = 1\n\nwhile x &lt; 5:\n  print(x)\n\nIn diesem Fall k√∂nnen Sie die Programmausf√ºhrung durch Dr√ºcken von Strg+ C beenden.\n\n\n\n\n\nfor-Schleifen\nW√§hrend die while-Schleife ausgef√ºhrt wird, solange eine Bedingung erf√ºllt ist, wird die for-Schleife √ºber eine Laufvariable gesteuert, die eine Sequenz durchl√§uft. Die Syntax sieht wie folgt aus:\nfor Laufvariable in Sequenz:\n  Anweisungsblock\nZur Definition des Schleifenkopf geh√∂ren die beiden Schl√ºsselworte for und in und der Kopf wird mit einem Doppelpunkt : abgeschlossen. Auch hier wird der Anweisungsblock einger√ºckt. Die Sequenz wird mit einem range-Objekt erstellt, das mit der Funktion range(start = 0, stop, step = 1) erzeugt wird. range() nimmt ganzzahlige Werte als positionale Argumente entgegen und erzeugt Ganzzahlen von start bis nicht einschlie√ülich stop mit der Schrittweite step. Dabei ist wichtig, dass Python exklusiv z√§hlt, das hei√üt, Python beginnt standarm√§√üig bei 0 zu z√§hlen und der als Argument stop √ºbergebene Wert wird nicht mitgez√§hlt.\nDa range() ein range-Objekt zur√ºckgibt, kann mit print() nicht unmittelbar die erwartete Ausgabe erzeugt werden.\n\n# range(start = 1, stop = 5) - step wird nicht √ºbergeben, es gilt der Standardwert step = 1\nprint(range(1, 5), type(range(1, 5)))\n\nrange(1, 5) &lt;class 'range'&gt;\n\n\nDieses Verhalten wird faule Auswertung (lazy evaluation) genannt: Die Werte des range-Objekts werden erst erzeugt, wenn Sie ben√∂tigt werden. Im Folgenden Code wird das range-Objekt mit einer Schleife durchlaufen und f√ºr jeden Durchlauf der Wert der Laufvariable i ausgegeben.\n\nfor i in range(1, 5):\n  print(i)\n\n1\n2\n3\n4\n\n\nMit dem Parameter step kann die Schrittweite gesteuert werden.\n\nfor i in range(1, 15, 3):\n  print(i)\n\n1\n4\n7\n10\n13\n\n\nN√ºtzlich ist die Ausgabe des range-Objekts in eine Liste oder in ein Tupel, Sammeltypen, die im n√§chsten Kapitel behandelt werden.\n\n# Ausgabe der geraden Zahlen 1-10 in eine Liste\nprint(\"Liste:\", list(range(2, 11, 2)))\n\n# Ausgabe der ungeraden Zahlen 1-10 in ein Tupel\nprint(\"Tupel:\", tuple(range(1, 11, 2)))\n\nListe: [2, 4, 6, 8, 10]\nTupel: (1, 3, 5, 7, 9)\n\n\nstart und stop k√∂nnen auch negativ sein, step muss immer gr√∂√üer 0 sein.\n\nfor i in range(-5, -1):\n  print(i)\n\n-5\n-4\n-3\n-2\n\n\nstop muss immer gr√∂√üer als start sein. Um eine absteigende Zahlenfolge zu erzeugen, wird die Funktion reversed(sequenz) verwendet.\n\n# Die Ausgabe bleibt leer\nprint(list(range(5, 0)))\n\n# Mit der Funktion reversed geht es\nprint(list(reversed(range(0, 5))))\n\n[]\n[4, 3, 2, 1, 0]\n\n\n\n\nDie Schl√ºsselw√∂rter break und continue\nManchmal kann es notwendig sein, den Anweisungsblock einer Schleife vorzeitig zu verlassen. Daf√ºr k√∂nnen die Schl√ºsselw√∂rter break und continue benutzt werden. Das Schl√ºsselwort break bewirkt, dass die Schleife sofort verlassen wird. Dagegen f√ºhrt das Schl√ºsselwort continue dazu, dass der aktuelle Schleifendurchlauf beendet und der n√§chste Durchlauf begonnen wird.\n\nx = 0\nwhile x &lt; 10:\n\n  x += 1\n\n  # keine geraden Zahlen ausgeben\n  if x % 2 == 0:\n    continue\n\n  # Schleife bei x == 7 beenden\n  if x == 7:\n    break\n\n  print(x)\n\n1\n3\n5\n\n\n\n\n\nAusnahmebehandlung\nDie Ausnahmebehandlung erlaubt es, Python alternative Anweisungen zu geben, die beim Auftreten eines Fehlers ausgef√ºhrt werden sollen. Dies ist beispielsweise beim Einlesen von Datens√§tzen n√ºtzlich, um sich die Ursache von Fehlermeldungen ausgeben zu lassen - eine Technik, die im Querverweis m-EsD vorgestellt wird.\nIn Python gibt es zwei Arten von Fehlern. Dies sind erstens Syntaxfehler, die Python mit einer Fehlermeldung √§hnlich wie der folgenden quitiert. Syntaxfehler werden durch das Schreiben von syntaktisch korrektem Programmcode behoben.\n\nprint(1}\n\n\n\nclosing parenthesis '}' does not match opening parenthesis\n\n\nDie zweite Art von Fehlern sind Ausnahmen (exceptions), die auch bei syntaktisch korrektem Programmcode auftreten k√∂nnen. Ausnahmen f√ºhren auch zu Fehlermeldungen.\n\n# Beispiel 1: Division durch Null\nprint(1 / 0)\n\n\n\ndivision by zero\n\n\n\n# Beispiel 2: undefinierte Variable\nprint(undefinierte_variable)\n\n\n\nname 'undefinierte_variable' is not defined\n\n\nFehlermeldungen wie diese k√∂nnen in Python mit der Ausnahmebehandlung abgefangen werden. Diese wird mit dem Schl√ºsselwort try eingeleitet, das mit dem Doppeltpunkt : abgeschlossen wird. In der n√§chsten Zeile folgt eingr√ºckt der Anweisungblock, der auf Ausnahmen getestet werden soll (Hinweis: Der Anweisungsblock wird tats√§chlich ausgef√ºhrt, √Ñnderungen an Daten oder Dateien sind also m√∂glich.). Anschlie√üend wird mit dem Schl√ºsselwort except, das von einem Doppelpunkt : und in der n√§chsten Zeile von einem einger√ºckten Anweisungsblock gefolgt wird, festgelegt, was beim Aufkommen einer Ausnahme passieren soll. Optional kann mit dem Schl√ºsselwort else nach dem gleichen Schema ein weiterer Anweisungsblock definiert werden, der bei einer erfolgreichen Ausf√ºhrung des Anweisungsblocks unter try zus√§tzlich ausgef√ºhrt wird. Der allgemeiner Aufbau lautet wie folgt:\ntry:\n  Anweisungsblock_1 \nexcept:\n  Anweisungsblock falls Anweisungblock_1 eine Ausnahme erzeugt\nelse:\n  optionaler Anweisungsblock falls Anweisungsblock_1 keine Ausnhame erzeugt\nMithilfe der Ausnahmebehandlungen k√∂nnen die Elemente angezeigt werden, die zu einer Fehlermeldung f√ºhren.\n\na = 1\nb = 2\n\ntry:\n  differenz = a - b\nexcept:\n  print(f\"Die Differenz aus {a} und {b} konnte nicht gebildet werden.\")\nelse:\n  print(f\"Die Differenz aus {a} und {b} ist {differenz}.\")\n\nDie Differenz aus 1 und 2 ist -1.\n\n\n\na = 1\nb = 'abc'\n\ntry:\n  differenz = a - b\nexcept:\n  print(f\"Die Differenz aus {a} und {b} konnte nicht gebildet werden.\")\nelse:\n  print(f\"Die Differenz aus {a} und {b} ist {differenz}.\")\n\nDie Differenz aus 1 und abc konnte nicht gebildet werden.\n\n\nAuch ist es m√∂glich, die Fehlermeldung abzufangen und auszugeben. Daf√ºr wird die Zeile except: wie folgt modifiziert except Exception as error:\n\na = 1\nb = 'abc'\n\ntry:\n  differenz = a - b\nexcept Exception as error:\n  print(f\"Die Differenz aus {a} und {b} konnte nicht gebildet werden.\")\n  print(error)\nelse:\n  print(f\"Die Differenz aus {a} und {b} ist {differenz}.\")\n\nDie Differenz aus 1 und abc konnte nicht gebildet werden.\nunsupported operand type(s) for -: 'int' and 'str'",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "funktionen.html#funktionen-definieren",
    "href": "funktionen.html#funktionen-definieren",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.5 Funktionen definieren",
    "text": "3.5 Funktionen definieren\nDas Definieren eigener Funktionen er√∂ffnet vielf√§ltige M√∂glichkeiten und geh√∂ren zu den m√§chtigsten Werkzeugen in Python:\n\nKomplexe Programme k√∂nnen mit einer einzigen Zeile Code aufgerufen und ausgef√ºhrt werden.\nFunktionen k√∂nnen praktisch beliebig oft aufgerufen werden und sind durch den Einsatz von Parametern und Methoden der Flusskontrolle gleichzeitig in der Lage, flexibel auf wechselnde Bedingungen zu reagieren.\nFunktionen machen Programmcode k√ºrzer und lesbarer. Au√üerdem gint es nur eine Stelle, welche bei √Ñnderungen angepasst werden muss.\n\neine der vielseitigsten M It‚Äôs important to note that the optional argument must always appear after any required arguments when defining the function\nusing positional Arguments\n*args wird verwendet, um eine variable Anzahl von nicht-schl√ºsselwortlichen Argumenten zu empfangen. Innerhalb der Funktion wird args als eine Tuple behandelt, die alle √ºbergebenen Argumente enth√§lt.\nusing Keyword Arguments in Python\n**kwargs ist √§hnlich wie *args, aber es wird verwendet, um eine variable Anzahl von schl√ºsselwortbasierten Argumenten zu empfangen. Innerhalb der Funktion wird kwargs als ein Dictionary behandelt.\nKeyword arguments allow developers to specify which arguments should have which values when calling a Python function. This is especially useful if order isn‚Äôt important. To use keyword arguments, pass in a dictionary with the keyword and its associated value as an argument. For example:\nmy_dict = {‚Äúoptional_arg1‚Äù: 42} func_name(required_arg1, required_arg2, **my_dict)\nAusgabe: return-statement\n\nKontrollstrukturen\n\nFallunterscheidung if\n\n\nSchleifen while, for\n\n\n\nlambda",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#mapping-types",
    "href": "sammeltypen.html#mapping-types",
    "title": "4¬† Sammeltypen",
    "section": "4.10 Mapping Types",
    "text": "4.10 Mapping Types\nhttps://docs.python.org/3/library/stdtypes.html#mapping-types-dict",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "string-methods.html",
    "href": "string-methods.html",
    "title": "6¬† String Methods",
    "section": "",
    "text": "6.1 Zeichenfolgen als Sequenz\nZeichenfolgen werden in Python als Sequenz behandelt und k√∂nnen ebenso mit dem Slice Operator verwendet werden.\nprint('Ich bin ein string'[::2])\nprint('Hallo Welt'[0:6])\n\nIhbnensrn\nHallo\nVon unsch√§tzbaren Wert beim Einlesen von Datens√§tzen (Querverweis auf m-EsD) str.replace(old, new, count=-1) # wird new als ‚Äô‚Äô √ºbergeben, entspricht die Funktion dem L√∂schen von Zeichenfolgen\nstr.split(), str.rsplit(), str.splitlines(keepends=False)\nnicht von mir verwendet, aber n√ºtzlich:\nstr.count(sub[, start[, end]]) str.find(sub[, start[, end]]) # return the lowest index in the string where substring sub is foun str.index(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found. str.rfind(sub[, start[, end]]) # return the highest index in the string where substring sub is foun str.rindex(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found.\nstr.join(iterable) # das nutze ich einmal im m-EsD (glaube ich)\nstr.lstrip([chars]), str.rstrip([chars]), str.strip([chars]) ‚Äì&gt; default ist whitespace",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>String Methods</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html",
    "href": "funktionen-definieren.html",
    "title": "5¬† Eigene Funktionen definieren",
    "section": "",
    "text": "5.1 Syntax\nDas Schl√ºsselwort def leitet die Funktionsdefinition ein. Es wird gefolgt vom Funktionsnamen und den Funktionsargumenten, welche in runden Klammern () eingeschlossen sind. Der Funktionskopf wird mit einem Doppelpunkt : beendet. Der Anweisungsblock der Funktion ist einger√ºckt. Jede Funktion liefert einen R√ºckgabewert, welche durch das Schl√ºsselwort return an die aufrufende Stelle zur√ºckgegeben wird. return beendet die Ausf√ºhrung der Schleife, auch wenn es nicht am Ende des Anweisungsblocks steht.\ndef Funktionsname(Argument1, Argument2):\n    Anweisungsblock\n    return R√ºckgabewert\nDamit die Funktion ausfgef√ºhrt wird, muss der definierte Funktionsname aufgerufen und werden. In der Funktion ist nach dem Schl√ºsselwort return eine weitere Anweisung enthalten, die nicht mehr ausgef√ºhrt wird.\n# Beispiel 1: Summe der Quadrate\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b):\n    print('Wert Argument a:', a)\n    print('Wert Argument b:', b)\n    print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n    print(\"Anweisungen nach dem Schl√ºsselwort return werden nicht mehr ausgef√ºhrt.\")\n\nprint(sum_quadrate(6, 7))\n\nWert Argument a: 6\nWert Argument b: 7\n==================\n85\nDer R√ºckgabewert kann in einer Variablen gespeichert werden.\nergebnis = sum_quadrate(6, 7)\nprint(ergebnis)\n\nWert Argument a: 6\nWert Argument b: 7\n==================\n85",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#unterschied-zu-sequenzen",
    "href": "sammeltypen.html#unterschied-zu-sequenzen",
    "title": "4¬† Sammeltypen",
    "section": "4.8 Unterschied zu Sequenzen",
    "text": "4.8 Unterschied zu Sequenzen\nhttps://docs.python.org/3/library/stdtypes.html#typesseq Sequence Types ‚Äî list, tuple, range\nHinweis: Strings sind in Python eine Sequenz von Zeichen (Zeichenfolge), die unver√§nderlich ist (immutable). Bei der Arbeit mit strings f√§llt das nicht unbedingt auf. Beispiel erg√§nzen, bei dem ein string ver√§ndert wird. Tats√§chlich wird aber immer ein neuer string angelegt.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#slicing",
    "href": "sammeltypen.html#slicing",
    "title": "4¬† Sammeltypen",
    "section": "4.9 Slicing",
    "text": "4.9 Slicing\nUm auf Elemente einer Zeichenfolge zuzugreifen, wird der Slicing-Operator [] verwendet.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#tupel",
    "href": "sammeltypen.html#tupel",
    "title": "4¬† Sammeltypen",
    "section": "4.2 Tupel",
    "text": "4.2 Tupel\nTupel sind Listen sehr √§hnlich, jedoch sind Tupel unver√§nderbare Datenobjekte. Das hei√üt, die Elemente eines angelegten Tupels k√∂nnen weder ge√§ndert, noch entfernt werden. Auch k√∂nnen keine neuen Elemente zum Tupel hinzugef√ºgt werden.\nTupel werdem mit runden Klammern () erzeugt, die Elemente werden mit einem Komma , getrennt. Ein Tupel mit einem Wert wird mit einem Komma in der Form (wert, ) angelegt. Der Zugriff auf die Elemente eines Tupels ist mit dem Slice-Operator [start:stop:step] m√∂glich. Tupel k√∂nnen mit den Operatoren + und * verkettet werden.\n\ntupel1 = (2, 7.8, 'Feuer', True, text_variable)\ntupel2 = (1, )\n\nprint(tupel1)\nprint(tupel1[2:4])\nprint(tupel1[::2])\nprint(tupel1[-1])\nprint(tupel1[2:4] + tupel2)\nprint(3 * tupel2)\n\n(2, 7.8, 'Feuer', True, 'abc')\n('Feuer', True)\n(2, 'Feuer', 'abc')\nabc\n('Feuer', True, 1)\n(1, 1, 1)\n\n\n\nTupel kopieren\nTupel verhalten sich beim Kopieren gegens√§tzlich zu Listen. F√ºr Tupel ist die Methode .copy() nicht definiert. Tupel (bzw. die in diesen gespeicherten Werte) k√∂nnen durch Zuweisung kopiert werden. Dagegen bewirkt die Kopie mittels dem Zugriffsoperator [:] zwar, dass zwei Tupel auf den selben Speicherplatz zugreifen. Bei der Neuzuweisung eines Tupels legt Python jedoch ein neues Objekt im Speicher an.\n\n# Kopieren durch Zuweisung\ntupel1 = (1, 2, 3)\ntupel2 = tupel1\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(f\"Die in tupel2 gespeicherten Werte sind unver√§ndert:\\n{tupel1} {tupel2}\\n\")\n\n# Kopieren mit Slice Operator\ntupel1 = (1, 2, 3)\ntupel2 = tupel1[:]\nprint(tupel2 is tupel1)\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(tupel1, tupel2)\n\nDie in tupel2 gespeicherten Werte sind unver√§ndert:\n(4, 5, 6) (1, 2, 3)\n\nTrue\n(4, 5, 6) (1, 2, 3)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#zugriff-auf-sammeltypen",
    "href": "sammeltypen.html#zugriff-auf-sammeltypen",
    "title": "4¬† Sammeltypen",
    "section": "4.5 Zugriff auf Sammeltypen",
    "text": "4.5 Zugriff auf Sammeltypen\n\nSlicing-Operator []\n[:] legt eine Kopie an\n\n\n\nSammeltypen & for-Schleifen ‚Äì&gt; es handelt sich um eine foreach-Schleife, die ohne Z√§hler auskommt und die Liste, das Tupel, die Menge oder das Dictionary (Ausgabe der keys)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#slicing-der-zugriffsoperator",
    "href": "sammeltypen.html#slicing-der-zugriffsoperator",
    "title": "4¬† Sammeltypen",
    "section": "4.2 Slicing: der Zugriffsoperator []",
    "text": "4.2 Slicing: der Zugriffsoperator []\nDer Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere Sammeltypen) erfolgt √ºber den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator hei√üt deshalb auch Slice Operator.\n\nZugriff auf einzelne Elemente\nElemente werden √ºber ihren Index, bei 0 beginnend, angesprochen.\n\nprint(liste1)\nprint(liste1[0])\nprint(liste1[3])\n\n['abc', True, 'xy', 1, 'Hallo', 'Welt!']\nabc\n1\n\n\nAuf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste liste2 enth√§lt an Indexposition 1 eine Liste mit 4 Elementen.\n\nprint(liste2)\nprint(liste2[1])\nprint(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])\n\n[None, ['abc', True, 'xy', 1, 'Hallo', 'Welt!']]\n['abc', True, 'xy', 1, 'Hallo', 'Welt!']\nabc True xy 1\n\n\nMit negativen Indizes k√∂nnen Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.\n\nprint(liste1)\nprint(liste1[-1], liste1[-3])\n\n['abc', True, 'xy', 1, 'Hallo', 'Welt!']\nWelt! 1\n\n\n\n\nZugriff auf mehrere Elemente\nIndexbereiche k√∂nnen in der Form [start:stop:step] angesprochen werden. start ist das erste adressierte Element, stop das erste nicht mehr adressierte Element und step die Schrittweite.\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[start:stop]\nElemente von start bis stop - 1\n\n\nliste[:]\nAlle Elemente der Liste (entspricht einer Kopie)\n\n\nliste[start:]\nElemente von start bis zum Ende der Liste\n\n\nliste[:stop]\nElemente vom Anfang der Liste bis stop - 1\n\n\nliste[::3]\nAuswahl jedes dritten Elements\n\n\n\n¬†\nNegative Werte f√ºr start, stop oder‚Äôstep‚Äô bewirken eine R√ºckw√§rtsauswahl von Elementen.\n\n\n\n\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[-1]\ndas letzte Element der Liste\n\n\nliste[-2:]\ndie letzten beiden Elemente der Liste\n\n\nliste[:-2]\nalle bis auf die beiden letzten Elemente\n\n\nliste[::-1]\nalle Elemente in umgekehrter Reihenfolge\n\n\nliste[1::-1]\ndie ersten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[:-3:-1]\ndie letzten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[-3::-1]\nalle au√üer die letzten beiden Elemente in umgekehrter Reihenfolge\n\n\n\n¬†\n(Beispiele von Greg Hewgill unter der Lizenz CC BY-SA 4.0 verf√ºgbar auf stackoverflow. 2009)\n\n\nZeichenfolgen\nIn Python sind Zeichenfolgen eine Sequenz und k√∂nnen mit dem Slice Operator verwendet werden.\n\nprint('Hallo Welt'[4])\nprint('Hallo Welt'[0:6])\nprint('Hallo Welt'[6:])\nprint('Hallo Welt'[::-1])\nprint('Hallo Welt'[::2])\n\no\nHallo \nWelt\ntleW ollaH\nHloWl",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#umwandeln-von-sammeltypen",
    "href": "sammeltypen.html#umwandeln-von-sammeltypen",
    "title": "4¬† Sammeltypen",
    "section": "4.6 Umwandeln von Sammeltypen",
    "text": "4.6 Umwandeln von Sammeltypen\nDamit kann man die Sammeltypen auch erzeugen. list() list(dictionary) gibt die Schl√ºssel eines Dictionaries zur√ºck tuple() dict() # hier ist die Syntax anders set()",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#mengen",
    "href": "sammeltypen.html#mengen",
    "title": "4¬† Sammeltypen",
    "section": "4.3 Mengen",
    "text": "4.3 Mengen\nIn Python k√∂nnen Mengen mit der set() Funktion z. B. aus einer Liste oder aus einem Tupel erzeugt oder durch geschweiften Klammern {} erstellt werden (eine leere Menge kann nur mit set() erzeugt werden, da {} ein leeres Dictionary anlegt).\n\nliste = [1, 1, 5, 3, 3, 4, 2, 'a', 123, 1000, ('tupel', 5)]\nprint(\"Das Objekt liste als Menge:\\n\", set(liste))\n\nmenge = {1, 2, 3, 4, 5, 1000, ('tupel', 5), 'a', 123}\nprint(\"Die Menge kann auch mit geschweiften Klammern erzeugt werden:\", menge)\n\nDas Objekt liste als Menge:\n {1, 2, 3, 4, 5, 'a', 1000, ('tupel', 5), 123}\nDie Menge kann auch mit geschweiften Klammern erzeugt werden: {1, 2, 3, 4, 5, 'a', 1000, ('tupel', 5), 123}\n\n\nMengen k√∂nnen beispielsweise f√ºr Vergleichsoperationen verwendet werden.\n\nmenge_a = set('Python')\nmenge_b = set('ist super')\n\n# einzigartige Zeichen in a\nprint(\"Menge a:\", menge_a)\n\n# Zeichen in a, aber nicht in b\nprint(\"Menge a - b:\", menge_a - menge_b)\n\n# Zeichen in a oder b\nprint(\"Menge a | b:\", menge_a | menge_b)\n\n# Zeichen in a und b\nprint(\"Menge a & b:\", menge_a & menge_b)\n\n# Zeichen in a oder b, aber nicht in beiden (XOR)\nprint(\"Menge a ^ b:\", menge_a ^ menge_b)\n\nMenge a: {'t', 'o', 'n', 'h', 'P', 'y'}\nMenge a - b: {'o', 'n', 'h', 'P', 'y'}\nMenge a | b: {'i', 'u', 't', 'o', 'n', 'h', 'r', 'e', 'P', 's', ' ', 'y', 'p'}\nMenge a & b: {'t'}\nMenge a ^ b: {'i', 'u', 'o', 'n', 'r', 'h', 'e', 's', 'P', ' ', 'y', 'p'}\n\n\n\nMengen kopieren\nMengen verhalten sich wie Tupel mit dem Unterschied, dass die Methode .copy() f√ºr Mengen definiert ist. Allerdings kann der Zugriffsoperator [] nicht auf Mengen angewendet werden.\n\n# Kopieren durch Zuweisung\nset1 = {1, 2, 3}\nset2 = set1\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unver√§ndert:\\n{set1} {set2}\")\n\n# Kopieren durch Methode .copy()\nset1 = {1, 2, 3}\nset2 = set1.copy()\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unver√§ndert:\\n{set1} {set2}\")\n\nTrue\nDie in set2 gespeicherten Werte sind unver√§ndert:\n{4, 5, 6} {1, 2, 3}\nFalse\nDie in set2 gespeicherten Werte sind unver√§ndert:\n{4, 5, 6} {1, 2, 3}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#dictionaries",
    "href": "sammeltypen.html#dictionaries",
    "title": "4¬† Sammeltypen",
    "section": "4.4 Dictionaries",
    "text": "4.4 Dictionaries\nDictionaries bestehen aus Schl√ºssel-Wert-Paaren. Die Schl√ºssel k√∂nnen Zahlen oder Zeichenketten sein, jeder Schl√ºssel darf nur einmal vorkommen. Dictionaries werden mit geschweiften Klammern {} definiert. Die Schl√ºssel und deren zugeh√∂rigen Werte werden mit einem Doppelpunkt : getrennt. Der Zugriff auf die Werte erfolgt mit dem Zugriffsoperator [], welcher den oder die Schl√ºssel beinhaltet. Ein Zugriff √ºber die Indexposition der Schl√ºssel ist nicht m√∂glich, da Zahlen als Schl√ºssel interpretiert werden.\n\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nprint(dictionary1, \"\\n\")\n\nprint(\"Werte des Schl√ºssels 1:\", dictionary1[1])\nprint(\"Werte des Schl√ºssels 'b':\",  dictionary1['b'])\n\n{1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nWerte des Schl√ºssels 1: abc\nWerte des Schl√ºssels 'b': [1, 2, 3]\n\n\nAuf die Schl√ºssel eines Dictionaries kann √ºber die Methode dictionary.keys(), auf die Werte mittels der Methode dictionary.values() zugegriffen werden.\n\nprint(\"Schl√ºssel:\", dictionary1.keys(), \"\\n\")\nprint(\"Werte:\", dictionary1.values())\n\nSchl√ºssel: dict_keys([1, 'b', 'c']) \n\nWerte: dict_values(['abc', [1, 2, 3], ('tupel', 5, 6)])\n\n\n\nDictionaries kopieren\nDictionaries verhalten sich beim Kopieren wie Listen, das hei√üt beim Kopieren durch Zuweisung teilen sich Dictionaries den Speicherbereich.\n\n# Kopieren durch Zuweisung\nprint(\"dictionary:\", dictionary1, \"\\n\")\ndictionary2 = dictionary1\n\n## √Ñndern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"Auch dictionary1 hat sich durch die Zuweisung in dictionary2 ver√§ndert:\\n\",\n       dictionary1, \"\\n\")\n\n# Verwendung der Methode dictionary.copy()\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\ndictionary2 = dictionary1.copy()\n\n## √Ñndern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"dictionary1 bleibt durch die Zuweisung in dictionary2 unver√§ndert:\\n\",\n       dictionary1, \"\\n\")\n\ndictionary: {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nAuch dictionary1 hat sich durch die Zuweisung in dictionary2 ver√§ndert:\n {1: 'ABC', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\ndictionary1 bleibt durch die Zuweisung in dictionary2 unver√§ndert:\n {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#arbeiten-mit-sammeltypen",
    "href": "sammeltypen.html#arbeiten-mit-sammeltypen",
    "title": "4¬† Sammeltypen",
    "section": "4.6 Arbeiten mit Sammeltypen",
    "text": "4.6 Arbeiten mit Sammeltypen\nIn Python kommt Listen die gr√∂√üte Bedeutung zu, da diese am vielseitigsten eingesetzt werden k√∂nnnen. Im Folgenden‚Ä¶ wird die Arbeit mit Listen ausf√ºhrlich vorgestellt. Anschlie√üend werden die wesentlichen Unterschiede der √ºbrigen Sammeltypen erl√§utert.\n\nArbeiten mit Listen\n\n\nOperatoren\n\ndel\n\n\n\nUmwandlung von Sammeltypen\n\n\n\nSchleifen\nSammeltypen & for-Schleifen ‚Äì&gt; es handelt sich um eine foreach-Schleife, die ohne Z√§hler auskommt und die Liste, das Tupel, die Menge oder das Dictionary (Ausgabe der keys)\n\n\nUmwandeln von Sammeltypen\nDamit kann man die Sammeltypen auch erzeugen. list() list(dictionary) gibt die Schl√ºssel eines Dictionaries zur√ºck tuple() dict() # hier ist die Syntax anders set()",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#listen",
    "href": "sammeltypen.html#listen",
    "title": "4¬† Sammeltypen",
    "section": "",
    "text": "Slicing: der Zugriffsoperator []\nDer Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere Sammeltypen) erfolgt √ºber den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator hei√üt deshalb auch Slice Operator.\n\nZugriff auf einzelne Elemente\nElemente werden √ºber ihren Index, bei 0 beginnend, angesprochen.\n\nprint(liste1)\nprint(liste1[0])\nprint(liste1[3])\n\n[1, 'xy', True, 'abc']\n1\nabc\n\n\nAuf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste liste2 enth√§lt an Indexposition 1 eine Liste mit 4 Elementen.\n\nprint(liste2)\nprint(liste2[1])\nprint(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])\n\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc']\n1 xy True abc\n\n\nMit negativen Indizes k√∂nnen Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.\n\nprint(liste1)\nprint(liste1[-1], liste1[-3])\n\n[1, 'xy', True, 'abc']\nabc xy\n\n\n\n\nZugriff auf mehrere Elemente\nIndexbereiche k√∂nnen in der Form [start:stop:step] angesprochen werden. start ist das erste adressierte Element, stop das erste nicht mehr adressierte Element und step die Schrittweite.\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[start:stop]\nElemente von start bis stop - 1\n\n\nliste[:]\nAlle Elemente der Liste (entspricht einer Kopie)\n\n\nliste[start:]\nElemente von start bis zum Ende der Liste\n\n\nliste[:stop]\nElemente vom Anfang der Liste bis stop - 1\n\n\nliste[::3]\nAuswahl jedes dritten Elements\n\n\n\n¬†\nNegative Werte f√ºr start, stop oder‚Äôstep‚Äô bewirken eine R√ºckw√§rtsauswahl von Elementen.\n\n\n\n\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[-1]\ndas letzte Element der Liste\n\n\nliste[-2:]\ndie letzten beiden Elemente der Liste\n\n\nliste[:-2]\nalle bis auf die beiden letzten Elemente\n\n\nliste[::-1]\nalle Elemente in umgekehrter Reihenfolge\n\n\nliste[1::-1]\ndie ersten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[:-3:-1]\ndie letzten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[-3::-1]\nalle au√üer die letzten beiden Elemente in umgekehrter Reihenfolge\n\n\n\n¬†\n(Beispiele von Greg Hewgill unter der Lizenz CC BY-SA 4.0 verf√ºgbar auf stackoverflow. 2009)\n\n\nZeichenfolgen\nAuch aus Zeichenfolgen k√∂nnen mit dem Slice Operator Ausschnitte ausgew√§hlt werden.\n\nprint('Ich bin ein string'[::2])\nprint('Hallo Welt'[0:6])\nprint('abc'[::-1])\n\nIhbnensrn\nHallo \ncba\n\n\n\n\n\nListenmethoden\nF√ºr den Listentyp sind verschiedene Methoden definiert.\n\nElemente bestimmen\n\nlist.index(x, start, stop) gibt die Indexposition des ersten Elements x aus. Die optionalen Argumente start und stop erlauben es, den Suchbereich einzuschr√§nken.\nlist.count(x) gibt die H√§ufigkeit von x in der Liste aus.\nlist.reverse() kehrt die Reihenfolge der Listenelemente um (die Liste wird dadurch ver√§ndert!).\nlist.sort(reverse = False) sortiert die Liste, mit dem optionalen Argument reverse = True absteigend (die Liste wird dadurch ver√§ndert!). Die Datentypen innerhalb der Liste m√ºssen sortierbar sein (d.¬†h. alle Elemente sind numerisch oder Zeichen).\n\n\nprint(liste1)\n\nliste1.reverse()\nprint(liste1)\n\n# True wird als 1 gez√§hlt\nprint(\"True wird als 1 gez√§hlt:\", liste1.index(1), liste1.count(1))\n\n[1, 'xy', True, 'abc']\n['abc', True, 'xy', 1]\nTrue wird als 1 gez√§hlt: 1 2\n\n\n\n\nElemente einf√ºgen\n\nlist.append(x) h√§ngt ein einzelnes Element an das Ende der Liste an.\nlist.extend(sammeltyp) h√§ngt alle mit sammeltyp √ºbergebenen Elemente an das Ende der Liste an. Der Sammeltyp kann eine Liste, ein Tupel, eine Menge oder ein Dictionary sein.\nlist.insert(i, x) f√ºgt an der Position i Element x ein.\n\n\nprint(liste1, \"\\n\")\n\nliste1.append('Hallo')\nliste1.extend(['Hallo', 'Welt!'])\nliste1.insert(2, '12345')\n\nprint(liste1)\n\n['abc', True, 'xy', 1] \n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Hallo', 'Welt!']\n\n\n\n\nElemente entfernen\n\nlist.remove(x) entfernt das erste Element x in der Liste und gibt einen ValueError zur√ºck, wenn x nicht in der Liste enthalten ist.\nliste.pop(i) entfernt das Element an der Indexposition i. Wird kein Index angegeben, wird das letzte Element entfernt. Die Methode liste.pop([i]) gibt die entfernten Elemente zur√ºck.\nliste.clear() entfernt alle Elemente einer Liste.\n\n\nliste1.remove('Hallo')\nprint(liste1)\n\nliste1.pop(2)\n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Welt!']\n\n\n'12345'\n\n\n\n\nListen und Listenelemente kopieren\nIn Python enthalten Listen Daten nicht direkt, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. In Python werden Listen nicht durch Zuweisung kopiert, sondern greifen dann auf den selben Speicherort zu. Um eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen, kann die Methode liste.copy() verwendet werden. Auch durch die Verwendung des Zugriffsoperators [:] wird eine neue Liste im Speicher angelegt.\n\n# Kopieren durch Zuweisung\nliste1 = [1, 'xy', True, text_variable]\nprint(\"liste1:\", liste1, \"\\n\")\nliste2 = liste1\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"Auch liste1 hat sich durch die Zuweisung in liste2 ver√§ndert:\", liste1, \"\\n\")\n\n# Verwendung der Methode liste.copy()\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1.copy()\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1, \"\\n\")\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[:]\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1)\n\nliste1: [1, 'xy', True, 'abc'] \n\nAuch liste1 hat sich durch die Zuweisung in liste2 ver√§ndert: ['ABC', 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc']\n\n\nDie Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[0:2]\n\n# √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1)\n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc']\n\n\nUm zu √ºberpr√ºfen, ob sich zwei Objekte den Speicherbereich teilen, kann die Objekt-ID mit der Funktion id() verglichen oder die Operatoren is bzw. is not verwendet werden, die die Funktion id() aufrufen.\n\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1\n\nprint(\"ID liste1:\", id(liste1))\nprint(\"ID liste2:\", id(liste2))\nprint(\"ID liste1 gleich ID list2:\", liste1 is liste2)\n\nID liste1: 2324568329728\nID liste2: 2324568329728\nID liste1 gleich ID list2: True\n\n\n\n\n\n\n\n\nIdentit√§t vs.¬†Wertgleichheit\n\n\n\n\n\nDer Operator is pr√ºft die Identit√§t zweier Objekte und unterscheidet sich dadurch vom logischen Operator ==, der auf Wertgleichheit pr√ºft. Da liste1 und liste2 die gleichen Elemente enthalten, liegen sowohl Identit√§t und Wertgleichheit vor. Der Unterschied von Identit√§t und Wertgleichheit kann anhand eines Werts verdeutlicht werden (Im Code-Beispiel wird eine Syntax-Warnung unterdr√ºckt.).\n\n# Wertgleichheit\nprint(1 == 1.0)\nprint(liste1 == liste2, \"\\n\")\n\n# Identit√§t\nprint(1 is 1.0)\nprint(liste1 is liste2)\n\nTrue\nTrue \n\nFalse\nTrue\n\n\n\n\n\n\n\n\nAufgaben Listen\n\nErstellen Sie eine Liste ‚Äòwochentage‚Äô, die die sieben Tage der Woche enth√§lt. Verwenden Sie den Slice-Operator, um eine neue Liste ‚Äòwochenende‚Äô mit den Tagen des Wochenendes zu erstellen. Entfernen Sie die Tage des Wochenendes aus der Liste ‚Äòwochentage‚Äô.\n4-Tage-Woche: Verwenden Sie Listenmethoden, um den Freitag aus der Liste ‚Äòwochentage‚Äô zu entfernen und der Liste ‚Äòwochenende‚Äô hinzuzuf√ºgen.\nBestimmen Sie in der Liste zahlen = [34, 12, 0, 67, 23] die Position des Werts 0. Entfernen Sie den Wert aus der Liste und geben Sie die Liste aufsteigend sortiert aus.\nGeben Sie nun mit Hilfe des Zugriffsoperators [] die Indexpositionen 1 und 3 der sortierten Liste ‚Äòzahlen‚Äô aus.\n\nMusterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†4.1: Musterl√∂sung",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#arbeiten-mit-listen",
    "href": "sammeltypen.html#arbeiten-mit-listen",
    "title": "4¬† Sammeltypen",
    "section": "4.6 Arbeiten mit Listen",
    "text": "4.6 Arbeiten mit Listen\nIn Python kommt Listen die gr√∂√üte Bedeutung zu, da diese am vielseitigsten eingesetzt werden k√∂nnnen.\n\nOperatoren\n\ndel\n\n\n\n\n\nverkettete_liste = liste1 + liste2\nprint(verkettete_liste, \"\\n\")\n\nverkettetes_tupel = tupel1 + (5, 'Eis', None)\nprint(verkettetes_tupel)\n\n[1, 'xy', True, 'abc', 1, 'xy', True, 'abc'] \n\n(4, 5, 6, 5, 'Eis', None)\n\n\n\nUmwandlung von Sammeltypen\n\n‚Ä¶ hier kann del eigentlich mit rein\n\n\nSchleifen\nSammeltypen & for-Schleifen ‚Äì&gt; es handelt sich um eine foreach-Schleife, die ohne Z√§hler auskommt und die Liste, das Tupel, die Menge oder das Dictionary (Ausgabe der keys)\n\n\nUmwandeln von Sammeltypen\nDamit kann man die Sammeltypen auch erzeugen. list() list(dictionary) gibt die Schl√ºssel eines Dictionaries zur√ºck tuple() dict() # hier ist die Syntax anders set()",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#√ºbersicht",
    "href": "sammeltypen.html#√ºbersicht",
    "title": "4¬† Sammeltypen",
    "section": "4.5 √úbersicht",
    "text": "4.5 √úbersicht\n\n\n\n\n\n\n\n\n\n\nMerkmal\nListen\nTupel\nMengen\nDictionary\n\n\n\n\nBeschreibung\nflexible Anzahl von Elementen beliebigen Typs\nElemente beliebigen Typs, unver√§nderlich\nungeordnete Sammlung, jedes Element nur einmal enthalten\nZuordnungstabelle aus Schl√ºssel-Wert-Paaren\n\n\nSpeicherbereich bei Zuweisung geteilt\nja\nAufhebung bei Neuzuweisung\nAufhebung bei Neuzuweisung\nja\n\n\nMethode .copy() definiert\nja\nnein\nja\nja\n\n\nSlice-Operator anwendbar\nja\nja\nnein\nja (nach Schl√ºssel)\n\n\n\n¬†\nDie Sammeltypen k√∂nnen ineinander umgewandelt werden. wohin?!\n\ndictionary = {1: 'Kater', 2: 'F√§hre', 3: 'Ricke'}\nprint( (liste := list(dictionary)) )\nprint( (menge := set(liste)) )\nprint( (tupel := tuple(menge)) )\n\n[1, 2, 3]\n{1, 2, 3}\n(1, 2, 3)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#verwendung-von-schleifen",
    "href": "sammeltypen.html#verwendung-von-schleifen",
    "title": "4¬† Sammeltypen",
    "section": "4.7 Verwendung von Schleifen",
    "text": "4.7 Verwendung von Schleifen\nOperationen mit Listen? Denn das ist ja der eigentliche Grund, warum mit einer Schleife elementweise √ºber die Liste iteriert (foreach-Schleife) - weil Operationen nicht auf alle Listenelemente angewendet werden. In Python kommt Listen die gr√∂√üte Bedeutung zu, da diese am vielseitigsten eingesetzt werden k√∂nnnen.\n\nTypen umwandeln\n\n\nOperatoren\n\ndel wohin?!\n+, * eventl. als Einleitung zu Operationen mit Sammeltypen\n\n\n\nUmwandlung von Sammeltypen\n\n‚Ä¶ hier kann del eigentlich mit rein\n\n\nSchleifen\nSammeltypen & for-Schleifen ‚Äì&gt; es handelt sich um eine foreach-Schleife, die ohne Z√§hler auskommt und die Liste, das Tupel, die Menge oder das Dictionary (Ausgabe der keys)\n\n\nUmwandeln von Sammeltypen\nDamit kann man die Sammeltypen auch erzeugen. list() list(dictionary) gibt die Schl√ºssel eines Dictionaries zur√ºck tuple() dict() # hier ist die Syntax anders set()",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#l√∂schen-das-schl√ºsselwort-del",
    "href": "sammeltypen.html#l√∂schen-das-schl√ºsselwort-del",
    "title": "4¬† Sammeltypen",
    "section": "4.6 L√∂schen: das Schl√ºsselwort del",
    "text": "4.6 L√∂schen: das Schl√ºsselwort del\nUm Sammeltypen, Elemente oder Slices zu l√∂schen kann das Schl√ºsselwort del verwendet werden.\n\n# L√∂schen einer Liste\ndel liste1\n\n# L√∂schen eines Indexbereichs aus einer Liste\nprint(\"Liste vor dem L√∂schen:\", liste2)\ndel liste2[1:3]\nprint(\"Liste nach dem L√∂schen:\", liste2)\n\n# L√∂schen eines Schl√ºsselworts aus einem Dictionary\nprint(\"Dictionary vor dem L√∂schen\", dictionary1)\ndel dictionary1[1]\nprint(\"Dictionary nach dem L√∂schen\", dictionary1)\n\nListe vor dem L√∂schen: [1, 'xy', True, 'abc']\nListe nach dem L√∂schen: [1, 'abc']\nDictionary vor dem L√∂schen {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nDictionary nach dem L√∂schen {'b': [1, 2, 3], 'c': ('tupel', 5, 6)}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#operationen-verwendung-von-schleifen",
    "href": "sammeltypen.html#operationen-verwendung-von-schleifen",
    "title": "4¬† Sammeltypen",
    "section": "4.8 Operationen: Verwendung von Schleifen",
    "text": "4.8 Operationen: Verwendung von Schleifen\nUm arithmetische und logische Operatoren auf die in einem Sammeltyp gespeicherten Elemente anzuwenden, wird eine for-Schleife verwendet. Im folgenden Beispiel wird eine Liste ‚Äòzahlen‚Äô durchlaufen, die darin gespeicherten Zahlen quadriert und das jeweilige Ergebnis an die Liste ‚Äòquadratzahlen‚Äô angeh√§ngt. Auch wird gepr√ºft, ob die quadrierten Zahlen ganzzahlig durch 3 teilbar sind und das Pr√ºfergebnis in einer Liste ‚Äòmodulo_3‚Äô gespeichert.\n\n\n\n\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  quadratzahlen.append(quadratzahl)\n  modulo_3.append(quadratzahl % 3 == 0)\n\nprint(quadratzahlen)\nprint(modulo_3)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n[False, False, True, False, False, True, False, False, True, False]\n\n\n\n\nCode-Block¬†4.1",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#funktionen",
    "href": "sammeltypen.html#funktionen",
    "title": "4¬† Sammeltypen",
    "section": "4.7 Funktionen",
    "text": "4.7 Funktionen\nDie Sammeltypen k√∂nnen ineinander umgewandelt werden.\n\ndictionary = {1: 'Kater', 2: 'F√§hre', 3: 'Ricke'}\nprint( (liste := list(dictionary)) )\nprint( (menge := set(liste)) )\nprint( (tupel := tuple(menge)) )\n\n[1, 2, 3]\n{1, 2, 3}\n(1, 2, 3)\n\n\nEinige praktische Funktionen lassen sich auch auf Sammeltypen anwenden:\n\nlen() liefert die L√§nge eines Sammeltyps zur√ºck\nmin(), max(), sum() gibt das Minimum, Maximum bzw. die Summe eines Sammeltyps zur√ºck (bei Dictionaries wird die Anzahl der Schl√ºssel gez√§hlt)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#aufgaben-sammeltypen",
    "href": "sammeltypen.html#aufgaben-sammeltypen",
    "title": "4¬† Sammeltypen",
    "section": "4.10 Aufgaben Sammeltypen",
    "text": "4.10 Aufgaben Sammeltypen\n\nModifizieren Sie den Programmcode in Code-Block¬†4.1 so, dass nur die Quadratzahlen gespeichert werden, die ganzzahlig durch 3 teilbar sind.\nUmrechnung von Geschwindigkeiten Erstellen Sie ein Skript, welches eine Umrechnungstabelle f√ºr Geschwindigkeiten erzeugt. Folgende Randbedingungen sollen beachtet werden:\n\n\nDie Umrechnung soll von km/h in m/s erfolgen.\nDer Start- und Endwert soll in km/h frei w√§hlbar sein, wobei beide ganzzahlig sein sollen.\nDie Anzahl der Umrechnungspunkte soll definiert werden k√∂nnen und die Zwischenschritte (in km/h) immer als ganze Zahlen ausgegeben werden.\n\nTipp: In Ihrem Skript k√∂nnen Sie die Funktion input() verwenden, um Werte per Eingabe zu erfassen.\n\nSortieren: Gegeben ist die Liste meine_liste = list(range(9, 0, -1)). Diese soll mittels for-Schleifen sortiert werden.\n\n\n\n\n\n\n\nTipp¬†4.2: Musterl√∂sung Aufgaben Sammeltypen\n\n\n\n\n\n\nGanzzahlig durch 3 teilbare Quadratzahlen\n\n\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  if quadratzahl % 3 == 0:\n    quadratzahlen.append(quadratzahl)\n\nprint(quadratzahlen)\n\n[9, 36, 81]\n\n\n\nUmrechnung von Geschwindigkeiten\n\n\n# Freie Eingabe\n## start = int(input(\"Startwert in Kilometer pro Stunde eingeben.\"))\n## ende = int(input(\"Endwert in Kilometer pro Stunde eingeben.\"))\n## ausgabeschritte =  int(input(\"Anzahl auszugebener Schritte ein geben.\"))\n\n# Fixe Werte f√ºr die L√∂sung\nstart = 5\nende = 107\nausgabeschritte = 8\n\n# Liste f√ºr km erstellen\nschrittweite = (ende - start) / (ausgabeschritte - 1)\nliste_km = []\nfor i in range(ausgabeschritte):\n    liste_km.append(round(start + i * schrittweite))\n\n# Umrechnung\n# meter = 1000 * kilometer\n# Sekunde = Stunde * 60 * 60\nliste_m = []\nfor wert in liste_km:\n    liste_m.append(round((wert * 1000) / (60 * 60), 2))\n\n# Ausgabe\nprint(f\"Schrittweite: {schrittweite:.2f}\")\nprint(\"Kilometer pro Stunde\")\nprint(liste_km)\nprint(\"Meter pro Sekunde\")\nprint(liste_m)\n\nSchrittweite: 14.57\nKilometer pro Stunde\n[5, 20, 34, 49, 63, 78, 92, 107]\nMeter pro Sekunde\n[1.39, 5.56, 9.44, 13.61, 17.5, 21.67, 25.56, 29.72]\n\n\n\nSortieren: Bubble Sort Algorithmus\n\n\n# statische Liste, Textausgabe\nmeine_liste = list(range(9, 0, -1))\n\nif len(meine_liste) &gt; 1: \n\n    print(\"Liste zu Beginn\\t\\t  :\", meine_liste)\n\n    # √§u√üere Schleife\n    Schritt = 0\n    for i in range(len(meine_liste) - 1):\n\n    # innere Schleife\n        for j in range(len(meine_liste) - 1):\n            if meine_liste[j] &gt; meine_liste[j + 1]:\n                meine_liste[j], meine_liste[j + 1] = meine_liste[j + 1], meine_liste[j]\n\n        Schritt += 1\n        print(\"Liste nach Schritt \", Schritt, \":\", meine_liste)\n\n    print(\"\\nListe sortiert:\", *meine_liste) # * unterdr√ºckt die Kommas zwischen den Listenelementen\n\nelse:\n    print(\"Die Liste muss mindenstens zwei Elemente enthalten!\")\n\nListe zu Beginn       : [9, 8, 7, 6, 5, 4, 3, 2, 1]\nListe nach Schritt  1 : [8, 7, 6, 5, 4, 3, 2, 1, 9]\nListe nach Schritt  2 : [7, 6, 5, 4, 3, 2, 1, 8, 9]\nListe nach Schritt  3 : [6, 5, 4, 3, 2, 1, 7, 8, 9]\nListe nach Schritt  4 : [5, 4, 3, 2, 1, 6, 7, 8, 9]\nListe nach Schritt  5 : [4, 3, 2, 1, 5, 6, 7, 8, 9]\nListe nach Schritt  6 : [3, 2, 1, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  7 : [2, 1, 3, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  8 : [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nListe sortiert: 1 2 3 4 5 6 7 8 9\n\n\n\n\n\n¬†\n(Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Schleifen und Abzweigungen.‚Äú Fachhochschule Dortmund.\n\n\nMatthes, Eric. 2017. Python Crashkurs: Eine praktische, projektbasierte Programmiereinf√ºhrung. 1. Aufl. Heidelberg: dpunkt.verlag.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html#lambdas",
    "href": "funktionen-definieren.html#lambdas",
    "title": "5¬† Funktionen definieren",
    "section": "5.2 Lambdas",
    "text": "5.2 Lambdas\nhttps://docs.python.org/3/reference/expressions.html#lambda",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html#anonyme-funktionen-lambdas",
    "href": "funktionen-definieren.html#anonyme-funktionen-lambdas",
    "title": "5¬† Funktionen definieren",
    "section": "5.4 anonyme Funktionen Lambdas",
    "text": "5.4 anonyme Funktionen Lambdas\nhttps://docs.python.org/3/reference/expressions.html#lambda",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#listennotation",
    "href": "sammeltypen.html#listennotation",
    "title": "4¬† Sammeltypen",
    "section": "4.9 Listennotation",
    "text": "4.9 Listennotation\n\nDie sogenannte Listennotation ist eine Kurzschreibweise f√ºr for-Schleifen. In Listennotation geschriebene Schleifen m√ºssen in einer Zeile stehen und haben die folgende Syntax:\n\nquadratzahlen = [wert ** 2 for wert in range(10, 0, -1)]\nprint(quadratzahlen)\n\n[100, 81, 64, 49, 36, 25, 16, 9, 4, 1]\n\n\n(Matthes (2017), S. 71)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html#optionale-parameter",
    "href": "funktionen-definieren.html#optionale-parameter",
    "title": "5¬† Eigene Funktionen definieren",
    "section": "5.2 Optionale Parameter",
    "text": "5.2 Optionale Parameter\nDabei kann die in der Funktion enthaltene Ausgabe mit print() unn√∂tig sein. Mit Hilfe von optionalen Parametern kann die Programmausf√ºhrung gesteuert werden. Optionale Parameter m√ºssen nach verpflichtend zu √ºbergebenen Parametern definiert werden.\n\n# Beispiel 2: optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n\nprint(sum_quadrate(42, 7), \"\\n\")\nprint(sum_quadrate(42, 7, ausgabe = True))\n\n1813 \n\nWert Argument a: 42\nWert Argument b: 7\n==================\n1813\n\n\nGibt es mehrere optionale Parameter, so erfolgt die Zuweisung von Argumenten positional oder √ºber das Schl√ºsselwort.\n\n# Beispiel 3: mehrere optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print('Wert Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return summe\n\n# positionale √úbergabe\nprint(sum_potenzen(42, 7, 3, True), \"\\n\")\n\n# √úbergabe per Schl√ºsselwort\nprint(sum_potenzen(42, 7, ausgabe = True, p = 4))\n\nWert Argument a: 42\nWert Argument b: 7\nWert Argument p: 3\n==================\n74431 \n\nWert Argument a: 42\nWert Argument b: 7\nWert Argument p: 4\n==================\n3114097",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html#r√ºckgabewerte",
    "href": "funktionen-definieren.html#r√ºckgabewerte",
    "title": "5¬† Eigene Funktionen definieren",
    "section": "5.3 R√ºckgabewert(e)",
    "text": "5.3 R√ºckgabewert(e)\nFunktionen k√∂nnen in Python nur einen einzigen R√ºckgabewert haben. Trotzdem k√∂nnen mehrere R√ºckgabewerte mit einem Komma getrennt werden. Python gibt diese als Tupel zur√ºck.\n\n# Beispiel 4: mehrere R√ºckgabewerte\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print('Wert Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return a, b, summe\n\nergebnis = sum_potenzen(2, 7, ausgabe = False, p = 4)\nprint(ergebnis, type(ergebnis))\n\n(2, 7, 2417) &lt;class 'tuple'&gt;\n\n\nMit dem Slice Operator kann ein bestimmter R√ºckgabewert ausgew√§hlt werden.\n\nprint(ergebnis[2])\n\nsumme_potenzen = sum_potenzen(2, 7, ausgabe = False, p = 4)[2]\nprint(summe_potenzen, type(summe_potenzen))\n\n2417\n2417 &lt;class 'int'&gt;",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "funktionen-definieren.html#aufgaben-funktionen-definieren",
    "href": "funktionen-definieren.html#aufgaben-funktionen-definieren",
    "title": "5¬† Eigene Funktionen definieren",
    "section": "5.4 Aufgaben Funktionen definieren",
    "text": "5.4 Aufgaben Funktionen definieren\n\nPalindrom\nSchreiben Sie eine Funktion is_palindrome(), die pr√ºft, ob es sich bei einer √ºbergebenen Zeichenkette um ein Palindrom handelt.\n\nHinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise ‚ÄòAnna‚Äô, ‚ÄòOtto‚Äô, ‚ÄòLagerregal‚Äô. Palindrome m√ºssen nicht aus Buchstaben bestehen, sie k√∂nnen sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise ‚Äò345g543‚Äô.\n\nFibonacci-Zahlenreihe\n\nEntwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der Fibonacci-Reihe generiert und als Liste zur√ºckgibt. Die Fibonacci-Reihe beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden vorhergehenden Zahlen.\n\nVerschl√ºsselung\n\nBei Geocachen werden oft verschl√ºsselte Botschaften als R√§tsel verwendet. Oft wird folgende Logik zur Verschl√ºsselung angewendet:\n\nA -&gt; Z\nB -&gt; Y\nC -&gt; X\n‚Ä¶\n\nSchreiben Sie eine Funktion verschluesseln(str), die einen String als Eingabewert bekommt und einen verschl√ºsselten String zur√ºckgibt. Wie k√∂nnen Sie einen verschl√ºsselten String am einfachsten wieder entschl√ºsseln?\n\nTemperaturkonverter\n\nEntwickeln Sie eine Funktion temperatur_umrechnen(wert, von_einheit, nach_einheit), die eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion soll folgende Parameter verwenden:\n\nwert: Der Temperaturwert, der umgewandelt werden soll.\nvon_einheit / nach_einheit: Die Einheit des Ausgangs- bzw. des Zielwerts als string. M√∂gliche Werte sind ‚ÄòC‚Äô f√ºr Celsius, ‚ÄòF‚Äô f√ºr Fahrenheit und ‚ÄòK‚Äô f√ºr Kelvin.\n\nEs gelten die folgenden Umrechnungsformeln zwischen den Einheiten:\n\nCelsius nach Fahrenheit: F = C * 9/5 + 32\nFahrenheit nach Celsius: C = (F - 32) * 5/9\nCelsius nach Kelvin: K = C + 273.15\nKelvin nach Celsius: C = K - 273.15\nFahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15\nKelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32\n\nDie Musterl√∂sung kann Marc machen\n\n\n\n\n\n\nMusterl√∂sung Aufgaben Funktionen definieren\n\n\n\n\n\n\n\n\n\n¬† (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "string-methods.html#aufgaben-string-methods",
    "href": "string-methods.html#aufgaben-string-methods",
    "title": "6¬† String Methods",
    "section": "6.2 Aufgaben string methods",
    "text": "6.2 Aufgaben string methods\n\nPalindrom\n\nSchreiben Sie eine Funktion is_palindrome, die pr√ºft, ob es sich bei einer √ºbergebenen Zeichenkette um ein Palindrom handelt.\nHinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise ‚ÄòAnna‚Äô, ‚ÄòOtto‚Äô, ‚ÄòLagerregal‚Äô. Palindrome m√ºssen nicht aus Buchstaben bestehen, sie k√∂nnen sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise ‚Äò345g543‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>String Methods</span>"
    ]
  },
  {
    "objectID": "funktionen.html#aufgaben-flusskontrolle",
    "href": "funktionen.html#aufgaben-flusskontrolle",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.5 Aufgaben Flusskontrolle",
    "text": "3.5 Aufgaben Flusskontrolle\n\nSchreiben Sie ein Programm, dass von 1 bis 25 und von 38 bis 50 z√§hlt und jeden Wert, der ganzzahlig durch 7 teilbar ist, mit print() ausgibt.\nRoulette: Schreiben Sie ein Programm, dass f√ºr eine Zahl pr√ºft, ob diese im Wertebereich des Spieltischs liegt. Falls nein, soll eine Fehlermeldung ausgegeben werden. Falls ja, soll das Programm ausgeben, ob die Zahl\n\n\ngerade oder ungerade ist,\nrot oder schwarz ist,\nniedrig (1-18) oder hoch (19-36) ist und\nim 1., 2. oder 3. Dutzend liegt.\n\n\n\n\n\nRoulette Tableau\n\n\nEuropean roulette von Betzaar.com ist lizensiert unter CC 3.0 BY-SA und verf√ºgbar auf wikimedia.org. 2010\n\n¬†\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nMusterl√∂sung Aufgaben Flusskontrolle\n\n\n\n\n\n\n\n\n\n¬†\n(Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Schleifen und Abzweigungen.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html",
    "href": "dateien-lesen-und-schreiben.html",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "",
    "text": "6.1 Dateiobjekte\nUm mit Python auf eine Datei zuzugreifen, muss diese f√ºrs Lesen oder Schreiben ge√∂ffnet werden. Dazu wird in Python die Funktion open verwendet. Diese nimmt zwei Argumente, den Pfad der Datei und den Zugriffsmodus, an und liefert ein Dateiobjekt zur√ºck. Aus dem Dateiobjekt werden dann die Inhalte der Datei ausgelesen.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#zeichenfolgen-als-sequenz",
    "href": "dateien-lesen-und-schreiben.html#zeichenfolgen-als-sequenz",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.6 Zeichenfolgen als Sequenz",
    "text": "6.6 Zeichenfolgen als Sequenz\nZeichenfolgen werden in Python als Sequenz behandelt und k√∂nnen ebenso mit dem Slice Operator verwendet werden.\n\nprint('Ich bin ein string'[::2])\nprint('Hallo Welt'[0:6])\nprint('abc'[::-1])\n\nIhbnensrn\nHallo \ncba\n\n\nVon unsch√§tzbaren Wert beim Einlesen von Datens√§tzen (Querverweis auf m-EsD) str.replace(old, new, count=-1) # wird new als ‚Äô‚Äô √ºbergeben, entspricht die Funktion dem L√∂schen von Zeichenfolgen\nstr.split(), str.rsplit(), str.splitlines(keepends=False)\nnicht von mir verwendet, aber n√ºtzlich:\nstr.count(sub[, start[, end]]) str.find(sub[, start[, end]]) # return the lowest index in the string where substring sub is foun str.index(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found. str.rfind(sub[, start[, end]]) # return the highest index in the string where substring sub is foun str.rindex(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found.\nstr.join(iterable) # das nutze ich einmal im m-EsD (glaube ich)\nstr.lstrip([chars]), str.rstrip([chars]), str.strip([chars]) ‚Äì&gt; default ist whitespace",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#aufgaben-string-methods",
    "href": "dateien-lesen-und-schreiben.html#aufgaben-string-methods",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.7 Aufgaben string methods",
    "text": "6.7 Aufgaben string methods\nto do",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "einleitung.html#python-code-1",
    "href": "einleitung.html#python-code-1",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "2.1 Python-Code",
    "text": "2.1 Python-Code\nBei der Formatierung von Python-Code m√ºssen nur wenige Punkte beachtet werden.\n\nZahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\nprint(1 + 2)\nprint('Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\nHallo Welt!\nHallo Python!\n\n\n\nKommentare werden mit einer vorangestellten # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n# Ein reiner Kommentar\n# print(\"Python ist gro√üartig!\") # auskommentierter Code, gefolgt von einem Kommentar\nprint(\"Python ist ziemlich gut.\") # auszuf√ºhrender Code, gefolgt von einem Kommentar\n\nPython ist ziemlich gut.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Zeichen \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\n\n\nIn dem obenstehenden Beispiel werden Variablen angelegt. Mit Variablen besch√§ftigten wir uns sp√§ter in diesem Abschnitt. Trotzdem m√∂chte ich Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir kommen sp√§ter darauf zur√ºck.\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\n\n\n\nDie Einr√ºckung mit Leerzeichen kennzeichnet einen zusammengeh√∂rigen Code-Block. Innerhalb eines Code-Blocks muss immer die gleiche Anzahl Leerzeichen verwendet werden. Es muss mindestens ein Leerzeichen gesetzt werden, ansonsten ist die Anzahl der Leerzeichen beliebig. √úblich sind 2 oder 4 Leerzeichen. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.\n\n\nfor i in range(3):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n15\n25\n40\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html",
    "href": "objektorientierte-programmierung.html",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "",
    "text": "2.1 Klassen, Typen, Objekte, Attribute\nDie objektorientierte Programmierung ist ein System, um Ordnung in komplexe Computerprogramme zu bringen. Ein Pythonprogramm besteht aus verschiedenen Elementen: Operatoren und Operanden, Funktionen und Methoden, Werten und Variablen und vielem mehr. Alles in Python ist ein Objekt.\nJedes Objekt geh√∂rt zu einer Klasse, beispielsweise zur Klasse der Ganzzahlen. Die Klasse bestimmt als Blaupause die Eigenschaften und das Verhalten des Objekts - etwa welche Daten gespeichert und welche Operationen ausgef√ºhrt werden k√∂nnen.\nEin kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + '2', \"Zeichen werden verkettet.\")\nprint(type(True), True + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; a2 Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, einer Klasse, mit der nicht existente Werte verarbeitet werden:\nprint(None + None)\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\nPython kennt sehr viele Klassen. In Python werden Klassen (class) auch Typen (type) genannt. In fr√ºheren Versionen von Python waren Klassen und Typen noch verschieden. Inzwischen gibt es diesen Unterschied nicht mehr, beide Begriffe kommen aber noch in der Sprache vor.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#klassen-typen-objekte-und-datentypen",
    "href": "objektorientierte-programmierung.html#klassen-typen-objekte-und-datentypen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "",
    "text": "Datentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n\n\nDatentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert ‚Äú1‚Äù ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Auspr√§gung einer kategorialen Variablen repr√§sentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa f√ºr die Klasse der Ganzzahlen ‚Äòint‚Äô und den Datentyp ‚Äòint‚Äô. Jedes Objekt geh√∂rt zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und geh√∂ren einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp.\n\ntype(print)\n\nbuiltin_function_or_method\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einf√ºhren, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‚Äòfloat32‚Äô) und 64 Bit Speicherplatzbedarf (Datentyp ‚Äòfloat64‚Äô). Objekte vom Datentyp float32 und float64 geh√∂ren zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit k√∂nnen gr√∂√üere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel¬†2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine f√ºr die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#ausgabe-formatieren",
    "href": "objektorientierte-programmierung.html#ausgabe-formatieren",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.14 Ausgabe formatieren",
    "text": "2.14 Ausgabe formatieren\nMit sogenannten f-Strings k√∂nnen formatierte Zeichenketten erstellt werden. Formatierte Zeichenketten werden mit einem vorgesetzten f vor den Anf√ºhrungsstrichen erstellt. Werte und Variablen k√∂nnen durch Platzhalter eingesetzt werden, die mit geschweiften Klammern {} angegeben und mit Formattierungsinformationen versehen werden. Das Formatierungsformat innerhalb der geschweiften Klammer ist, vereinfacht dargestellt:\n{Variablenname:PlatzbedarfAusgabetyp}\nEin f-String mit Platzhaltern ohne Formatierungsinformationen:\n\nzahl1 = 5\nzahl2 = 7\nverh√§ltnis = zahl1 / zahl2\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.7142857142857143.\n\n\nDie Anzahl der darzustellenden Nachkommastellen kann wie folgt festgelegt werden: {verh√§ltnis:.2f}.\n\n: leitet die Formatierungsbefehle ein.\n. gibt an, dass Formatierungsinformationen f√ºr die Darstellung hinter dem Dezimaltrennzeichen folgen.\n2 ist der Wert f√ºr die darzustellenden Nachkommastellen.\nf spezifiziert die Darstellung einer Gleitkommazahl ‚Äòfloat‚Äô.\n\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:.2f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.71.\n\n\nDas gleiche ist mit einem Wert m√∂glich:\n\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:.3f}.\")\n\nDas Verh√§ltnis ist genauer 0.714.\n\n\nEin Wert f√ºr die insgesamt darzustellenden Stellen wird vor dem Dezimaltrennzeichen √ºbergeben {verh√§ltnis:7.2f} bzw. inklusive f√ºhrender Nullen {verh√§ltnis:07.2f}:\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:7.2f}.\")\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:07.3f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist    0.71.\nDas Verh√§ltnis ist genauer 000.714.\n\n\nDas Dezimaltrennzeichen z√§hlt als eine Stelle.\nH√§ufig verwendete Formatierung sind:\n\nganze ZahlenGleitkommazahlenZeichenketten\n\n\nGanze Zahlen haben den Ausgabetyp d.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nnd\nn-Stellen werden f√ºr die Ausgabe verwendet\n\n\n0nd\nAusgabe von n-Stellen, wobei die Leerstellen mit Nullen aufgef√ºllt werden.\n\n\n+d\nAusgabe des Vorzeichens auch bei positiven Zahlen\n\n\n\n\n\nGleitkommazahlen haben die Ausgabetypen f und e.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\n.mf\nm-Stellen werden f√ºr die Nachkommastellen genutzt.\n\n\nn.mf\nInsgesamt werden n-Stellen verwendet, wobei m-Stellen f√ºr die Nachkommastellen genutzt werden.\n\n\nn.me\nGenauso, aber die Ausgabe erfolgt in exponentieller Schreibweise.\n\n\n\n\n\nZeichenketten haben den Ausgabetyp s.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nns\nInsgesamt werden n-Stellen verwendet.\n\n\n&lt;ns, &gt;ns, ^ns\nGenauso, jedoch wird die Zeichenkette linksb√ºndig, rechtsb√ºndig bzw. zentriert platziert.\n\n\n\n\n\n\nEine Auflistung aller verf√ºgbaren Ausgabetypen findet sich in der Python Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#python-code",
    "href": "einleitung.html#python-code",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "Zahlen und Operatoren k√∂nnen direkt eingegeben werden. Text muss in einfache oder doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts.\n\n\n\nKommentare werden mit einer vorangestellten Raute # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Backslash \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\n\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\n\nDie Einr√ºckung mit Leerzeichen kennzeichnet einen zusammengeh√∂rigen Code-Block. Innerhalb eines Code-Blocks muss immer die gleiche Anzahl Leerzeichen verwendet werden. Es muss mindestens ein Leerzeichen gesetzt werden, ansonsten ist die Anzahl der Leerzeichen beliebig. √úblich sind 2 oder 4 Leerzeichen. Die for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die folgende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#zahlen",
    "href": "objektorientierte-programmierung.html#zahlen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.3 Zahlen",
    "text": "2.3 Zahlen\nZu den Zahlen geh√∂ren Ganzzahlen und boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.\n\nGanzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n0.001 oder 1000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#arithmetische-operatoren",
    "href": "objektorientierte-programmierung.html#arithmetische-operatoren",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.4 Arithmetische Operatoren",
    "text": "2.4 Arithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#aufgaben-zahlen",
    "href": "objektorientierte-programmierung.html#aufgaben-zahlen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.5 Aufgaben Zahlen",
    "text": "2.5 Aufgaben Zahlen\nL√∂sen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\nùü£ + ùü§6 / ùüß = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.1: Musterl√∂sung Zahlen",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#boolsche-werte",
    "href": "objektorientierte-programmierung.html#boolsche-werte",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.6 Boolsche Werte",
    "text": "2.6 Boolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und geh√∂ren in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte und Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary lernen wir in den folgenden Kapiteln kennen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#logische-operatoren",
    "href": "objektorientierte-programmierung.html#logische-operatoren",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.7 Logische Operatoren",
    "text": "2.7 Logische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / gr√∂√üer als / gr√∂√üer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis¬†2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint(5 & 10)\nprint(10 &gt; False &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\n0\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#aufgaben-boolsche-werte",
    "href": "objektorientierte-programmierung.html#aufgaben-boolsche-werte",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.8 Aufgaben boolsche Werte",
    "text": "2.8 Aufgaben boolsche Werte\nL√∂sen Sie die Aufgaben mit Python.\n\nIst das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\nIst es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#zeichenfolgen",
    "href": "objektorientierte-programmierung.html#zeichenfolgen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.9 Zeichenfolgen",
    "text": "2.9 Zeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\nprint('eine Zeichenfolge')\nprint(\"noch eine Zeichenfolge\")\n\neine Zeichenfolge\nnoch eine Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Das Steuerzeichen \\\\ erm√∂glicht die gleichen \\\"Anf√ºhrungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nDas Steuerzeichen \\ erm√∂glicht die gleichen \"Anf√ºhrungszeichen\" in der Ausgabe von print.\nErst ein    Tabstopp, dann eine\nneue Zeile.\n\n\nEin vorangestelltes r bewirkt, dass das Steuerzeichen \\ nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\nDie Daten liegen unter: C:  olle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#operationen-mit-zeichenfolgen",
    "href": "objektorientierte-programmierung.html#operationen-mit-zeichenfolgen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.10 Operationen mit Zeichenfolgen",
    "text": "2.10 Operationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n# string + string\nprint('a' + 'b')\nprint(\"\\n\")\n\n# string + Zahl\nprint(15 * 'a')\nprint(\"\\n\")\n\n# logische Operatoren\nprint('a' &lt; 'b', 'a' &gt;= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n\nab\n\n\naaaaaaaaaaaaaaa\n\n\nTrue False True\na b",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#aufgaben-zeichenfolgen",
    "href": "objektorientierte-programmierung.html#aufgaben-zeichenfolgen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.11 Aufgaben Zeichenfolgen",
    "text": "2.11 Aufgaben Zeichenfolgen\nL√∂sen Sie die Aufgaben mit Python.\n\nWas passiert, wenn Sie die Zeichenfolge ‚ÄúPython‚Äù mit ‚Äúfor beginners‚Äù addieren?\nErzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge ‚Äútick tack‚Äù.\nWelche Zeichenfolge ist kleiner, ‚ÄúAachen‚Äù oder ‚ÄúBern‚Äù. Warum ist das so, wie werden Zeichenfolgen verglichen?\nGeben Sie den Dateipfad aus: ‚Äú~_daten‚Äù\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.2: Musterl√∂sung Aufgaben Zeichenfolgen",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#variablen",
    "href": "objektorientierte-programmierung.html#variablen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.12 Variablen",
    "text": "2.12 Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‚Äòfloat‚Äô zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder √ºbersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAufl√∂sung Variablen\n\n\n\n\n\n\nprint(var_3, type(var_3))\nprint(variable1, type(variable1))\nprint(a, type(a))\n\nTrue &lt;class 'bool'&gt;\n15 &lt;class 'int'&gt;\n67.0 &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich ‚Äúsprechende‚Äù, das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchl√ºsselw√∂rter und Funktionsnamen\n\n\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#aufgaben-variablen",
    "href": "objektorientierte-programmierung.html#aufgaben-variablen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.13 Aufgaben Variablen",
    "text": "2.13 Aufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable f√ºr den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.3: Musterl√∂sung Aufgaben Variablen\n\n\n\n\n\n\n\n\n\n(Arnold 2023a)\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#klassen-typen-objekte",
    "href": "objektorientierte-programmierung.html#klassen-typen-objekte",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "",
    "text": "Datentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#datentypen",
    "href": "objektorientierte-programmierung.html#datentypen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert ‚Äú1‚Äù ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Auspr√§gung einer kategorialen Variablen repr√§sentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa f√ºr die Klasse der Ganzzahlen ‚Äòint‚Äô und den Datentyp ‚Äòint‚Äô.\nJedes Objekt geh√∂rt zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und geh√∂ren einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp. Zu welcher Klasse bzw. zu welchem Typ ein Objekt geh√∂rt, kann mit der Funktion type() ermittelt werden.\n\nprint(type(print))\n\n&lt;class 'builtin_function_or_method'&gt;\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einf√ºhren, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‚Äòfloat32‚Äô) und 64 Bit Speicherplatzbedarf (Datentyp ‚Äòfloat64‚Äô). Objekte vom Datentyp float32 und float64 geh√∂ren zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit k√∂nnen gr√∂√üere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel¬†2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine f√ºr die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#klassen-typen-objekte-attribute",
    "href": "objektorientierte-programmierung.html#klassen-typen-objekte-attribute",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "",
    "text": "Datentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#string-methods-komplizierter-aufgebaute-datens√§tze---siehe-sa",
    "href": "dateien-lesen-und-schreiben.html#string-methods-komplizierter-aufgebaute-datens√§tze---siehe-sa",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.4 String Methods = komplizierter aufgebaute Datens√§tze - siehe SA",
    "text": "6.4 String Methods = komplizierter aufgebaute Datens√§tze - siehe SA\nEinleitung: Da open in der Regel eine Zeichenfolge zur√ºckgibt, kommen beim Einlesen von Dateien in Python Methoden zur Stringmanipulation eine besondere Bedeutung zu. Dies gilt auch f√ºr das Einlesen von Dateien mit auf die Datenanalyse spezialisierten Paketen wie NumPy und Pandas, da dabei das Bereinigen von Datens√§tzen h√§ufig einen gro√üen Anteil einnimmt (Querverweis auf m-EsD).\nhttps://docs.python.org/3/library/stdtypes.html\nGewisse Sonderstellung, weil Zahlen manchmal als String eingelesen werden. Beim Einlesen von Dateien braucht man das h√§ufig.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#dateiobjekte",
    "href": "dateien-lesen-und-schreiben.html#dateiobjekte",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "",
    "text": "Dateipfad\nDer lokale Dateipfad wird ausgehend vom aktuellen Arbeitsverzeichnis angegeben.\n\npfad_maya = \"skript/01-daten/dice-maya.txt\"\npfad_hans = \"skript/01-daten/dice-hans.txt\"\n\n\n\n\n\n\n\nTipp¬†6.1: Arbeitsverzeichnis in Python ermitteln und wechseln\n\n\n\n\n\nDer Pfad des aktuellen Arbeitsverzeichnisses kann mit dem Modul os mittels os.getcwd() ermittelt werden (hier ohne Ausgabe). Mit os.chdir('neuer_pfad') kann das Arbeitsverzeichnis ggf. gewechselt werden. Die korrekte Formatierung des Pfads erkennen Sie an der Ausgabe von os.getcwd().\n\nimport os\nprint(os.getcwd())\n\nDas Importieren von Modulen wird in einem sp√§teren Kapitel behandelt.\n\n\n\n\n\nZugriffsmodus\nAls Zugriffsmodus stehen unter anderem folgende Optionen zur Verf√ºgung:\n\n\n\n\n\n\n\nModus\nBeschreibung\n\n\n\n\nr\nlesender Zugriff\n\n\nw\nSchreibzugriff, Datei wird √ºberschrieben\n\n\nx\nErzeugt die Datei, Fehlermeldung, wenn die Datei bereits existiert\n\n\na\nSchreibzugriff, Inhalte werden angeh√§ngt\n\n\nb\nBin√§rmodus (z. B. f√ºr Grafiken)\n\n\nt\nTextmodus, default\n\n\n\n¬†\nDie Zugriffsmodi k√∂nnen auch kombiniert werden. Weitere Informationen dazu finden Sie in der Dokumentation. Sofern nicht im Bin√§rmodus auf Dateien zugegriffen wird, liefert die Funktion open() den Dateiinhalt als string zur√ºck.\nIm Lesemodus wird ein Datenobjekt erzeugt.\n\ndaten_maya = open(pfad_maya, mode = 'r')\nprint(daten_maya)\n\n&lt;_io.TextIOWrapper name='skript/01-daten/dice-maya.txt' mode='r' encoding='cp1252'&gt;\n\n\nWenn das Datenobjekt daten_maya der Funktion print() √ºbergeben wird, gibt Python die Klasse des Objekts zur√ºck, in diesem Fall also _io.TextIOWrapper. Diese Klasse stammt aus dem Modul io und ist f√ºr das Lesen und Schreiben von Textdateien zust√§ndig. Ebenfalls werden als Attribute des Dateiobjekts der Dateipfad, der Zugriffsmodus und die Enkodierung der Datei ausgegeben (siehe Beispiel¬†6.1). Sollte die Enkodierung nicht automatisch als UTF-8 erkannt werden, kann diese mit dem Argument encoding = 'UTF-8' √ºbergeben werden.\n\ndaten_maya = open(pfad_maya, mode = 'r', encoding = 'UTF-8')\nprint(daten_maya)\n\n&lt;_io.TextIOWrapper name='skript/01-daten/dice-maya.txt' mode='r' encoding='UTF-8'&gt;\n\n\n\n\n\n\n\n\nBeispiel¬†6.1: Attribute eines Objekts bestimmen\n\n\n\n\n\nMit der Funktion dir(objekt) k√∂nnen die verf√ºgbaren Attribute eines Objekts ausgegeben werden. Dabei werden jedoch auch die vererbten Attribute und Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel f√ºr die Ganzzahl 1:\n\nprint(dir(1))\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']\n\n\nUm die Ausgabe auf Attribute einzugrenzen, kann folgende Funktion verwendet werden:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not callable (getattr(objekt, attr))]\nprint(attribute)\n\n['__doc__', 'denominator', 'imag', 'numerator', 'real']\n\n\nMit doppelten Unterstrichen umschlossene Attribute sind f√ºr Python reserviert und nicht f√ºr den:die Nutzer:in gedacht. Folgende Funktion entfernt Attribute mit doppelten Unterstrichen aus der Ausgabe:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n\n['denominator', 'imag', 'numerator', 'real']\n\n\nIm Fall einer Ganzzahl k√∂nnen Attribute (zur Abgrenzung von Gleitkommazahlen in umschlie√üenden Klammern) wie folgt aufgerufen werden:\n\n(1).numerator\n\n1\n\n\nWenn wir uns die Attribute des Dateiobjekts ‚Äòdaten_maya‚Äô ansehen, fallen Attribute mit einem einzelnen f√ºhrenden Unterstrich auf.\n\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n\n['_CHUNK_SIZE', '_finalizing', 'buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n\n\nHierbei handelt es sich um Attribute, die nicht durch den:die Nutzer:in aufgerufen werden sollen (weitere Informationen dazu finden Sie hier). Folgender Programmcode gibt alle Attribute ohne f√ºhrende Unterstriche aus:\n\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('_'))]\nprint(attribute)\n\n['buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n\n\n\n\n\nDie Attribute der Datei k√∂nnen mit entsprechenden Befehlen abgerufen werden.\n\nprint(f\"Dateipfad: {daten_maya.name}\\n\"\n      f\"Dateiname: {os.path.basename(daten_maya.name)}\\n\"\n      f\"Datei ist geschlossen: {daten_maya.closed}\\n\"\n      f\"Zugriffsmodus: {daten_maya.mode}\"\n      f\"Enkodierung: : {daten_maya.encoding}\")\n\nDateipfad: skript/01-daten/dice-maya.txt\nDateiname: dice-maya.txt\nDatei ist geschlossen: False\nZugriffsmodus: rEnkodierung: : UTF-8\n\n\n\n\n\n\n\n\nTipp¬†6.2: Enkodierung ausgeben\n\n\n\n\n\nIn der Datenanalyse werden in der Regel spezialisierte Pakete wie NumPy oder Pandas verwendet. Diese vereinfachen das Einlesen von Dateien gegen√ºber der Pythonbasis erheblich. Dennoch ist es sinnvoll, sich mit den Methoden der Pythonbasis zum Einlesen von Dateien vertraut zu machen:\n\nKlappt das Einlesen mit der Funktion open() so gut wie immer - es ist eine gute R√ºckfalloption.\nIst die Funktion open() eine schnelle Methode, die Enkodierung einer Datei zu bestimmen. Beim Einlesen von Dateien mit NumPy und Pandas muss die Enkodierung f√ºr eine korrekte Zeichenverarbeitung h√§ufig mit dem Parameter encoding √ºbergeben werden.\n\n\n\n\n\n\nDateiinhalt ausgeben\nUm den Dateiinhalt auszugeben, kann das Datenobjekt mit einer Schleife zeilenweise durchlaufen und ausgegeben werden. (Die Datei dice-maya hat nur eine Zeile.)\n\ni = 0\nfor zeile in daten_maya:\n    print(f\"Inhalt Zeile {i}, mit {len(zeile)} Zeichen:\")\n    print(zeile)\n    i += 1\n\nInhalt Zeile 0, mit 28 Zeichen:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nDies ist jedoch f√ºr gr√∂√üere Dateien nicht sonderlich praktikabel. Die Ausgabe einzelner Zeilen mit der Funktion print() kann aber n√ºtzlich sein, um die genaue Formatierung der Zeichenkette zu pr√ºfen. In diesem Fall hat Maya ihre Daten in Anf√ºhrungszeichen gesetzt und mit einem Komma voneinander getrennt.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#daten-einlesen",
    "href": "dateien-lesen-und-schreiben.html#daten-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.2 Daten einlesen",
    "text": "6.2 Daten einlesen\nUm den gesamten Inhalt einer Datei einzulesen, kann die Methode datenobjekt.read() verwendet werden. Die Methode hat als optionales Argument .read(size). size wird als Ganzzahl √ºbergeben und entsprechend viele Zeichen (im Bin√§rmodus entsprechend viele Bytes) werden ggf. bis zum Dateiende ausgelesen.\n\naugen_maya = daten_maya.read()\n\nprint(f\"len(augen_maya): {len(augen_maya)}\\n\\n\"\n      f\"Inhalt der Datei augen_maya:\\n{augen_maya}\")\n\nlen(augen_maya): 0\n\nInhalt der Datei augen_maya:\n\n\n\nDas hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist leer! Der Grund daf√ºr ist, dass beim Lesen (und beim Schreiben) einer Datei der Dateizeiger die Datei durchl√§uft. Nachdem die Datei daten_maya in Kapitel 6.1.3 zeilenweise ausgegeben wurde, steht der Dateizeiger am Ende der Datei.\n\n\n\n\n\n\nHinweis¬†6.1: Dateizeiger in Python\n\n\n\nWird eine Datei zeilenweise oder mit der Methode .read() ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz ‚Äòdaten‚Äô ge√∂ffnet und mit der Methode daten.read(3) die ersten drei Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0 zur Indexposition 3 (bzw. steht jeweils davor).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung¬†6.1: Bewegung des Dateizeigers beim Auslesen von drei Zeichen\n\n\n\nDie Methode daten.tell() gibt zur√ºck, an welcher Position sich der Dateizeiger befindet.\nMit der Methode daten.seek(offset, whence = 0) wird der Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das Argument offset (Versatz) und das optionale Argument whence (woher), dessen Standardwert 0 (Dateianfang) ist. F√ºr Zugriffe im Bin√§rmodus (open(pfad, mode = 'rb')) kann das Argument whence au√üerdem die Werte 1 (aktuelle Position) oder 2 (Dateiende) annehmen.\n\ndaten.seek(0, 0) bezeichnet den Dateianfang\ndaten.seek(0, 1) bezeichnet die aktuelle Position in der Datei\ndaten.seek(0, 2) bezeichnet das Dateiende\ndaten.seek(-3, 2) bezeichnet das dritte Zeichen vor dem Dateiende\n\n\n\nWird der Dateizeiger mit der Methode datenobjekt.seek(0) an den Dateianfang gestellt, gelingt das Auslesen der Datei.\n\nprint(f\"Position des Dateizeigers vor dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\ndaten_maya.seek(0);\nprint(f\"Position des Dateizeigers nach dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\naugen_maya = daten_maya.read()\n\nprint(f\"Inhalt des Objekts augen_maya:\\n{augen_maya}\")\n\nPosition des Dateizeigers vor dem Zur√ºcksetzen auf 0: 28\nPosition des Dateizeigers nach dem Zur√ºcksetzen auf 0: 0\nInhalt des Objekts augen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nGeben Sie aus dem Datenobjekt daten_maya mit den Methoden .seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6 und 2, aus.\n\n\n\n\n\n\nTipp¬†6.3: Musterl√∂sung Dateizeiger bewegen\n\n\n\n\n\n\ndaten_maya.seek(6, 0);\nprint(daten_maya.read(1))\n\ndaten_maya.seek(daten_maya.tell() + 4, 0);\nprint(daten_maya.read(1))\n\n6\n2\n\n\n\n\n\nUm Mayas W√ºrfelergebnisse zu addieren, m√ºssen die Zahlen extrahiert und in Ganzzahlen umgewandelt werden, da im Textmodus stets strings zur√ºckgegeben werden.\n\nprint(type(augen_maya))\n\n&lt;class 'str'&gt;\n\n\nDazu werden mit der Methode str.strip(\") das f√ºhrende und abschlie√üende Anf√ºhrungszeichen entfernt sowie anschlie√üend mit der Methode str.split('\", \"') der String in eine Liste aufgeteilt. Anschlie√üend werden die Listenelemente in Ganzzahlen umgewandelt und summiert.\n\nprint(f\"augen_maya:\\n{augen_maya}\")\n\naugen_maya = augen_maya.strip('\"')\nprint(f\"\\naugen_maya.strip('\\\"'):\\n{augen_maya}\")\n\naugen_maya = augen_maya.split('\", \"')\nprint(f\"\\naugen_maya.split('\\\", \\\"'):\\n{augen_maya}\")\n\naugen_maya_int = []\nfor i in augen_maya:\n  augen_maya_int.append(int(i))\n\nprint(f\"\\naugen_maya_int:\\n{augen_maya_int}\\n\\nSumme Augen: {sum(augen_maya_int)}\")\n\naugen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\naugen_maya.strip('\"'):\n5\", \"6\", \"2\", \"1\", \"4\", \"5\n\naugen_maya.split('\", \"'):\n['5', '6', '2', '1', '4', '5']\n\naugen_maya_int:\n[5, 6, 2, 1, 4, 5]\n\nSumme Augen: 23\n\n\n\nDatei schlie√üen\nNach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um diese f√ºr andere Programme freizugeben.\n\ndaten_maya.close()\n\n\n\n\n\n\n\nHinweis¬†6.2: Schreiboperationen mit Python\n\n\n\nDas Schlie√üen einer Datei ist besonders f√ºr Schreiboperationen auf Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit datenobjekt.write() nicht vollst√§ndig auf den Datentr√§ger geschrieben werden. Siehe dazu die Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#aufgabe-daten-einlesen",
    "href": "dateien-lesen-und-schreiben.html#aufgabe-daten-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.3 Aufgabe Daten einlesen",
    "text": "6.3 Aufgabe Daten einlesen\nWelche Augenzahl hat Hans erreicht?\n\n\n\n\n\n\nTipp¬†6.4: Musterl√∂sung Augenzahlvergleich\n\n\n\n\n\n\n\n# Erst Einlesen der Datei:\ndaten_hans = open(pfad_hans, mode = 'r', encoding = 'UTF-8')\naugen_hans = daten_hans.read()\nprint(augen_hans)\n# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!\n\naugen_hans = augen_hans.strip('\"Hans\", ')\naugen_hans = augen_hans.strip('\"')\naugen_hans = augen_hans.split('\", \"')\nprint(augen_hans)\n# print-Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese k√∂nnen summiert werden\n\n# Neue (leere) Liste f√ºr die W√ºrfe von Hans anlegen:\naugen_hans_int = []\nfor i in augen_hans:\n   augen_hans_int.append(int(i))\n\nprint(f\"Summe Augenzahl von Hans: {sum(augen_hans_int)}\")\n\n\"Hans\", \"3\", \"5\", \"1\", \"3\", \"2\", \"5\"\n['3', '5', '1', '3', '2', '5']\nSumme Augenzahl von Hans: 19\n\n\nMusterl√∂sung von Marc S√∂nnecken.\n\n\n\n\n(Arnold 2023)\nRest aus SA: 03",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#datei-einlesen",
    "href": "dateien-lesen-und-schreiben.html#datei-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.2 Datei einlesen",
    "text": "6.2 Datei einlesen\nUm den gesamten Inhalt einer Datei einzulesen, kann die Methode datenobjekt.read() verwendet werden. Die Methode hat als optionales Argument .read(size). size wird als Ganzzahl √ºbergeben und entsprechend viele Zeichen (im Bin√§rmodus entsprechend viele Bytes) werden ggf. bis zum Dateiende ausgelesen.\n\naugen_maya = daten_maya.read()\n\nprint(f\"len(augen_maya): {len(augen_maya)}\\n\\n\"\n      f\"Inhalt der Datei augen_maya:\\n{augen_maya}\")\n\nlen(augen_maya): 0\n\nInhalt der Datei augen_maya:\n\n\n\nDas hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist leer! Der Grund daf√ºr ist, dass beim Lesen (und beim Schreiben) einer Datei der Dateizeiger die Datei durchl√§uft. Nachdem die Datei daten_maya in Kapitel 6.1.3 zeilenweise ausgegeben wurde, steht der Dateizeiger am Ende der Datei.\n\n\n\n\n\n\nHinweis¬†6.1: Dateizeiger in Python\n\n\n\nWird eine Datei zeilenweise oder mit der Methode .read() ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz ‚Äòdaten‚Äô ge√∂ffnet und mit der Methode daten.read(3) die ersten drei Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0 zur Indexposition 3 (bzw. steht jeweils davor).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung¬†6.1: Bewegung des Dateizeigers beim Auslesen von drei Zeichen\n\n\n\nDie Methode daten.tell() gibt zur√ºck, an welcher Position sich der Dateizeiger befindet.\nMit der Methode daten.seek(offset, whence = 0) wird der Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das Argument offset (Versatz) und das optionale Argument whence (woher), dessen Standardwert 0 (Dateianfang) ist. F√ºr Zugriffe im Bin√§rmodus (open(pfad, mode = 'rb')) kann das Argument whence au√üerdem die Werte 1 (aktuelle Position) oder 2 (Dateiende) annehmen.\n\ndaten.seek(0, 0) bezeichnet den Dateianfang\ndaten.seek(0, 1) bezeichnet die aktuelle Position in der Datei\ndaten.seek(0, 2) bezeichnet das Dateiende\ndaten.seek(-3, 2) bezeichnet das dritte Zeichen vor dem Dateiende\n\n\n\nWird der Dateizeiger mit der Methode datenobjekt.seek(0) an den Dateianfang gestellt, gelingt das Auslesen der Datei.\n\nprint(f\"Position des Dateizeigers vor dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\ndaten_maya.seek(0);\nprint(f\"Position des Dateizeigers nach dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\naugen_maya = daten_maya.read()\n\nprint(f\"Inhalt des Objekts augen_maya:\\n{augen_maya}\")\n\nPosition des Dateizeigers vor dem Zur√ºcksetzen auf 0: 28\nPosition des Dateizeigers nach dem Zur√ºcksetzen auf 0: 0\nInhalt des Objekts augen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nGeben Sie aus dem Datenobjekt daten_maya mit den Methoden .seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6 und 2, aus.\n\n\n\n\n\n\nTipp¬†6.3: Musterl√∂sung Dateizeiger bewegen\n\n\n\n\n\n\ndaten_maya.seek(6, 0);\nprint(daten_maya.read(1))\n\ndaten_maya.seek(daten_maya.tell() + 4, 0);\nprint(daten_maya.read(1))\n\n6\n2\n\n\n\n\n\nUm Mayas W√ºrfelergebnisse zu addieren, m√ºssen die Zahlen extrahiert und in Ganzzahlen umgewandelt werden, da im Textmodus stets strings zur√ºckgegeben werden.\n\nprint(type(augen_maya))\n\n&lt;class 'str'&gt;\n\n\nDazu werden mit der Methode str.strip(\") das f√ºhrende und abschlie√üende Anf√ºhrungszeichen entfernt sowie anschlie√üend mit der Methode str.split('\", \"') der String in eine Liste aufgeteilt. Anschlie√üend werden die Listenelemente in Ganzzahlen umgewandelt und summiert. (Methoden der string-Bearbeitung werden im n√§chsten Abschnitt ausf√ºhrlich behandelt.)\n\nprint(f\"augen_maya:\\n{augen_maya}\")\n\naugen_maya = augen_maya.strip('\"')\nprint(f\"\\naugen_maya.strip('\\\"'):\\n{augen_maya}\")\n\naugen_maya = augen_maya.split('\", \"')\nprint(f\"\\naugen_maya.split('\\\", \\\"'):\\n{augen_maya}\")\n\naugen_maya_int = []\nfor i in augen_maya:\n  augen_maya_int.append(int(i))\n\nprint(f\"\\naugen_maya_int:\\n{augen_maya_int}\\n\\nSumme Augen: {sum(augen_maya_int)}\")\n\naugen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\naugen_maya.strip('\"'):\n5\", \"6\", \"2\", \"1\", \"4\", \"5\n\naugen_maya.split('\", \"'):\n['5', '6', '2', '1', '4', '5']\n\naugen_maya_int:\n[5, 6, 2, 1, 4, 5]\n\nSumme Augen: 23\n\n\n\nDatei schlie√üen\nNach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um diese f√ºr andere Programme freizugeben.\n\ndaten_maya.close()\n\n\n\n\n\n\n\nHinweis¬†6.2: Schreiboperationen mit Python\n\n\n\nDas Schlie√üen einer Datei ist besonders f√ºr Schreiboperationen auf Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit datenobjekt.write() nicht vollst√§ndig auf den Datentr√§ger geschrieben werden. Siehe dazu die Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#aufgabe-datei-einlesen",
    "href": "dateien-lesen-und-schreiben.html#aufgabe-datei-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.3 Aufgabe Datei einlesen",
    "text": "6.3 Aufgabe Datei einlesen\nWelche Augenzahl hat Hans erreicht?\n\n\n\n\n\n\nTipp¬†6.4: Musterl√∂sung Augenzahlvergleich\n\n\n\n\n\n\n\n# Erst Einlesen der Datei:\ndaten_hans = open(pfad_hans, mode = 'r', encoding = 'UTF-8')\naugen_hans = daten_hans.read()\nprint(augen_hans)\n# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!\n\naugen_hans = augen_hans.strip('\"Hans\", ')\naugen_hans = augen_hans.strip('\"')\naugen_hans = augen_hans.split('\", \"')\nprint(augen_hans)\n# print-Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese k√∂nnen summiert werden\n\n# Neue (leere) Liste f√ºr die W√ºrfe von Hans anlegen:\naugen_hans_int = []\nfor i in augen_hans:\n   augen_hans_int.append(int(i))\n\nprint(f\"Summe Augenzahl von Hans: {sum(augen_hans_int)}\")\n\n\"Hans\", \"3\", \"5\", \"1\", \"3\", \"2\", \"5\"\n['3', '5', '1', '3', '2', '5']\nSumme Augenzahl von Hans: 19\n\n\nMusterl√∂sung von Marc S√∂nnecken.\n\n\n\n\n(Arnold 2023)",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#zeichenfolgen-verarbeiten",
    "href": "dateien-lesen-und-schreiben.html#zeichenfolgen-verarbeiten",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.4 Zeichenfolgen verarbeiten",
    "text": "6.4 Zeichenfolgen verarbeiten\nDie Funktion open(datei) gibt ein Dateiobjekt zur√ºck, dass mit Methoden wie zum Beispiel dateiobjekt.read() als Zeichenfolge ausgelesen werden kann. Um die Daten sinnvoll weiterverarbeiten zu k√∂nnen, ist es notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden. Dies gilt auch f√ºr das Einlesen von Dateien mit auf die Datenanalyse spezialisierten Paketen wie NumPy und Pandas, da die korrekte Formatierung und das Bereinigen von Datens√§tzen h√§ufig einen gro√üen Anteil der Arbeit einnimmt (Formulierung √ºberarbeiten, Querverweis auf m-EsD). In diesem Abschnitt werden die Methoden zur string-Manipulation vorgestellt.\nRest aus SA: 03\nEinleitung: Da open in der Regel eine Zeichenfolge zur√ºckgibt, kommen beim Einlesen von Dateien in Python Methoden zur Stringmanipulation eine besondere Bedeutung zu.\nHier Methode dateiobjekt.readlines vorstellen\nhttps://docs.python.org/3/library/stdtypes.html\nGewisse Sonderstellung, weil Zahlen manchmal als String eingelesen werden. Beim Einlesen von Dateien braucht man das h√§ufig.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#dateien-schreiben",
    "href": "dateien-lesen-und-schreiben.html#dateien-schreiben",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.7 Dateien schreiben",
    "text": "6.7 Dateien schreiben\nUm Dateien zu schreiben, m√ºssen diese mit der write-Methode eines Dateiobjekts verwendet werden. Dieser Methode wird als Argument die zu schreibende Zeichenfolge √ºbergeben.\n\ndateipfad = \"skript/01-daten/neue_datei.txt\"\n\n# √ñffne Datei zum Schreiben √∂ffnen\ndatei = open(dateipfad, mode = 'w')\n\n# Inhalt in die Datei schreiben\ndatei.write(\"Prokrastination an Hochschulen\\n\\n\".upper())\ndatei.write(\"KAPITEL 1: Aller Anfang ist schwer\\nPlatzhalter: Den Rest schreibe ich sp√§ter.\")\n\n# Datei schlie√üen\n\ndatei.close()\n\nDie Datei kann nun ausgelesen werden.\n\ndateiinhalt = open(dateipfad, mode = 'r')\ntext = dateiinhalt.read()\nprint(text)\n\ndateiinhalt.close()\n\nPROKRASTINATION AN HOCHSCHULEN\n\nKAPITEL 1: Aller Anfang ist schwer\nPlatzhalter: Den Rest schreibe ich sp√§ter.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#dateien-einlesen",
    "href": "dateien-lesen-und-schreiben.html#dateien-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.2 Dateien einlesen",
    "text": "6.2 Dateien einlesen\nUm den gesamten Inhalt einer Datei einzulesen, kann die Methode datenobjekt.read() verwendet werden. Die Methode hat als optionalen Parameter .read(size). size wird als Ganzzahl √ºbergeben und entsprechend viele Zeichen (im Bin√§rmodus entsprechend viele Bytes) werden ggf. bis zum Dateiende ausgelesen. Der Parameter size ist n√ºtzlich, um die Formatierung des Inhalts einer gro√üen Datei zu pr√ºfen und dabei die Ausgabe auf eine √ºberschaubare Anzahl von Zeichen zu begrenzen.\n\naugen_maya = daten_maya.read()\n\nprint(f\"len(augen_maya): {len(augen_maya)}\\n\\n\"\n      f\"Inhalt der Datei augen_maya:\\n{augen_maya}\")\n\nlen(augen_maya): 0\n\nInhalt der Datei augen_maya:\n\n\n\nDas hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist leer! Der Grund daf√ºr ist, dass beim Lesen (und beim Schreiben) einer Datei der Dateizeiger die Datei durchl√§uft. Nachdem die Datei daten_maya in Kapitel 6.1.3 zeilenweise ausgegeben wurde, steht der Dateizeiger am Ende der Datei.\n\n\n\n\n\n\nHinweis¬†6.1: Dateizeiger in Python\n\n\n\nWird eine Datei zeilenweise oder mit der Methode .read() ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz ‚Äòdaten‚Äô ge√∂ffnet und mit der Methode daten.read(3) die ersten drei Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0 zur Indexposition 3 (bzw. steht jeweils davor).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung¬†6.1: Bewegung des Dateizeigers beim Auslesen von drei Zeichen\n\n\n\nDie Methode daten.tell() gibt zur√ºck, an welcher Position sich der Dateizeiger befindet.\nMit der Methode daten.seek(offset, whence = 0) wird der Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das Argument offset (Versatz) und das optionale Argument whence (woher), dessen Standardwert 0 (Dateianfang) ist. F√ºr Zugriffe im Bin√§rmodus (open(pfad, mode = 'rb')) kann das Argument whence au√üerdem die Werte 1 (aktuelle Position) oder 2 (Dateiende) annehmen.\n\ndaten.seek(0, 0) bezeichnet den Dateianfang\ndaten.seek(0, 1) bezeichnet die aktuelle Position in der Datei\ndaten.seek(0, 2) bezeichnet das Dateiende\ndaten.seek(-3, 2) bezeichnet das dritte Zeichen vor dem Dateiende\n\n\n\nWird der Dateizeiger mit der Methode datenobjekt.seek(0) an den Dateianfang gestellt, gelingt das Auslesen der Datei.\n\nprint(f\"Position des Dateizeigers vor dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\ndaten_maya.seek(0);\nprint(f\"Position des Dateizeigers nach dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\naugen_maya = daten_maya.read()\n\nprint(f\"Inhalt des Objekts augen_maya:\\n{augen_maya}\")\n\nPosition des Dateizeigers vor dem Zur√ºcksetzen auf 0: 28\nPosition des Dateizeigers nach dem Zur√ºcksetzen auf 0: 0\nInhalt des Objekts augen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nGeben Sie aus dem Datenobjekt daten_maya mit den Methoden .seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6 und 2, aus.\n\n\n\n\n\n\nTipp¬†6.3: Musterl√∂sung Dateizeiger bewegen\n\n\n\n\n\n\ndaten_maya.seek(6, 0);\nprint(daten_maya.read(1))\n\ndaten_maya.seek(daten_maya.tell() + 4, 0);\nprint(daten_maya.read(1))\n\n6\n2\n\n\n\n\n\nUm Mayas W√ºrfelergebnisse zu addieren, m√ºssen die Zahlen extrahiert und in Ganzzahlen umgewandelt werden, da im Textmodus stets eine Zeichenfolge zur√ºckgegeben wird.\n\nprint(type(augen_maya))\n\n&lt;class 'str'&gt;\n\n\nDazu werden mit der Methode str.strip(\") das f√ºhrende und abschlie√üende Anf√ºhrungszeichen entfernt sowie anschlie√üend mit der Methode str.split('\", \"') die Zeichenfolge √ºber das Trennzeichen in eine Liste aufgeteilt. Anschlie√üend werden die Listenelemente in Ganzzahlen umgewandelt und summiert. (Methoden der string-Bearbeitung werden im n√§chsten Abschnitt ausf√ºhrlich behandelt.)\n\nprint(f\"augen_maya:\\n{augen_maya}\")\n\naugen_maya = augen_maya.strip('\"')\nprint(f\"\\naugen_maya.strip('\\\"'):\\n{augen_maya}\")\n\naugen_maya = augen_maya.split('\", \"')\nprint(f\"\\naugen_maya.split('\\\", \\\"'):\\n{augen_maya}\")\n\naugen_maya_int = []\nfor i in augen_maya:\n  augen_maya_int.append(int(i))\n\nprint(f\"\\naugen_maya_int:\\n{augen_maya_int}\\n\\nSumme Augen: {sum(augen_maya_int)}\")\n\naugen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\naugen_maya.strip('\"'):\n5\", \"6\", \"2\", \"1\", \"4\", \"5\n\naugen_maya.split('\", \"'):\n['5', '6', '2', '1', '4', '5']\n\naugen_maya_int:\n[5, 6, 2, 1, 4, 5]\n\nSumme Augen: 23\n\n\n\nDatei schlie√üen\nNach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um diese f√ºr andere Programme freizugeben.\n\ndaten_maya.close()\n\n\n\n\n\n\n\nHinweis¬†6.2: Schreiboperationen mit Python\n\n\n\nDas Schlie√üen einer Datei ist besonders f√ºr Schreiboperationen auf Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit datenobjekt.write() nicht vollst√§ndig auf den Datentr√§ger geschrieben werden. Siehe dazu die Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#aufgabe-dateien-einlesen",
    "href": "dateien-lesen-und-schreiben.html#aufgabe-dateien-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.3 Aufgabe Dateien einlesen",
    "text": "6.3 Aufgabe Dateien einlesen\nWelche Augenzahl hat Hans erreicht?\n\n\n\n\n\n\nTipp¬†6.4: Musterl√∂sung Augenzahlvergleich\n\n\n\n\n\n\n\n# Erst Einlesen der Datei:\ndaten_hans = open(pfad_hans, mode = 'r', encoding = 'UTF-8')\naugen_hans = daten_hans.read()\nprint(augen_hans)\n# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!\n\naugen_hans = augen_hans.strip('\"Hans\", ')\naugen_hans = augen_hans.strip('\"')\naugen_hans = augen_hans.split('\", \"')\nprint(augen_hans)\n# print-Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese k√∂nnen summiert werden\n\n# Neue (leere) Liste f√ºr die W√ºrfe von Hans anlegen:\naugen_hans_int = []\nfor i in augen_hans:\n   augen_hans_int.append(int(i))\n\nprint(f\"Summe Augenzahl von Hans: {sum(augen_hans_int)}\")\n\n\"Hans\", \"3\", \"5\", \"1\", \"3\", \"2\", \"5\"\n['3', '5', '1', '3', '2', '5']\nSumme Augenzahl von Hans: 19\n\n\nMusterl√∂sung von Marc S√∂nnecken.\n\n\n\n\n(Arnold 2023)",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#komplexe-dateien-einlesen",
    "href": "dateien-lesen-und-schreiben.html#komplexe-dateien-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.4 Komplexe Dateien einlesen",
    "text": "6.4 Komplexe Dateien einlesen\nDatens√§tze liegen typischerweise wenigstens in zweidimensionaler Form vor (die Daten sind in Zeilen und Spalten organisiert) und weisen unterschiedliche Datentypen auf. Die Funktion open(datei) gibt ein Dateiobjekt zur√ºck, dass mit Methoden wie zum Beispiel dateiobjekt.read() als Zeichenfolge eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu k√∂nnen, ist es deshablb notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden.\nBeispielsweise soll eine Datei mit den Einwohnerzahlen der europ√§ischen L√§nder eingelesen werden.\n\n\n\nDaten\nDateiname\n\n\n\n\nEinwohner Europas\neinwohner_europa_2019.csv\n\n\n\n¬†\nIn diesem Abschnitt werden verschiedene M√∂glichkeiten gezeigt, die Datei einzulesen.\n\nvollst√§ndiges Einlesen\nIm vorherigen Abschnitt haben wir die Methode dateiobjekt.read() kennengelernt, mit der eine Datei vollst√§ndig als string eingelesen wird. Zuvor m√∂chten wir uns jedoch die ersten drei Zeilen der Datei anschauen. Daf√ºr brechen wir die for-Schleife mit dem Schl√ºsselwort break ab, wenn die Laufvariable i den Wert 3 erreicht. break habe ich noch gar nicht vorgestellt ‚Äì&gt; geh√∂rt zu Flusskontrolle\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# erste 3 Zeilen anschauen\ni = 0\nfor zeile in dateiobjekt_einwohner:\n  \n  print(zeile)\n  i += 1\n  if i == 3:\n    break\n\n# Dateizeiger zur√ºcksetzen\ndateiobjekt_einwohner.seek(0);\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\nDie Datei hat also zwei Spalten. In der ersten Spalte sind die L√§ndernamen eingetragen, in der zweiten Spalte die Werte. Als Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die Spaltenbeschriftungen eingetragen.\nZun√§chst wird die Datei mit der Methode dateiobjekt.read() in das Objekt einwohner eingelesen und wieder geschlossen.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n\n\nAnschlie√üend k√∂nnen die eingelesenen Daten mit der Methode str.split('\\n') zeilweise aufgeteilt werden. Mit '\\n' wird als Argument der Zeilenumbruch √ºbergeben. Die Methode liefert eine Liste zur√ºck.\n\nliste_einwohner_zeilenweise = einwohner.split(\"\\n\")\nprint(liste_einwohner_zeilenweise[0:3])\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']\n\n\nDie Liste enth√§lt an der Indexposition die Spaltenbeschriftungen. Diese k√∂nnen mit der Methode liste.pop(index) aus der Liste entfernt und zugleich in einem neuen Objekt gespeichert werden.\n\nspaltennamen = liste_einwohner_zeilenweise.pop(0)\nspaltennamen = spaltennamen.split(',')\nprint(f\"√úberschrift Spalte 0: {spaltennamen[0]}\\t√úberschrift Spalte 1: {spaltennamen[1]}\")\n\n√úberschrift Spalte 0: GEO   √úberschrift Spalte 1: Value\n\n\nAnschlie√üend kann die Liste mit der Methode str.split(',') nach L√§ndern und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per error handling mit der Konstruktion aus try: und except: abgefangen. Damit kann die Fehlerquelle auf eine der Listenoperationen eingegrenzt werden.\nerror handling erg√§nzen - eventuell bei Funktionen definieren - und hier Querverweis setzen\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nlist index out of range\n\n\nLeicht angepasst, liefert der Code-Block auch die Ursache der Fehlermeldung. erkl√§ren\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\nindexz√§hler = 0\n\nfor zeile in liste_einwohner_zeilenweise:\n  try:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n    indexz√§hler += 1\n\n  except IndexError as error:\n    print(error)\n    print(\"Eintrag:\", eintrag, \"\\tIndexposition:\", indexz√§hler)\n\nlist index out of range\nEintrag: ['']   Indexposition: 29\n\n\nWird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der L√§ndernamen und der Werte.\n\n# leere Zeile entfernen\nliste_einwohner_zeilenweise.remove('')\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nGEO\n['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] \n\nValue\n['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']\n\n\n\n\nAufgabe vollst√§ndiges Einlesen\n\nBestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die dazugeh√∂rigen L√§nder.\nBereinigen Sie ggf. fehlerhafte Werte.\nWie viele Einwohner leben in Europa insgesamt?\n\n\nWelchen Datentyp hat die Liste einwohnerzahl?\nWelchen Datentyp haben die Eintr√§ge der Liste einwohnerzahl?\n\nDie Musterl√∂sung kann Marc machen\n\n\n\n\n\n\nMusterl√∂sung vollst√§ndiges Einlesen\n\n\n\n\n\n\n\n\n\n\n\nzeilenweises Einlesen\nDann die Methode readline() und die Funktion list() zeigen, die das auch machen.\npanel-tabset\n\nMethode readline()Funktion list()\n\n\nMit der Methode dateiobjekt.readline() kann ein Zeile eingelesen werden. Diese gibt den Zeilenumbruch \\n mit zur√ºck.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = []\nfor zeile in dateiobjekt_einwohner:\n  einwohner.append(zeile) \n\nprint(einwohner)\n\n# Dateizeiger zur√ºcksetzen\ndateiobjekt_einwohner.seek(0);\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\n\n\nDie Funktion list() tut das gleiche wie das Iterieren √ºber den Datensatz mit der Methode dateiobjekt.readline()\n\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\n\n\n\nfor zeile in daten_maya: print(f‚ÄùInhalt Zeile {i}, mit {len(zeile)} Zeichen:‚Äú) print(zeile) i += 1 Rest aus SA: 03\nreadlines\nEinleitung: Da open in der Regel eine Zeichenfolge zur√ºckgibt, kommen beim Einlesen von Dateien in Python Methoden zur Stringmanipulation eine besondere Bedeutung zu.\nHier Methode dateiobjekt.readline vorstellen\nhttps://docs.python.org/3/library/stdtypes.html\nGewisse Sonderstellung, weil Zahlen manchmal als String eingelesen werden. Beim Einlesen von Dateien braucht man das h√§ufig.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#methode-read",
    "href": "dateien-lesen-und-schreiben.html#methode-read",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.5 Methode read()",
    "text": "6.5 Methode read()\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n\n\nDann die Methode readline() und die Funktion list() zeigen, die das auch machen.\npanel-tabset\n\nMethode readline()Funktion list()\n\n\nMit der Methode dateiobjekt.readline() kann ein Zeile eingelesen werden. Diese gibt den Zeilenumbruch \\n mit zur√ºck.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = []\nfor zeile in dateiobjekt_einwohner:\n  einwohner.append(zeile) \n\nprint(einwohner)\n\n# Dateizeiger zur√ºcksetzen\ndateiobjekt_einwohner.seek(0);\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\n\n\nDie Funktion list() tut das gleiche wie das Iterieren √ºber den Datensatz mit der Methode dateiobjekt.readline()\n\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\n\n\n\nfor zeile in daten_maya: print(f‚ÄùInhalt Zeile {i}, mit {len(zeile)} Zeichen:‚Äú) print(zeile) i += 1 Rest aus SA: 03\nreadlines\nEinleitung: Da open in der Regel eine Zeichenfolge zur√ºckgibt, kommen beim Einlesen von Dateien in Python Methoden zur Stringmanipulation eine besondere Bedeutung zu.\nHier Methode dateiobjekt.readline vorstellen\nhttps://docs.python.org/3/library/stdtypes.html\nGewisse Sonderstellung, weil Zahlen manchmal als String eingelesen werden. Beim Einlesen von Dateien braucht man das h√§ufig.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#datens√§tze-einlesen",
    "href": "dateien-lesen-und-schreiben.html#datens√§tze-einlesen",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.4 Datens√§tze einlesen",
    "text": "6.4 Datens√§tze einlesen\nDatens√§tze liegen typischerweise wenigstens in zweidimensionaler Form vor, d.¬†h. die Daten sind in Zeilen und Spalten organisiert. Au√üerdem weisen Datens√§tze in der Regel auch unterschiedliche Datentypen auf. Die Funktion open(datei) gibt ein Dateiobjekt zur√ºck, das mit Methoden wie zum Beispiel dateiobjekt.read() als Zeichenfolge eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu k√∂nnen, ist es deshablb notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden.\nF√ºr die Bearbeitung von Zeichenfolgen bietet Python eine Reihe von String-Methoden. Einige davon werden in diesem Kapitel exemplarisch verwendet. String-Methoden werden in der Regel mit einem f√ºhrenden ‚Äòstr‚Äô in der Form str.methode() genannt.\nBeispielsweise soll eine Datei mit den Einwohnerzahlen der europ√§ischen L√§nder eingelesen werden.\n\n\n\nDaten\nDateiname\n\n\n\n\nEinwohner Europas\neinwohner_europa_2019.csv\n\n\n\n¬†\nZun√§chst geben wir die ersten drei Zeilen der Datei aus. Daf√ºr kann die Datei zeilenweise mit einer for-Schleife durchlaufen werden, die mit dem Schl√ºsselwort break abgebrochen wird, wenn die Laufvariable den Wert 3 erreicht hat. Eine andere M√∂glichkeit ist die Methode dateiobjekt.readline(), die eine einzelne Zeile ausliest.\n\nfor-Schleife mit breakMethode dateiobjekt.readline()\n\n\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# erste 3 Zeilen anschauen\ni = 0\nfor zeile in dateiobjekt_einwohner:\n  \n  print(zeile)\n  i += 1\n  if i == 3:\n    break\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\nMit der Methode dateiobjekt.readline() kann eine einzelne Zeile eingelesen werden.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\nfor i in range(3):\n  print(dateiobjekt_einwohner.readline())\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\n\nDie Datei hat also zwei Spalten. In der ersten Spalte sind die L√§ndernamen eingetragen, in der zweiten Spalte die Werte. Als Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die Spaltenbeschriftungen eingetragen.\n\nvollst√§ndiges Einlesen\nIm vorherigen Abschnitt haben wir die Methode dateiobjekt.read() kennengelernt, mit der eine Datei vollst√§ndig als string eingelesen wird. Zun√§chst wird die Datei mit der Methode dateiobjekt.read() in das Objekt einwohner eingelesen und wieder geschlossen.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n\n\nAnschlie√üend k√∂nnen die eingelesenen Daten mit der Methode str.split('\\n') zeilweise aufgeteilt werden. Mit '\\n' wird als Argument der Zeilenumbruch √ºbergeben. Die Methode liefert eine Liste zur√ºck.\n\nliste_einwohner_zeilenweise = einwohner.split(\"\\n\")\nprint(liste_einwohner_zeilenweise[0:3])\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']\n\n\nDie Liste enth√§lt an der Indexposition die Spaltenbeschriftungen. Diese k√∂nnen mit der Methode liste.pop(index) aus der Liste entfernt und zugleich in einem neuen Objekt gespeichert werden.\n\nspaltennamen = liste_einwohner_zeilenweise.pop(0)\nspaltennamen = spaltennamen.split(',')\nprint(f\"√úberschrift Spalte 0: {spaltennamen[0]}\\t√úberschrift Spalte 1: {spaltennamen[1]}\")\n\n√úberschrift Spalte 0: GEO   √úberschrift Spalte 1: Value\n\n\nAnschlie√üend kann die Liste mit der Methode str.split(',') nach L√§ndern und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per error handling mit der Konstruktion aus try: und except: abgefangen, um dieser hier im Skript darzustellen.\nerror handling erg√§nzen - bei Funktionen - und hier Querverweis setzen Die Datei von der Frau Vol.. war ein gutes Beispiel, wo Zeile 127 pl√∂tzlich einger√ºckt war.\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nlist index out of range\n\n\nDie Fehlermeldung ist so zu deuten, dass eine der Listenoperationen mit dem Slice Operator einen ung√ºltigen Index anspricht. Leicht angepasst, liefert der Code-Block auch die Ursache der Fehlermeldung.\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\nindexz√§hler = 0\n\nfor zeile in liste_einwohner_zeilenweise:\n  try:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n    indexz√§hler += 1\n\n  except IndexError as error:\n    print(error)\n    print(\"Eintrag:\", eintrag, \"\\tIndexposition:\", indexz√§hler)\n\nlist index out of range\nEintrag: ['']   Indexposition: 29\n\n\nWird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der L√§ndernamen und der Werte.\n\n# leere Zeile entfernen\nliste_einwohner_zeilenweise.remove('')\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nGEO\n['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] \n\nValue\n['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']\n\n\n\n\nAufgabe Einwohnerzahl\n\nBestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die dazugeh√∂rigen L√§nder.\nBereinigen Sie ggf. fehlerhafte Werte.\nWie viele Einwohner leben in Europa insgesamt?\n\n\nWelchen Datentyp hat die Liste einwohnerzahl?\nWelchen Datentyp haben die Eintr√§ge der Liste einwohnerzahl?\n\nDie Musterl√∂sung kann Marc machen\n\n\n\n\n\n\nMusterl√∂sung vollst√§ndiges Einlesen",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#funktion-list",
    "href": "dateien-lesen-und-schreiben.html#funktion-list",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.5 Funktion list()",
    "text": "6.5 Funktion list()\ndas geh√∂rt zum vollst√§ndigen Einlesen Die Funktion list() tut das gleiche wie das Iterieren √ºber den Datensatz mit der Methode dateiobjekt.readline()\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\nfor zeile in daten_maya: print(f‚ÄùInhalt Zeile {i}, mit {len(zeile)} Zeichen:‚Äú) print(zeile) i += 1 Rest aus SA: 03\nreadlines\nEinleitung: Da open in der Regel eine Zeichenfolge zur√ºckgibt, kommen beim Einlesen von Dateien in Python Methoden zur Stringmanipulation eine besondere Bedeutung zu.\nHier Methode dateiobjekt.readline vorstellen\nhttps://docs.python.org/3/library/stdtypes.html\nGewisse Sonderstellung, weil Zahlen manchmal als String eingelesen werden. Beim Einlesen von Dateien braucht man das h√§ufig.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#readlines-und-list",
    "href": "dateien-lesen-und-schreiben.html#readlines-und-list",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.5 .readlines() und list()",
    "text": "6.5 .readlines() und list()\nDie Methode dateiobjekt.readlines() gibt eine Liste zur√ºck, in der jede Zeile einen Eintrag darstellt. Ebenso kann die Listenfunktion list() auf Dateiobjekte angewendet werden. Beide Vorgehensweisen liefern die gleiche Liste zur√ºck, in der der Zeilenumbruch \\n mit ausgelesen wird.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\nprint(einwohner)\n\n## Dateizeiger zur√ºcksetzen\ndateiobjekt_einwohner.seek(0);\n\n# Funktion list\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\nUm den Zeilenumbruch zu entfernen, k√∂nnte mit dem Slice Operator das letzte Zeichen jedes Listeneintrags entfernt werden.\nEine andere M√∂glichkeit ist die Methode str.replace(old, new, count=-1), mit der Zeichen ersetzt oder gel√∂scht werden k√∂nnen. Die Parameter old und new geben die zu ersetzende bzw. die einzusetzende Zeichenfolge an und m√ºssen positional √ºbergeben werden. √úber den Parameter count kann eingestellt werden, wie oft die Zeichenfolge old ersetzt werden soll, standm√§√üig wird jedes Vorkommen ersetzt.\n\nprint('Hund'.replace('Hu', 'Mu'))\n\nzeichenfolge = 'Ein  kurzer Text ohne  doppelte Leerzeichen.'\n\nprint(zeichenfolge.replace('  ', ' '))\n\nMund\nEin kurzer Text ohne doppelte Leerzeichen.\n\n\nDie Methode str.replace() kann auch zum L√∂schen verwendet werden. Wird f√ºr den Parameter new eine leere Zeichenfolge √ºbergeben, wird die in old √ºbergebene Zeichenfolge gel√∂scht.\n\nprint(zeichenfolge.replace(' ', ''))\n\nEinkurzerTextohnedoppelteLeerzeichen.\n\n\nMit der Methode str.replace() k√∂nnen die Listen um den Zeilenumbruch bereinigt werden.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\n\nfor element in einwohner:\n  element.replace('\\n', '')\n  \nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\nRest aus SA: 03\nVon unsch√§tzbaren Wert beim Einlesen von Datens√§tzen (Querverweis auf m-EsD) str.replace(old, new, count=-1) # wird new als ‚Äô‚Äô √ºbergeben, entspricht die Funktion dem L√∂schen von Zeichenfolgen\nstr.split(), str.rsplit(), str.splitlines(keepends=False)\nnicht von mir verwendet, aber n√ºtzlich:\nstr.count(sub[, start[, end]]) str.find(sub[, start[, end]]) # return the lowest index in the string where substring sub is foun str.index(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found. str.rfind(sub[, start[, end]]) # return the highest index in the string where substring sub is foun str.rindex(sub[, start[, end]]) # Like find(), but raise ValueError when the substring is not found.\nstr.join(iterable) # das nutze ich einmal im m-EsD (glaube ich)\nstr.lstrip([chars]), str.rstrip([chars]), str.strip([chars]) ‚Äì&gt; default ist whitespace",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "objektorientierte-programmierung.html#aufgaben-ausgabe",
    "href": "objektorientierte-programmierung.html#aufgaben-ausgabe",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.15 Aufgaben Ausgabe",
    "text": "2.15 Aufgaben Ausgabe\n\n‚ÄúGleitkommazahlen k√∂nnen nat√ºrlich, z. B. {1015.39:12.4f}, oder wissenschaftlich, {1015.39:e}, dargestellt werden.‚Äù\n\n\nVer√§ndern Sie die nat√ºrliche Schreibweise so, dass nur noch eine Stelle nach dem Komma angezeigt wird. Was f√§llt auf?\nVer√§ndern Sie die wissenschaftliche Schreibweise so, dass anstelle von e die Zehnerbasis als E geschrieben wird.\n\n\nWandeln Sie die Zahl 1015.39 in eine Zeichenkette um und stellen Sie diese mit 12 Stellen rechtsb√ºndig dar.\nGeben Sie mit Hilfe der formatierten Zeichenketten eine Tabelle aus, welche die Spalten \\(x\\), \\(x^2\\) und \\(x^3\\) f√ºr ganze Zahlen zwischen -2 und 2 auflistet.\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.4: Musterl√∂sung Ausgabe\n\n\n\n\n\n\n\n\n\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "einleitung.html#programmcode-formatieren",
    "href": "einleitung.html#programmcode-formatieren",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "1.2 Programmcode formatieren",
    "text": "1.2 Programmcode formatieren\nBei der Formatierung von Python-Code m√ºssen nur wenige Punkte beachtet werden. Um in den ersten Beispielen eine Ausgabe mit Python zu erzeugen, wird der Aufruf einer Funktion, hier print(eingabe), vorweggenommen. Diese Funktion gibt das Argument eingabe aus.\n\nZahlen und Operatoren k√∂nnen direkt eingegeben werden. Text (genauer: eine Zeichenfolge) muss in einfache oder doppelte Anf√ºhrungszeichen gesetzt werden, andernfalls interpretiert Python diesen als Namen einer Funktion oder eines Objekts. Zeichenfolgen k√∂nnen neben Buchstaben, Sonderzeichen und Zahlen enthalten.\n\n\nprint(1 + 2)\nprint('123: Hallo Welt!')\ntext_variable = 'Hallo Python!'\nprint(text_variable)\n\n3\n123: Hallo Welt!\nHallo Python!\n\n\n\nKommentare werden mit einer vorangestellten Raute # gekennzeichnet. Kommentare markieren Code, der nicht ausgef√ºhrt werden soll, oder Erl√§uterungen.\n\n\n# Ein reiner Kommentar\n# print(\"Python ist gro√üartig!\") # auskommentierter Code, gefolgt von einem Kommentar\nprint(\"Python ist ziemlich gut.\") # auszuf√ºhrender Code, gefolgt von einem Kommentar\n\nPython ist ziemlich gut.\n\n\n\nAusdr√ºcke m√ºssen in einer Zeile stehen. L√§ngere Ausdr√ºcke k√∂nnen mit dem Backslash \\ √ºber mehrere Zeilen fortgesetzt werden (hinter \\ darf keine # stehen). Innerhalb von Funktionen wie zum Beispiel print() k√∂nnen Zeilen nach jedem Komma fortgesetzt werden.\n\n\nvariable1 = 15\nvariable2 = 25\n\n# Zeilenfortsetzung mit \\\nsumme = variable1 + \\\n    variable2\n\n# Zeilenfortsetzung innerhalb einer Funktion\nprint(variable1,\n variable2,\n  summe)\n\n15 25 40\n\n\nIn dem obenstehenden Beispiel werden Variablen angelegt. Mit Variablen besch√§ftigten wir uns im n√§chsten Kapitel. Trotzdem m√∂chte ich Sie bitten, sich variable1 und variable2 nocheinmal kurz anzusehen. Wir kommen sp√§ter darauf zur√ºck.\n\nDie Anzahl der Leerzeichen zwischen Operanden und Operatoren kann beliebig sein.\n\n\nprint(1+0, 1 + 1, 1 +                  2)\n\n1 2 3\n\n\n\nDie Einr√ºckung mit Leerzeichen kennzeichnet einen zusammengeh√∂rigen Code-Block. Innerhalb eines Code-Blocks muss immer die gleiche Anzahl Leerzeichen verwendet werden. Es muss mindestens ein Leerzeichen gesetzt werden, ansonsten ist die Anzahl der Leerzeichen beliebig. √úblich sind 2 oder 4 Leerzeichen.\nDie folgende for-Schleife f√ºhrt alle Anweisungen im einger√ºckten Ausf√ºhrungsblock aus. Die anschlie√üende, nicht einger√ºckte Zeile markiert den Beginn einer neuen, nicht zur Schleife geh√∂rigen Anweisung.\n\n\nfor i in range(2):\n    print(variable1)\n    print(variable2)\nprint(summe)\n\n15\n25\n15\n25\n40",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "einleitung.html#ausgabe-formatieren",
    "href": "einleitung.html#ausgabe-formatieren",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "1.3 Ausgabe formatieren",
    "text": "1.3 Ausgabe formatieren\nMit sogenannten f-Strings k√∂nnen formatierte Zeichenfolgen erstellt werden. Formatierte Zeichenfolgen werden mit einem den Anf√ºhrungsstrichen vorangestellten f erstellt. Werte und Variablen k√∂nnen durch Platzhalter eingesetzt werden, die mit geschweiften Klammern {} angegeben und mit Formattierungsinformationen versehen werden. Das Formatierungsformat innerhalb der geschweiften Klammer ist vereinfacht dargestellt:\n{Variablenname:PlatzbedarfAusgabetyp}\nEin f-String mit Platzhaltern ohne Formatierungsinformationen:\n\nzahl1 = 5\nzahl2 = 7\nverh√§ltnis = zahl1 / zahl2\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.7142857142857143.\n\n\nDie Anzahl der darzustellenden Nachkommastellen kann wie folgt festgelegt werden: {verh√§ltnis:.2f}.\n\n: leitet die Formatierungsbefehle ein.\n. gibt an, dass Formatierungsinformationen f√ºr die Darstellung hinter dem Dezimaltrennzeichen folgen.\n2 ist der Wert f√ºr die darzustellenden Nachkommastellen.\nf spezifiziert die Darstellung einer Gleitkommazahl ‚Äòfloat‚Äô.\n\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:.2f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist 0.71.\n\n\nDas gleiche ist mit einem Wert m√∂glich:\n\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:.3f}.\")\n\nDas Verh√§ltnis ist genauer 0.714.\n\n\nEin Wert f√ºr die insgesamt darzustellenden Stellen wird vor dem Dezimaltrennzeichen √ºbergeben {verh√§ltnis:7.2f} bzw. inklusive f√ºhrender Nullen {verh√§ltnis:07.2f}:\n\nprint(f\"Das Verh√§ltnis von {zahl1} zu {zahl2} ist {verh√§ltnis:7.2f}.\")\nprint(f\"Das Verh√§ltnis ist genauer {0.7142857142857143:07.3f}.\")\n\nDas Verh√§ltnis von 5 zu 7 ist    0.71.\nDas Verh√§ltnis ist genauer 000.714.\n\n\nDas Dezimaltrennzeichen z√§hlt als eine Stelle.\nH√§ufig verwendete Formatierung sind:\n\nganze ZahlenGleitkommazahlenZeichenfolgen\n\n\nGanze Zahlen haben den Ausgabetyp d.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nnd\nn-Stellen werden f√ºr die Ausgabe verwendet\n\n\n0nd\nAusgabe von n-Stellen, wobei die Leerstellen mit Nullen aufgef√ºllt werden.\n\n\n+d\nAusgabe des Vorzeichens auch bei positiven Zahlen\n\n\n\n\n\nGleitkommazahlen haben die Ausgabetypen f und e.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\n.mf\nm-Stellen werden f√ºr die Nachkommastellen genutzt.\n\n\nn.mf\nInsgesamt werden n-Stellen verwendet, wobei m-Stellen f√ºr die Nachkommastellen genutzt werden.\n\n\nn.me\nGenauso, aber die Ausgabe erfolgt in exponentieller Schreibweise.\n\n\n\n\n\nZeichenfolgen haben den Ausgabetyp s.\n\n\n\n\n\n\n\nFormatierung\nAusgabe\n\n\n\n\nns\nInsgesamt werden n-Stellen verwendet.\n\n\n&lt;ns, &gt;ns, ^ns\nGenauso, jedoch wird die Zeichenfolge linksb√ºndig, rechtsb√ºndig bzw. zentriert platziert.\n\n\n\n\n\n\nEine Auflistung aller verf√ºgbaren Ausgabetypen findet sich in der Python Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "einleitung.html#aufgaben-ausgabe-formatieren",
    "href": "einleitung.html#aufgaben-ausgabe-formatieren",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "1.3 Aufgaben Ausgabe formatieren",
    "text": "1.3 Aufgaben Ausgabe formatieren\n\nGleitkommazahlen k√∂nnen nat√ºrlich, z. B. {1015.39:12.4f}, oder wissenschaftlich, {1015.39:e}, dargestellt werden.\n\nVer√§ndern Sie die nat√ºrliche Schreibweise so, dass nur noch eine Stelle nach dem Komma angezeigt wird. Was f√§llt auf?\nVer√§ndern Sie die wissenschaftliche Schreibweise so, dass anstelle von e die Zehnerbasis als E geschrieben wird.\n\nWandeln Sie die Zahl 1015.39 in eine Zeichenfolge um und stellen Sie diese mit 12 Stellen rechtsb√ºndig dar.\nGeben Sie mit Hilfe der formatierten Zeichenfolge eine Tabelle aus, welche die Spalten \\(x\\), \\(x^2\\) und \\(x^3\\) f√ºr ganze Zahlen zwischen -2 und 2 auflistet.\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†1.1: Musterl√∂sung Ausgabe\n\n\n\n\n\n\n\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.\n(Arnold 2023)\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "einleitung.html#aufgaben",
    "href": "einleitung.html#aufgaben",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "1.4 Aufgaben",
    "text": "1.4 Aufgaben\n\nGleitkommazahlen k√∂nnen nat√ºrlich, z. B. {1015.39:12.4f}, oder wissenschaftlich, {1015.39:e}, dargestellt werden.\n\nVer√§ndern Sie die nat√ºrliche Schreibweise so, dass nur noch eine Stelle nach dem Komma angezeigt wird. Was f√§llt auf?\nVer√§ndern Sie die wissenschaftliche Schreibweise so, dass anstelle von e die Zehnerbasis als E geschrieben wird.\n\nWandeln Sie die Zahl 1015.39 in eine Zeichenfolge um und stellen Sie diese mit 12 Stellen rechtsb√ºndig dar.\nGeben Sie mit Hilfe der formatierten Zeichenfolge eine Tabelle aus, welche die Spalten \\(x\\), \\(x^2\\) und \\(x^3\\) f√ºr ganze Zahlen zwischen -2 und 2 auflistet.\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†1.1: Musterl√∂sung Ausgabe\n\n\n\n\n\n\n\n\n\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.\n(Arnold 2023a)\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "einleitung.html#objektorientierte-programmierung",
    "href": "einleitung.html#objektorientierte-programmierung",
    "title": "1¬† Einleitung: Programmieren mit Python",
    "section": "1.4 Objektorientierte Programmierung",
    "text": "1.4 Objektorientierte Programmierung\nPython ist eine objektorientierte Programmiersprache. In diesem Abschnitt werden die Grundz√ºge der Programmierung mit Python vermittelt. Sie erfahren, was der Unterschied zwischen einem Objekt, einer Klasse und dem Datentyp ist.\n√úberarbeiten: den Aufklapper Attribute k√∂nnte man in dieses Kapitel verschieben und auch erg√§nzen, wie man sich mit dir() die verf√ºgbaren Methoden eines Objekts ausgeben lassen kann. Eine gute Vorlage ist das Skript von Lukas\n\nKlassen, Typen, Objekte, Attribute\nDie objektorientierte Programmierung ist ein System, um Ordnung in komplexe Computerprogramme zu bringen. Ein Pythonprogramm besteht aus verschiedenen Elementen: Operatoren und Operanden, Funktionen und Methoden, Werten und Variablen und vielem mehr. Alles in Python ist ein Objekt.\nJedes Objekt geh√∂rt zu einer Klasse, beispielsweise zur Klasse der Ganzzahlen. Die Klasse bestimmt als Blaupause die Eigenschaften und das Verhalten des Objekts - etwa welche Daten gespeichert und welche Operationen ausgef√ºhrt werden k√∂nnen.\nEin kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + '2', \"Zeichen werden verkettet.\")\nprint(type(True), True + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; a2 Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, einer Klasse, mit der nicht existente Werte verarbeitet werden:\n\nprint(None + None)\n\n\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Klassen. In Python werden Klassen (class) auch Typen (type) genannt. In fr√ºheren Versionen von Python waren Klassen und Typen noch verschieden. Inzwischen gibt es diesen Unterschied nicht mehr, beide Begriffe kommen aber noch in der Sprache vor.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\nQuelle SA Datenanalyse mit Python. Idee des Kurses ‚ÄòDatenanalyse mit Python‚Äô.\n(Arnold 2023a)\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Programmieren mit Python</span>"
    ]
  },
  {
    "objectID": "einleitung.html#grundbegriffe-der-objektorientierten-programmierung",
    "href": "einleitung.html#grundbegriffe-der-objektorientierten-programmierung",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "Klassen, Typen, Objekte, Attribute\nEin Pythonprogramm besteht aus verschiedenen Elementen: Operatoren und Operanden, Funktionen und Methoden, Werten und Variablen und vielem mehr. Alles in Python ist ein Objekt.\nJedes Objekt geh√∂rt zu einer Klasse, beispielsweise zur Klasse der Ganzzahlen. Die Klasse bestimmt als Blaupause die Eigenschaften und das Verhalten des Objekts - etwa welche Daten gespeichert und welche Operationen ausgef√ºhrt werden k√∂nnen. Ein kurzes Beispiel: Abh√§ngig von ihrer Klasse, verhalten sich Objekte anders mit dem Operator +.\n\nprint(type(2), 2 + 2, \"Ganzzahlen werden addiert.\")\nprint(type('a'), 'a' + '2', \"Zeichen werden verkettet.\")\nprint(type(True), True + True, \"Logische Werte werden addiert.\")\n\n&lt;class 'int'&gt; 4 Ganzzahlen werden addiert.\n&lt;class 'str'&gt; a2 Zeichen werden verkettet.\n&lt;class 'bool'&gt; 2 Logische Werte werden addiert.\n\n\nDas liegt daran, dass das Verhalten des Operators + f√ºr die Klassen Ganzzahlen (‚Äòint‚Äô), Zeichenfolgen (‚Äòstr‚Äô) und Boolesche Werte (‚Äòbool‚Äô) definiert ist. Anders verh√§lt es sich mit None, einer Klasse, mit der nicht existente Werte verarbeitet werden:\n\nprint(None + None)\n\n\n\nunsupported operand type(s) for +: 'NoneType' and 'NoneType'\n\n\nPython kennt sehr viele Klassen. In Python werden Klassen (class) auch Typen (type) genannt. In fr√ºheren Versionen von Python waren Klassen und Typen noch verschieden. Inzwischen gibt es diesen Unterschied nicht mehr, beide Begriffe kommen aber noch in der Sprache vor.\n\n\n\n\nDatentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018\n\n¬†\nZu welcher Klasse bzw. zu welchem Typ ein Objekt geh√∂rt, kann mit der Funktion type() ermittelt werden.\n\nprint(type(print))\n\n&lt;class 'builtin_function_or_method'&gt;\n\n\nAttribute speichern Eigenschaften eines Objekts. Sie treten in der Form objekt.attribut auf und werden ohne nachfolgende Klammern aufgerufen. Attribute haben an dieser Stelle der Einf√ºhrung keine praktische Bedeutung, werden uns aber sp√§ter wieder begegnen. Eine zweite Form der Attribute ist die Methode. Methoden sind Funktionen, die zu einer bestimmten Klasse geh√∂ren. Methoden haben die Form objekt.methode(), werden also mit nachfolgenden Klammern aufgerufen. Methoden werden in Kapitel Querverweis behandelt. Der Themenbereich wird an dieser Stelle deshalb nicht weiter vertieft. Wie Sie die verf√ºgbaren Attribute und Methoden eines Objekts bestimmen erfahren Sie in Querverweis und Querverweis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "datentypen.html",
    "href": "datentypen.html",
    "title": "2¬† Datentypen",
    "section": "",
    "text": "2.1 Zahlen\nZu den Zahlen geh√∂ren Ganzzahlen, boolsche Werte (Wahrheitswerte), Gleitkommazahlen sowie komplexe Zahlen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#klassen-typen-objekte-attribute",
    "href": "datentypen.html#klassen-typen-objekte-attribute",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "",
    "text": "Datentypen in Python\n\n\nPython 3. The standard type hierarchy. von –ú–∞–∫—Å–∏–º –ü–µ ist lizensiert unter CC BY SA 4.0 und abrufbar auf wikimedia. 2018",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "datentypen.html#datentypen",
    "href": "datentypen.html#datentypen",
    "title": "2¬† Objektorientierte Programmierung",
    "section": "2.2 Datentypen",
    "text": "2.2 Datentypen\nObjekte, die Daten speichern, haben einen Datentyp. Der Datentyp gibt an, wie die gespeicherten Werte von Python interpretiert werden sollen. Beispielsweise kann der Wert ‚Äú1‚Äù ein Zeichen, eine Ganzzahl, einen Wahrheitswert, den Monat Januar oder die Auspr√§gung einer kategorialen Variablen repr√§sentieren.\nIn der Pythonbasis gibt es nur einfache Datentypen wie Ganzzahl oder Gleitkommazahlen, weshalb der Unterschied zwischen Klassen und Datentypen nicht sofort offensichtlich ist. In Python sind die Begriffe manchmal synonym, etwa f√ºr die Klasse der Ganzzahlen ‚Äòint‚Äô und den Datentyp ‚Äòint‚Äô.\nJedes Objekt geh√∂rt zu einer Klasse, aber nicht jeder Klasse ist ein Datentyp zuordenbar - beispielsweise sind auch Funktionen Objekte und geh√∂ren einer eigenen Klasse an. Die Funktion print speichert aber keine Daten und hat deshalb auch keinen Datentyp. Zu welcher Klasse bzw. zu welchem Typ ein Objekt geh√∂rt, kann mit der Funktion type() ermittelt werden.\n\nprint(type(print))\n\n&lt;class 'builtin_function_or_method'&gt;\n\n\nDeutlicher wird der Unterschied zwischen Klassen und Datentyp erst in spezialisierten Paketen wie NumPy Querverweis auf w-NumPy oder Pandas Querverweis auf w-Pandas, die weitere Datentypen in Python einf√ºhren, wie zum Beispiel Gleitkommazahlen mit 32 Bit (Datentyp ‚Äòfloat32‚Äô) und 64 Bit Speicherplatzbedarf (Datentyp ‚Äòfloat64‚Äô). Objekte vom Datentyp float32 und float64 geh√∂ren zur selben Klasse (siehe Beispiel): Sie haben die selben allgemeinen Eigenschaften und Verhaltensweisen. Sie haben aber einen unterschiedlichen Wertebereich und Speicherplatzbedarf - Gleitkommazahlen mit 64 Bit k√∂nnen gr√∂√üere Zahlen speichern, nehmen aber doppelt so viel Platz im Speicher des Computers ein.\n\n\n\n\n\n\nBeispiel¬†2.1: Datentypen in NumPy und Pandas\n\n\n\n\n\nDie Module NumPy und Pandas sind wichtige Bausteine f√ºr die Datenanalyse mit Python.\n\nimport numpy as np\n\nfloat_64 = np.array([1.0])\nprint(\"Der Datentyp des Objekts float_64 ist:\", float_64.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_64), \"\\n\")\n\nfloat_32 = np.array([1.0], dtype = 'float32')\nprint(\"Der Datentyp des Objekts float_32 ist:\", float_32.dtype)\nprint(\"Das Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays:\", type(float_32))\n\nDer Datentyp des Objekts float_64 ist: float64\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt; \n\nDer Datentyp des Objekts float_32 ist: float32\nDas Objekt geh√∂rt zur Klasse der n-dimensionalen NumPy-Arrays: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\nIn diesem Abschnitt werden die f√ºr die Datenanalyse wichtigsten Datentypen vorgestellt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Objektorientierte Programmierung</span>"
    ]
  },
  {
    "objectID": "datentypen.html#zahlen",
    "href": "datentypen.html#zahlen",
    "title": "2¬† Datentypen",
    "section": "",
    "text": "Ganzzahlen\nGanzzahlen werden standardm√§√üig im Dezimalsystem eingegeben und k√∂nnen positiv oder negativ sein.\n\nprint(12, -8)\n\n12 -8\n\n\nDar√ºber hinaus k√∂nnen Ganzzahlen auch in anderen Basen angegeben werden:\n\nDualsystem: Ziffern 0 und 1 mit einem 0b Prefix\n\n\nprint(0b1000, \"plus\", 0b0000, \"plus\", 0b0010, \\\n      \"plus\", 0b0001, \"ist\", 0b1011)\n\n8 plus 0 plus 2 plus 1 ist 11\n\n\n\nOktalsystem: Ziffern 0 bis 7 mit einem 0o Prefix\n\n\nprint(0o7000, \"plus\", 0o0700, \"plus\", 0o0020, \\\n      \"plus\", 0o0000, \"ist\", 0o7720)\n\n3584 plus 448 plus 16 plus 0 ist 4048\n\n\n\nHexadezimalsystem: Ziffern 0 bis F mit einem 0x Prefix\n\n\nprint(0xF000, \"plus\", 0x0200, \"plus\", 0x00A0, \\\n      \"plus\", 0x0001, \"ist\", 0xF2A1)\n\n61440 plus 512 plus 160 plus 1 ist 62113\n\n\n\n\nGleitkommazahlen\nGleitkommazahlen werden entweder mit dem Dezimaltrennzeichen . oder in Exponentialschreibweise angegeben. Gleitkommazahlen haben den Typ float.\n\nprint(120.6, 1206e-1, 12060e-2, \"\\n\")\n\nprint(\"Beim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\")\nprint(1e-3, \"oder\", 1e+3)\n\n120.6 120.6 120.6 \n\nBeim Lottogewinn in Exponentialschreibeweise z√§hlt das Vorzeichen.\n0.001 oder 1000.0\n\n\nDa Computer im Bin√§rsystem arbeiten, k√∂nnen Dezimalzahlen nicht exakt gespeichert werden. Beispielsweise ist die Division von 1 durch 10 dezimal gleich 0.1. Bin√§r ist 12 durch 10102 aber ein periodischer Bruch: \\[ \\frac{1_2}{1010_2} ~ {=} ~ 0,000\\overline{1100}_2 \\]\nDezimalzahlen m√ºssen deshalb als Bruch zweier Ganzzahlen approximiert werden (Der Bin√§rbruch, der 0.1 ann√§hert, ist in Dezimalschreibweise 3602879701896397 / 255). Dadurch kommt es vor, dass mehrere Gleitkommazahlen durch die selbe Bin√§rapproximation repr√§sentiert werden. Python gibt zwar die jeweils k√ºrzeste Dezimalzahl aus, da Berechnungen aber bin√§r durchgef√ºhrt werden, kann sich bei Berechnungen die n√§chste Bin√§rapproximation und damit die zugeh√∂rige k√ºrzeste Dezimalzahl √§ndern (weitere Informationen in der Python Dokumentation).\n\nprint(0.1) # Die k√ºrzeste Dezimalzahl zur Bin√§rapproximation\nprint(format(0.1, '.17g')) # Die n√§chstl√§ngere Dezimalzahl zur selben Bin√§rapproximation\nprint(0.3 - 0.2) # bin√§r gerechnet, √§ndert sich die Bin√§rapproximation\n\n0.1\n0.10000000000000001\n0.09999999999999998\n\n\nIn der praktischen Arbeit mit Python kommen deshalb gelegentlich auf den ersten Blick ungew√∂hnlich wirkende Ergebnisse vor.\n\nprint(0.1 + 0.2)\nprint(0.01 + 0.02)\nprint(0.001 + 0.002)\nprint(0.0001 + 0.0002)\nprint(0.00001 + 0.00002)\n\n0.30000000000000004\n0.03\n0.003\n0.00030000000000000003\n3.0000000000000004e-05",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#arithmetische-operatoren",
    "href": "datentypen.html#arithmetische-operatoren",
    "title": "2¬† Datentypen",
    "section": "2.2 Arithmetische Operatoren",
    "text": "2.2 Arithmetische Operatoren\nMit arithmetischen Operatoren k√∂nnen die Grundrechenarten verwendet werden. Das Ergebnis ist meist vom Typ float, au√üer, wenn beide Operanden vom Typ int sind und das Ergebnis als ganze Zahl darstellbar ist.\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\nWerden mehrere Operatoren kombiniert, so muss deren Reihenfolge beachtet bzw. durch die Verwendung von Klammern (1 + 2) * 3 hergestellt werden. Grunds√§tzlich gelten die gleichen Regeln wie beim schriftlichen Rechen. Die vollst√§ndige √úbersicht der Reihenfolge der Ausf√ºhrung ist in der Pythondokumentation aufgef√ºhrt. F√ºr die arithmethischen Operatoren gilt folgende, absteigende Reihenfolge.\n\n\n\nOperator\n\n\n\n\n**\n\n\n* , / , // , %\n\n\n+ , -\n\n\n\nBei gleichrangigen Operationen werden diese von links nach rechts ausgef√ºhrt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#aufgaben-zahlen",
    "href": "datentypen.html#aufgaben-zahlen",
    "title": "2¬† Datentypen",
    "section": "2.3 Aufgaben Zahlen",
    "text": "2.3 Aufgaben Zahlen\nL√∂sen Sie die folgenden Aufgaben mit Python.\n\n4 + 2 * 4 = ?\n2 hoch 12 = ?\nWas ist der Rest aus 315 geteilt durch 4?\nùü£ + ùü§6 / ùüß = ?\nWelche Dezimalzahl ist 111111010012 ?\n111111010012 / 1012 = ?\nWelcher Kapitalertrag ist gr√∂√üer, wenn 1000 Euro angelegt werden?\n\n20 Jahre Anlagedauer mit 3 Prozent j√§hrlicher Rendite\n30 Jahre Anlagedauer mit 2 Prozent j√§hrlicher Rendite\n\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.1: Musterl√∂sung Zahlen",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#boolsche-werte",
    "href": "datentypen.html#boolsche-werte",
    "title": "2¬† Datentypen",
    "section": "2.4 Boolsche Werte",
    "text": "2.4 Boolsche Werte\nDie boolschen Werte True und False sind das Ergebnis logischer Abfragen, die wir sp√§ter genauer kennenlernen. Sie nehmen auch die Werte 1 und 0 an und geh√∂ren in Python deshalb zu den Zahlen.\n\nprint(\"Ist 10 gr√∂√üer als 9?\", 10 &gt; 9)\nprint(\"Ist 11 kleiner als 10?\", 11 &lt; 10)\nprint(\"Ist 10 genau 10.0?\", 10 == 10.0, \"\\n\")\n\nprint(\"True und False k√∂nnen mit + addiert:\", True + False)\nprint(\"... und mit * multipliziert werden:\", True * False, \"\\n\")\n\nIst 10 gr√∂√üer als 9? True\nIst 11 kleiner als 10? False\nIst 10 genau 10.0? True \n\nTrue und False k√∂nnen mit + addiert: 1\n... und mit * multipliziert werden: 0 \n\n\n\nDie Multiplikation von Wahrheitswerten ist n√ºtzlich, um mehrere logische Abfragen zu einem logischen UND zu kombinieren:\n\nprint(\"Ist 10 &gt; 9 UND 10 &gt; 8?\", (10 &gt; 9) * (10 &gt; 8))\n\nIst 10 &gt; 9 UND 10 &gt; 8? 1\n\n\nDie Funktion bool() gibt den Wahrheitswert eines Werts zur√ºck.\n\nprint(\"Ist 10 &gt; 9 UND &gt; 8?\", bool((10 &gt; 9) * (10 &gt; 8)))\n\nIst 10 &gt; 9 UND &gt; 8? True\n\n\nDie meisten Werte in Python haben den Wahrheitswert True.\n\nprint(bool(1), bool(2), bool(2.4))\nprint(bool('a'), bool('b'), bool('ab'))\n\nTrue True True\nTrue True True\n\n\nNeben False und 0 haben leere und nicht existierende Werte oder Objekte den Wahrheitswert False.\n\nprint(bool(False), bool(0))\nprint(bool(\"\")) # eine leere Zeichenfolge\nprint(bool([])) # eine leere Liste\nprint(bool(())) # eine leeres Tupel\nprint(bool({})) # ein leeres Dictionary\nprint(bool(None)) # None deklariert einen nicht existenten Wert\n\nFalse False\nFalse\nFalse\nFalse\nFalse\nFalse\n\n\nDie Sammeltypen Liste, Tupel und Dictionary lernen wir in den folgenden Kapiteln kennen. Boolsche Werte k√∂nnen die Ausf√ºhrung von Programmcode steuern, indem sie wie an und aus wirken. So kann Programmcode mit einer if-Anweisung nur dann ausgef√ºhrt werden, wenn ein Sammeltyp auch Werte enth√§lt.\n\nmeine_Liste = ['√Ñpfel', 'Butter']\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nmeine_Liste = [] # eine leere Liste\nif meine_Liste:\n    print(f\"Wir m√ºssen {meine_Liste} einkaufen.\")\n\nWir m√ºssen ['√Ñpfel', 'Butter'] einkaufen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#logische-operatoren",
    "href": "datentypen.html#logische-operatoren",
    "title": "2¬† Datentypen",
    "section": "2.5 Logische Operatoren",
    "text": "2.5 Logische Operatoren\nZu den logischen Operatoren geh√∂ren die logischen Verkn√ºpfungen and, or und not. Dar√ºber hinaus k√∂nnen auch vergleichende Operatoren wie &gt;, &gt;= oder == verwendet werden. Das Ergebnis dieser Operationen ist vom Typ bool. Die Operatoren werden in folgender Reihenfolge ausgef√ºhrt. Gleichrangige Operatoren werden von links nach rechts ausgef√ºhrt.\n\n\n\n\n\n\n\nOperator\nBeschreibung\n\n\n\n\n&\nbitweises UND\n\n\n^\nbitweises XOR\n\n\n|\nbitweises ODER\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==\nkleiner / kleiner gleich / gr√∂√üer als / gr√∂√üer gleich / ungleich / gleich\n\n\nnot\nlogisches NICHT\n\n\nand\nlogisches UND\n\n\nor\nlogisches ODER\n\n\n\n\n\n\n\n\n\nHinweis¬†2.1: Bitweise Operatoren\n\n\n\n\n\nBesondere Vorsicht ist mit den bitweisen Operatoren geboten. Diese vergleichen Zahlen, allerdings nicht als Ganzes, sondern stellenweise (im Bin√§rsystem). Zu beachten ist, dass die bitweisen Operatoren Ausf√ºhrungspriorit√§t vor Vergleichsoperationen haben.\n\nprint(10 &gt; 5 and 10 &gt; 6)\nprint(10 &gt; 5 & 10 &gt; 6)\nprint(5 & 10)\nprint(10 &gt; False &gt; 6)\nprint((10 &gt; 5) & (10 &gt; 6))\n\nTrue\nFalse\n0\nFalse\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nIm Allgemeinen werden die bitweisen Operatoren f√ºr die Datenanalyse nicht ben√∂tigt. Vermeiden Sie unn√∂tige Fehler: Vermeiden Sie die bitweisen Operatoren &, ^ und |.\nDie Operatoren &, ^ und | haben jedoch f√ºr Mengen (die wir sp√§ter kennenlernen werden) eine andere Bedeutung. Auch in anderen Modulen kommt den Operatoren syntaktisch eine andere Bedeutung zu, bspw. im Paket Pandas bei der √úbergabe mehrerer Slicing-Bedingungen df = df[(Bedingung1) & (Bedingung2) | (Bedingung3)].",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#aufgaben-boolsche-werte",
    "href": "datentypen.html#aufgaben-boolsche-werte",
    "title": "2¬† Datentypen",
    "section": "2.6 Aufgaben boolsche Werte",
    "text": "2.6 Aufgaben boolsche Werte\nL√∂sen Sie die Aufgaben mit Python.\n\nIst das Verh√§ltnis aus 44 zu 4.5 gr√∂√üer als 10?\nIst es wahr, dass 4.5 gr√∂√üer als 4 aber kleiner als 5 ist?\nIst 2 hoch 10 gleich 1024?\nSind die Zahlen 3, 4 und 5 ganzzahlig durch 2 teilbar ODER ungleich 10?\nPr√ºfen Sie, ob eine Person den Vollpreis bezahlen muss, wenn Sie Ihr Alter angibt.\nKinder unter 14 Jahren fahren kostenlos, Jugendliche zwischen 14 und 18 Jahren und Senior:innen ab 65 Jahren erhalten einen Rabatt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#zeichenfolgen",
    "href": "datentypen.html#zeichenfolgen",
    "title": "2¬† Datentypen",
    "section": "2.7 Zeichenfolgen",
    "text": "2.7 Zeichenfolgen\nZeichenfolgen (Englisch string) werden in Python in einfache oder doppelte Anf√ºhrungszeichen gesetzt.\n\nprint('eine Zeichenfolge')\nprint(\"noch eine Zeichenfolge\")\n\neine Zeichenfolge\nnoch eine Zeichenfolge\n\n\nInnerhalb einer Zeichenfolge k√∂nnen einfache oder doppelte Anf√ºhrungszeichen verwendet werden, solange diese nicht den die Zeichenfolge umschlie√üenden Anf√ºhrungszeichen entsprechen.\n\nprint('A sophisticated heap beam, which we call a \"LASER\".')\nprint(\"I've turned the moon into what I like to call a 'Death Star'.\")\n\nA sophisticated heap beam, which we call a \"LASER\".\nI've turned the moon into what I like to call a 'Death Star'.\n\n\nDas Steuerzeichen \\ (oder Fluchtzeichen, escape character) erlaubt es, bestimmte Sondernzeichen zu verwenden.\n\nprint(\"Das Steuerzeichen \\\\ erm√∂glicht die gleichen \\\"Anf√ºhrungszeichen\\\" in der Ausgabe von print.\")\nprint(\"Erst ein\\tTabstopp, dann eine\\nneue Zeile.\")\n\nDas Steuerzeichen \\ erm√∂glicht die gleichen \"Anf√ºhrungszeichen\" in der Ausgabe von print.\nErst ein    Tabstopp, dann eine\nneue Zeile.\n\n\nEin vorangestelltes r bewirkt, dass das Steuerzeichen \\ nicht verarbeitet wird (raw string literal). Dies ist beispielsweise bei der Arbeit mit Dateipfaden praktisch.\n\nprint(\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\nprint(r\"Die Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann\")\n\nDie Daten liegen unter: C:  olle_daten\nordpol\\weihnachtsmann\nDie Daten liegen unter: C:\\tolle_daten\\nordpol\\weihnachtsmann",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#operationen-mit-zeichenfolgen",
    "href": "datentypen.html#operationen-mit-zeichenfolgen",
    "title": "2¬† Datentypen",
    "section": "2.8 Operationen mit Zeichenfolgen",
    "text": "2.8 Operationen mit Zeichenfolgen\nEinige Operatoren funktionieren auch mit Daten vom Typ string.\n\n# string + string\nprint('a' + 'b')\nprint(\"\\n\")\n\n# string + Zahl\nprint(15 * 'a')\nprint(\"\\n\")\n\n# logische Operatoren\nprint('a' &lt; 'b', 'a' &gt;= 'b', 'a' != 'b')\nprint('a' or 'b', 'a' and 'b')\n\nab\n\n\naaaaaaaaaaaaaaa\n\n\nTrue False True\na b",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#aufgaben-zeichenfolgen",
    "href": "datentypen.html#aufgaben-zeichenfolgen",
    "title": "2¬† Datentypen",
    "section": "2.9 Aufgaben Zeichenfolgen",
    "text": "2.9 Aufgaben Zeichenfolgen\nL√∂sen Sie die Aufgaben mit Python.\n\nWas passiert, wenn Sie die Zeichenfolge ‚ÄúPython‚Äù mit ‚Äúfor beginners‚Äù addieren?\nErzeugen Sie eine Zeichenfolge, die 10 mal die Zeichenfolge ‚Äútick tack‚Äù.\nWelche Zeichenfolge ist kleiner, ‚ÄúAachen‚Äù oder ‚ÄúBern‚Äù. Warum ist das so, wie werden Zeichenfolgen verglichen?\nGeben Sie den Dateipfad aus: ‚Äú~_daten‚Äù\n\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.2: Musterl√∂sung Aufgaben Zeichenfolgen",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#variablen",
    "href": "datentypen.html#variablen",
    "title": "2¬† Datentypen",
    "section": "2.10 Variablen",
    "text": "2.10 Variablen\nVariablen sind Platzhalter bzw. Referenzen auf Daten. Die Zuweisung wird durch den Zuweisungsoperator = dargestellt. Der Name einer Variablen darf nur aus Buchstaben, Zahlen und Unterstrichen bestehen. Dabei darf das erste Zeichen keine Zahl sein.\n\nvar_1 = 'ABC'\nvar_2 = 26\nvar_3 = True\n\nprint(\"Das\", var_1, \"hat\", var_2, \"Buchstaben. Das ist\", var_3)\n\nDas ABC hat 26 Buchstaben. Das ist True\n\n\nVariablen m√ºssen in Python nicht initialisiert werden. Der Datentyp der Variablen wird durch die Zuweisung eines entsprechenden Werts festgelegt.\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\nprint(\"Die Variable var_2 hat den Typ\", type(var_2))\nprint(\"Die Variable var_3 hat den Typ\", type(var_3))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nDer Datentyp einer Variable √§ndert sich, wenn ihr ein neuer Wert eines anderen Datentyps zugewiesen wird.\n\nvar_1 = 100\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'int'&gt;\n\n\nEbenso kann sich der Datentyp einer Variable √§ndern, um das Ergebnis einer Operation aufnehmen zu k√∂nnen. In diesem Beispiel kann das Ergebnis nicht in Form einer Ganzzahl gespeichert werden. Python weist dem Objekt var_1 deshalb den Datentyp ‚Äòfloat‚Äô zu.\n\nvar_1 = var_1 / 11\nprint(\"Die Variable var_1 hat den Typ\", type(var_1))\n\nDie Variable var_1 hat den Typ &lt;class 'float'&gt;\n\n\nPython enth√§lt Funktionen, um den Datentyp einer Variablen zu bestimmen und umzuwandeln. Die Funktion type() wurde in den Code-Beispielen bereits benutzt, um den Datentyp (bzw. die Klasse) von Objekten zu bestimmen. Die Umwandlung des Datentyps zeigt der folgende Code-Block.\n\na = 67 \nprint(a, type(a))\n\nb = a + 1.8\nprint(b, type(b), \"\\n\")\n\nprint(f\"Beachten Sie das Abschneiden der Nachkommastelle:\\nUmwandlung in Ganzzahlen mit int(): {( a := int(a) ), (b := int(b) )}\\n\")\n\nprint(f\"Umwandlung in ASCII-Zeichen mit chr(): {( a := chr(a) ), ( b := chr(b) )}\\n\")\n\nprint(f\"Umwandlung in eine ASCII-Zahl mit ord(): {( a := ord(a) ), ( b := ord(b) )}\\n\")\n\nprint(f\"Umwandlung in Flie√ükommazahlen mit float(): {( a := float(a) ), ( b := float(b) )}\\n\")\n\nprint(f\"Umwandlung in Zeichen mit str(): {( a := str(a) ), ( b:= str(b) )}\\n\")\n\nprint(f\"Umwandlung in Wahrheitswerte mit bool(): {bool(a), bool(b)}\")\n\n67 &lt;class 'int'&gt;\n68.8 &lt;class 'float'&gt; \n\nBeachten Sie das Abschneiden der Nachkommastelle:\nUmwandlung in Ganzzahlen mit int(): (67, 68)\n\nUmwandlung in ASCII-Zeichen mit chr(): ('C', 'D')\n\nUmwandlung in eine ASCII-Zahl mit ord(): (67, 68)\n\nUmwandlung in Flie√ükommazahlen mit float(): (67.0, 68.0)\n\nUmwandlung in Zeichen mit str(): ('67.0', '68.0')\n\nUmwandlung in Wahrheitswerte mit bool(): (True, True)\n\n\n\nWeitere Zuweisungsoperatoren\nIn dem obenstehenden Code-Block wurde der sogenannte Walross-Operator := verwendet. Dieser erlaubt es, Zuweisungen innerhalb eines Ausdrucks (hier innerhalb der Funktion print()) vorzunehmen. Python kennt eine ganze Reihe weiterer Zuweisungsoperatoren (weitere Operatoren siehe Python-Dokumentation oder √ºbersichtlicher hier).\n\n\n\nOperator\nentspricht der Zuweisung\n\n\n\n\na += 2\na = a + 2\n\n\na -= 2\na = a - 2\n\n\na *= 2\na = a * 2\n\n\na /= 2\na = a / 2\n\n\na %= 2\na = a % 2\n\n\na //= 2\na = a // 2\n\n\na **= 2\na = a ** 2\n\n\n\n\n\n\n\n\n\nLesbare Zuweisungen\n\n\n\n\n\nDie in der Tabelle gezeigten Zuweisungsoperatoren sind f√ºr jemanden, der*die Ihren Code liest, gut zu lesen und nachzuvollziehen, da Zuweisungen immer am Beginn einer Zeile, also ganz links, stehen.\nDagegen kann der Walross-Operator an einer beliebigen Stelle in Ihrem Code stehen. Das mag f√ºr Sie beim Schreiben ein Vorteil sein, der Lesbarkeit ist das aber abtr√§glich. Wenn Sie den Walross-Operator verwenden, achten Sie deshalb auf die Nachvollziehbarkeit Ihres Codes.\n\n\n\n\n\nBenennung von Variablen\nF√ºr die Benennung von Variablen gibt es (meist) nur wenige Vorgaben. Trotzdem ist es besser, einen langen, aber ausf√ºhrlichen Variablennamen zu vergeben, als einen kurzen, der sich schnell schreiben l√§sst. Denn Programmcode wird deutlich h√§ufiger gelesen als geschrieben. K√∂nnen Sie sich erinnern? Welcher Wert ist in der Variablen Var_3 gespeichert, und welche Werte sind in variable1 und a gespeichert? Es reicht schon, wenn Sie sich an den richtigen Datentyp erinnern k√∂nnen.\nFalls Sie sich nicht erinnern k√∂nnen, dann ist dieses Beispiel gelungen: Die Namensgebung dieser Variablen ist alles andere als gut. Die Aufl√∂sung steht im folgenden Aufklapper.\n\n\n\n\n\n\nAufl√∂sung Variablen\n\n\n\n\n\n\nprint(var_3, type(var_3))\nprint(variable1, type(variable1))\nprint(a, type(a))\n\nTrue &lt;class 'bool'&gt;\n15 &lt;class 'int'&gt;\n67.0 &lt;class 'str'&gt;\n\n\n\n\n\nDeshalb empfiehlt es sich ‚Äúsprechende‚Äù, das hei√üt selbsterkl√§rende, Variablennamen zu vergeben. Unter selbsterkl√§renden Variablennamen versteht sich, dass der Variablenname den Inhalt der Variable beschreibt. Wird bspw. in einer Variable der Studienabschluss gespeichert, so kann diese mit academic_degree oder studienabschluss bezeichnet werden. Werden Daten aus verschiedenen Jahren verarbeitet, kann das Jahr zu besseren Unterscheidbarkeit in den Variablennamen einflie√üen, etwa: academic_degree_2023 oder studienabschluss2024. Dies verbessert die Lesbarkeit des Codes und vereinfacht die Benutzung der Variable. Mehr Informationen finden sich in diesem Wikipedia Abschnitt.\n\n\n\n\n\n\nSchl√ºsselw√∂rter und Funktionsnamen\n\n\n\nIn Python reservierte Schl√ºsselw√∂rter und Funktionsnamen sind ungeeignete Variablennamen. W√§hrend Python die Wertzuweisung zu Schl√ºsselw√∂rtern wie True oder break mit einem Syntaxfehler quittiert, lassen sich Funktionsnamen neue Werte zuweisen, beispielsweise mit print = 6. Wenn Sie die Funktion print dann aufrufen, funktioniert diese nat√ºrlich nicht mehr. In diesem Fall m√ºssen Sie die Zuweisung aus dem Skript entfernen und Python neu starten.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "datentypen.html#aufgaben-variablen",
    "href": "datentypen.html#aufgaben-variablen",
    "title": "2¬† Datentypen",
    "section": "2.11 Aufgaben Variablen",
    "text": "2.11 Aufgaben Variablen\n\nSchreiben Sie ein Skript, welches eine gegebene Zeit ùóç in Sekunden in die Anzahl Tage, Stunden, Minuten und Sekunden aufteilt und diese Aufteilung ausgibt.\nBerechnen Sie die Aufteilung f√ºr folgende Zeiten:\n\n79222 s\n90061 s\n300000 s\n\nDie Position eines Fahrzeugs zur Zeit \\(t\\), welches konstant mit der Beschleunigung \\(a\\) beschleunigt, ist gegeben durch:\n\n\\[\nx(t) = x_0 + v_0 \\cdot t + \\frac{1}{2} \\cdot a t^2\n\\]\nDabei ist \\(x_0\\) die Anfangsposition und \\(v_0\\) die Anfangsgeschwindigkeit. Erstellen Sie Variablen f√ºr \\(x_0\\), \\(v_0\\) und \\(a\\) und weisen Sie ihnen Werte zu. Da die Variablen nur Werte, aber keine Einheiten abbilden, √ºberlegen Sie sich die ggf. notwendigen Umrechnungen. Folgende Werte k√∂nnen sie als Beispiel verwenden:\n\\[\nx_0 = 10 \\, km \\,\\,\\,v_0 = 50 \\frac{km}{h} \\,\\,\\,a = 0.1 \\frac{m}{s^2}\n\\]\nErzeugen Sie eine Variable f√ºr den Zeitpunkt \\(t\\), z. B.: \\(t = 10 \\, min\\). Berechnen Sie mit obiger Gleichung und mit Hilfe der Variablen die Position \\(x(t)\\). Geben Sie nicht nur den Wert von \\(x(t)\\) in Kilometer aus, sondern betten ihn in einen ganzen Antwortsatz (einschlie√ülich Einheiten) ein.\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†2.3: Musterl√∂sung Aufgaben Variablen\n\n\n\n\n\n\n\n\n\n(Arnold 2023a)\n(Arnold 2023b)\n\n\n\n\nArnold, Simone. 2023a. ‚ÄûDatenanalyse mit Python. Datentypen und Grundlagen.‚Äú Fachhochschule Dortmund.\n\n\n‚Äî‚Äî‚Äî. 2023b. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Datentypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#listen-und-listenelemente-kopieren",
    "href": "sammeltypen.html#listen-und-listenelemente-kopieren",
    "title": "4¬† Sammeltypen",
    "section": "4.3 Listen und Listenelemente kopieren",
    "text": "4.3 Listen und Listenelemente kopieren\nIn Python enthalten Listen Daten nicht direkt, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. In Python werden Listen nicht durch Zuweisung kopiert, sondern greifen dann auf den selben Speicherort zu. Um eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen, kann die Methode liste.copy() verwendet werden. Auch durch die Verwendung des Zugriffsoperators [:] wird eine neue Liste im Speicher angelegt.\n\n# Kopieren durch Zuweisung\nliste1 = [1, 'xy', True, text_variable]\nprint(\"liste1:\", liste1, \"\\n\")\nliste2 = liste1\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"Auch liste1 hat sich durch die Zuweisung in liste2 ver√§ndert:\", liste1, \"\\n\")\n\n# Verwendung der Methode liste.copy()\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1.copy()\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1, \"\\n\")\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[:]\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1)\n\nliste1: [1, 'xy', True, 'abc'] \n\nAuch liste1 hat sich durch die Zuweisung in liste2 ver√§ndert: ['ABC', 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc']\n\n\nDie Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[0:2]\n\n# √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1)\n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc']\n\n\nUm zu √ºberpr√ºfen, ob sich zwei Objekte den Speicherbereich teilen, kann die Objekt-ID mit der Funktion id() verglichen oder die Operatoren is bzw. is not verwendet werden, die die Funktion id() aufrufen.\n\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1\n\nprint(\"ID liste1:\", id(liste1))\nprint(\"ID liste2:\", id(liste2))\nprint(\"ID liste1 gleich ID list2:\", liste1 is liste2)\n\nID liste1: 1879584773120\nID liste2: 1879584773120\nID liste1 gleich ID list2: True\n\n\n\n\n\n\n\n\nIdentit√§t vs.¬†Wertgleichheit\n\n\n\n\n\nDer Operator is pr√ºft die Identit√§t zweier Objekte und unterscheidet sich dadurch vom logischen Operator ==, der auf Wertgleichheit pr√ºft. Da liste1 und liste2 die gleichen Elemente enthalten, liegen sowohl Identit√§t und Wertgleichheit vor. Der Unterschied von Identit√§t und Wertgleichheit kann anhand eines Werts verdeutlicht werden (Im Code-Beispiel wird eine Syntax-Warnung unterdr√ºckt.).\n\n# Wertgleichheit\nprint(1 == 1.0)\nprint(liste1 == liste2, \"\\n\")\n\n# Identit√§t\nprint(1 is 1.0)\nprint(liste1 is liste2)\n\nTrue\nTrue \n\nFalse\nTrue",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#aufgaben-listen",
    "href": "sammeltypen.html#aufgaben-listen",
    "title": "4¬† Sammeltypen",
    "section": "4.4 Aufgaben Listen",
    "text": "4.4 Aufgaben Listen\n\nErstellen Sie eine Liste ‚Äòwochentage‚Äô, die die sieben Tage der Woche enth√§lt. Verwenden Sie den Slice-Operator, um eine neue Liste ‚Äòwochenende‚Äô mit den Tagen des Wochenendes zu erstellen. Entfernen Sie die Tage des Wochenendes aus der Liste ‚Äòwochentage‚Äô.\n4-Tage-Woche: Verwenden Sie Listenmethoden, um den Freitag aus der Liste ‚Äòwochentage‚Äô zu entfernen und der Liste ‚Äòwochenende‚Äô hinzuzuf√ºgen.\nBestimmen Sie in der Liste zahlen = [34, 12, 0, 67, 23] die Position des Werts 0. Entfernen Sie den Wert aus der Liste und geben Sie die Liste aufsteigend sortiert aus.\nGeben Sie nun mit Hilfe des Zugriffsoperators [] die Indexpositionen 1 und 3 der sortierten Liste ‚Äòzahlen‚Äô aus.\n\nMusterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†4.1: Musterl√∂sung",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "sammeltypen.html#√ºbersicht-sammeltypen",
    "href": "sammeltypen.html#√ºbersicht-sammeltypen",
    "title": "4¬† Sammeltypen",
    "section": "4.5 √úbersicht Sammeltypen",
    "text": "4.5 √úbersicht Sammeltypen\n\n\n\n\n\n\n\n\n\n\nMerkmal\nListen\nTupel\nMengen\nDictionary\n\n\n\n\nBeschreibung\nflexible Anzahl von Elementen beliebigen Typs\nElemente beliebigen Typs, unver√§nderlich\nungeordnete Sammlung, jedes Element nur einmal enthalten\nZuordnungstabelle aus Schl√ºssel-Wert-Paaren\n\n\nSpeicherbereich bei Zuweisung geteilt\nja\nja (aber unver√§nderlich)\nja (aber Zugriffsoperator nicht anwendbar)\nja\n\n\nMethode .copy() definiert\nja\nnein\nja\nja\n\n\nSlice-Operator anwendbar\nja\nja\nnein\nja (nach Schl√ºssel)",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#daten-interpretieren",
    "href": "dateien-lesen-und-schreiben.html#daten-interpretieren",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.4 Daten interpretieren",
    "text": "6.4 Daten interpretieren\nDatens√§tze liegen typischerweise wenigstens in zweidimensionaler Form vor, d.¬†h. die Daten sind in Zeilen und Spalten organisiert. Au√üerdem weisen Datens√§tze in der Regel auch unterschiedliche Datentypen auf. Die Funktion open(datei) gibt ein Dateiobjekt zur√ºck, das mit Methoden wie zum Beispiel dateiobjekt.read() als Zeichenfolge eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu k√∂nnen, ist es deshalb notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden.\nF√ºr die Bearbeitung von Zeichenfolgen bietet Python eine Reihe von String-Methoden. Einige davon werden in diesem Kapitel exemplarisch verwendet. String-Methoden werden in der Regel mit einem f√ºhrenden ‚Äòstr‚Äô in der Form str.methode() genannt.\nBeispielsweise soll eine Datei mit den Einwohnerzahlen der europ√§ischen L√§nder eingelesen werden.\n\n\n\nDaten\nDateiname\n\n\n\n\nEinwohner Europas\neinwohner_europa_2019.csv\n\n\n\n¬†\nUm einen √úberblick √ºber den Aufbau der Datei zu erhalten, werden die ersten drei Zeilen der Datei ausgegeben. Daf√ºr kann die Datei zeilenweise mit einer for-Schleife durchlaufen werden, die mit dem Schl√ºsselwort break abgebrochen wird, wenn die Laufvariable den Wert 3 erreicht hat. Eine andere M√∂glichkeit ist die Methode dateiobjekt.readline(), die eine einzelne Zeile ausliest. Hier wird die H√§ufigkeit der Schleifenausf√ºhrung √ºber die Laufvariable mit for i in range(3): gesteuert.\n\nfor-Schleife mit breakMethode dateiobjekt.readline()\n\n\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# erste 3 Zeilen anschauen\ni = 0\nfor zeile in dateiobjekt_einwohner:\n  \n  print(zeile)\n  i += 1\n  if i == 3:\n    break\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\nMit der Methode dateiobjekt.readline() kann eine einzelne Zeile eingelesen werden.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\nfor i in range(3):\n  print(dateiobjekt_einwohner.readline())\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\n\nDie Datei hat also zwei Spalten. In der ersten Spalte sind die L√§ndernamen eingetragen, in der zweiten Spalte die Werte. Als Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die Spaltenbeschriftungen eingetragen.\nIm vorherigen Abschnitt haben wir die Methode dateiobjekt.read() kennengelernt, mit der eine Datei vollst√§ndig als string eingelesen wird. Zun√§chst wird die Datei mit der Methode dateiobjekt.read() in das Objekt einwohner eingelesen und wieder geschlossen.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n\n\nAnschlie√üend k√∂nnen die eingelesenen Daten mit der Methode str.split('\\n') zeilweise aufgeteilt werden. Mit '\\n' wird als Argument der Zeilenumbruch √ºbergeben. Die Methode liefert eine Liste zur√ºck.\n\nliste_einwohner_zeilenweise = einwohner.split(\"\\n\")\nprint(liste_einwohner_zeilenweise[0:3])\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']\n\n\nDie Liste enth√§lt an der Indexposition die Spaltenbeschriftungen. Diese k√∂nnen mit der Methode liste.pop(index) aus der Liste entfernt und zugleich in einem neuen Objekt gespeichert werden.\n\nspaltennamen = liste_einwohner_zeilenweise.pop(0)\nspaltennamen = spaltennamen.split(',')\nprint(f\"√úberschrift Spalte 0: {spaltennamen[0]}\\t√úberschrift Spalte 1: {spaltennamen[1]}\")\n\n√úberschrift Spalte 0: GEO   √úberschrift Spalte 1: Value\n\n\nAnschlie√üend kann die Liste mit der Methode str.split(',') nach L√§ndern und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per Ausnahmebehandlung abgefangen. Neben der Fehlermeldung werden der verursachende Listeneintrag und dessen Indexposition ausgegeben.\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept Exception as error:\n  # print Fehlermeldung\n  print(f\"Fehlermeldung: {error}\")\n  \n  # print Eintrag und Index\n  print(f\"Eintrag: {eintrag}\\t Zeilenindex: {liste_einwohner_zeilenweise.index(zeile)}\")\n\nFehlermeldung: list index out of range\nEintrag: ['']    Zeilenindex: 29\n\n\nDie Fehlermeldung ist so zu deuten, dass eine der Listenoperationen mit dem Slice Operator einen ung√ºltigen Index anspricht. Leicht angepasst, liefert der Code-Block auch die Ursache der Fehlermeldung.\nWird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der L√§ndernamen und der Werte.\n\n# leere Zeile entfernen\nliste_einwohner_zeilenweise.remove('')\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nGEO\n['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] \n\nValue\n['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#aufgabe-daten-interpretieren",
    "href": "dateien-lesen-und-schreiben.html#aufgabe-daten-interpretieren",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.5 Aufgabe Daten interpretieren",
    "text": "6.5 Aufgabe Daten interpretieren\n\nBestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die dazugeh√∂rigen L√§nder.\nBereinigen Sie ggf. fehlerhafte Werte.\nWie viele Einwohner leben in Europa insgesamt?\n\n\nWelchen Datentyp hat die Liste einwohnerzahl?\nWelchen Datentyp haben die Eintr√§ge der Liste einwohnerzahl?\n\nDie Musterl√∂sung kann Marc machen\n\n\n\n\n\n\nMusterl√∂sung vollst√§ndiges Einlesen",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#einlesen-als-liste",
    "href": "dateien-lesen-und-schreiben.html#einlesen-als-liste",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.6 Einlesen als Liste",
    "text": "6.6 Einlesen als Liste\nEin Dateiobjekt kann auch direkt als Liste eingelesen werden. Die Methode dateiobjekt.readlines() gibt eine Liste zur√ºck, in der jede Zeile einen Eintrag darstellt. Ebenso kann die Listenfunktion list() auf Dateiobjekte angewendet werden. Beide Vorgehensweisen liefern die gleiche Liste zur√ºck, in der der Zeilenumbruch \\n mit ausgelesen wird.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\nprint(einwohner)\n\n## Dateizeiger zur√ºcksetzen\ndateiobjekt_einwohner.seek(0);\n\n# Funktion list\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\nUm den Zeilenumbruch zu entfernen, k√∂nnte mit dem Slice Operator das letzte Zeichen jedes Listeneintrags entfernt werden.\nEine andere M√∂glichkeit ist die Methode str.replace(old, new, count=-1), mit der Zeichen ersetzt oder gel√∂scht werden k√∂nnen. Die Parameter old und new geben die zu ersetzende bzw. die einzusetzende Zeichenfolge an und m√ºssen positional √ºbergeben werden. √úber den Parameter count kann eingestellt werden, wie oft die Zeichenfolge old ersetzt werden soll. Standardm√§√üig wird jedes Vorkommen ersetzt.\n\nprint('Hund'.replace('Hu', 'Mu'))\n\nzeichenfolge = 'Ein  kurzer Text ohne  doppelte Leerzeichen.'\n\nprint(zeichenfolge.replace('  ', ' '))\n\nMund\nEin kurzer Text ohne doppelte Leerzeichen.\n\n\nDie Methode str.replace() kann auch zum L√∂schen verwendet werden. Wird f√ºr den Parameter new eine leere Zeichenfolge √ºbergeben, wird die in old √ºbergebene Zeichenfolge gel√∂scht.\n\nprint(zeichenfolge.replace(' ', '').replace('doppelte', ''))\n\nEinkurzerTextohneLeerzeichen.\n\n\nMit der Methode str.replace() kann die eingelesene Liste um den Zeilenumbruch bereinigt werden.\n\ndateipfad = \"skript/01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\neinwohner_neu = []\n\nfor element in einwohner:\n  einwohner_neu.append(element.replace('\\n', ''))\n\neinwohner = einwohner_neu\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039', 'Tschechien,10528984', 'Daenemark,5799763', 'Deutschland einschliesslich ehemalige DDR,82940663', 'Estland,1324820', 'Irland,4904240', 'Griechenland,10722287', 'Spanien,46934632', 'Frankreich,67028048', 'Kroatien,4076246', 'Italien,61068437', 'Zypern,875898', 'Lettland,1919968', 'Litauen,2794184', 'Luxemburg,612179', 'Uganda,-1', 'Ungarn,9772756', 'Malta,493559', 'Niederlande,17423013', 'Oesterreich,8842000', 'Polen,37972812', 'Portugal,10276617', 'Rumaenien,19405156', 'Slowenien,2080908', 'Slowakei,5450421', 'Finnland,5512119', 'Schweden,10243000', 'Vereinigtes Koenigreich,66647112']",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "dateien-lesen-und-schreiben.html#aufgabe-dateien-schreiben",
    "href": "dateien-lesen-und-schreiben.html#aufgabe-dateien-schreiben",
    "title": "6¬† Dateien lesen und schreiben",
    "section": "6.8 Aufgabe Dateien schreiben",
    "text": "6.8 Aufgabe Dateien schreiben\n\nErzeugen Sie eine neue Datei mit der Endung .txt, die den Namen ihrer Heimatstadt hat. Schreiben Sie in diese Datei 10 Zeilen mit Informationen zur Stadt.\n\n¬† (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "module-und-pakete-importieren.html",
    "href": "module-und-pakete-importieren.html",
    "title": "7¬† Module und Pakete importieren",
    "section": "",
    "text": "7.1 Kleine Modul√ºbersicht\nDa es nicht m√∂glich ist auf alle diese Module einzugehen, werden im folgenden nur einige wenige Module aufgelistet, welche f√ºr die Zielgruppe dieses Skripts interessant sein k√∂nnten. Hinweis: Die Eigennamen einiger Module weisen eine Gro√ü- und Kleinschreibung auf, bspw. das Modul NumPy. Beim Importieren der Module werden die Modulnamen jedoch klein geschrieben. In der folgenden Liste wird auf die Gro√ü- und Kleinschreibung daher verzichtet.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  },
  {
    "objectID": "module-und-pakete-importieren.html#kleine-modul√ºbersicht",
    "href": "module-und-pakete-importieren.html#kleine-modul√ºbersicht",
    "title": "7¬† Module und Pakete importieren",
    "section": "",
    "text": "math: Mathematische Funktionen und Konstanten\nsys: Interaktion mit dem Python-Interpreter\nos: Interaktion mit dem Betriebssystem\ntime: Zeitfunktionen\nglob: Durchsuchen von Dateisystempfaden\nmultiprocessing / threading: Parallelprogramierung mit Prozessen / Threads\nmatplotlib: Visualisierung von Daten und Erstellen von Abbildungen\nnumpy: Numerische Operationen und Funktionen\nscipy: Wissenschaftliche Funktionen\npandas: Daten einlesen und auswerten",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  },
  {
    "objectID": "module-und-pakete-importieren.html#import-as",
    "href": "module-und-pakete-importieren.html#import-as",
    "title": "7¬† Module und Pakete importieren",
    "section": "7.2 import as",
    "text": "7.2 import as\nUm lange Modulnamen zu vereinfachen, kann beim Importieren das Schl√ºsselwort as verwendet werden, um dem Modul einen neuen Namen zuzuweisen.\n\nimport matplotlib.pyplot as plt\n\nplt.plot(zufallsdaten)\n\n\n\n\nGrafik mit dem Modul pyplot aus dem Paket matplotlib\n\n\n\n\n¬†\nF√ºr h√§ufig verwendete Module haben sich bestimmte K√ºrzel etabliert. In den Bausteinen werden h√§ufig die folgenden Pakete und K√ºrzel genutzt:\n\n\n\nModul\nK√ºrzel\nBefehl\n\n\n\n\nNumPy\nnp\nimport numpy as np\n\n\nPandas\npd\nimport pandas as pd\n\n\nmatplotlib.pyplot\nplt\nimport matplotlib.pyplot as plt\n\n\n\n¬† (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  }
]