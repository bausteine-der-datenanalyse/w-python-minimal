[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine Computergest√ºtzter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Bausteine werden die Grundz√ºge der Programmierung mit Python vermittelt. In diesem Baustein lernen Sie ‚Ä¶\n\nGrundlagen des Programmierens\nAusgaben in Python, Grundlegende Datentypen, FLusskontrolle\ndie Dokumentation zu lesen und zu verwenden\nModule und Pakete laden",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "skript/einleitung.html",
    "href": "skript/einleitung.html",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "2 Willkommen bei Python!\nPython ist eine moderne Programmiersprache, die sich besonders gut f√ºr Einsteigerinnen und Einsteiger eignet. Sie ist leicht verst√§ndlich und wird in vielen Bereichen eingesetzt ‚Äì von der Datenanalyse bis hin zur Webentwicklung.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#lernziele-dieses-kapitels",
    "href": "skript/einleitung.html#lernziele-dieses-kapitels",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "2.1 Lernziele dieses Kapitels",
    "text": "2.1 Lernziele dieses Kapitels\nAm Ende dieses Kapitels k√∂nnen Sie: - einfache Python-Programme schreiben, - Text auf dem Bildschirm ausgeben, - erste Variablen definieren und verwenden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#ihr-erstes-programm",
    "href": "skript/einleitung.html#ihr-erstes-programm",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "2.2 Ihr erstes Programm",
    "text": "2.2 Ihr erstes Programm\nDie ersten Schritte in einer neuen Programmiersprache sind immer die gleichen. WIr lassen uns die Worte ‚ÄòHello World‚Äô ausgeben. Dazu nutzen wir den print-Befehl print(...):\n\nprint(\"Hallo Welt!\")\n\nHallo Welt!\n\n\nWas passiert hier? - print(...) ist eine sogenannte Funktion, die etwas auf dem Bildschirm ausgibt. - Der Text \"Hello World!\" wird angezeigt. - Texte (auch ‚ÄûStrings‚Äú genannt) stehen immer in Anf√ºhrungszeichen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#variablen-namen-f√ºr-werte",
    "href": "skript/einleitung.html#variablen-namen-f√ºr-werte",
    "title": "1¬† Einleitung: Datenanalyse mit Python",
    "section": "2.3 Variablen ‚Äì Namen f√ºr Werte",
    "text": "2.3 Variablen ‚Äì Namen f√ºr Werte\nVariablen sind wie beschriftete Schubladen: Sie speichern Informationen unter einem Namen.\n\nname = \"Frau M√ºller\"\nalter = 32\n\nSie k√∂nnen diese Variablen verwenden, um dynamische Ausgaben zu erzeugen:\n\nprint(name + \" ist \" + str(alter) + \" Jahre alt.\")\n\nFrau M√ºller ist 32 Jahre alt.\n\n\nZu beachten ist hier, dass sie versuchen sowohl eine Zahl, als auch Text auszugeben. Daher m√ºssen wir mit der Funktion ‚Äòstr()‚Äô die Zahl in Text umwandeln.\n\n\n\n\n\n\n‚úèÔ∏è Aufgabe: Begr√º√üung mit Alter\n\n\n\n\n\nSchreiben Sie ein Programm, das Sie mit Ihrem Namen begr√º√üt:\nHallo Frau M√ºller!\nTipp: In Python k√∂nnen Sie Texte mit + zusammenf√ºgen. Denken Sie daran, dass Strings in Anf√ºhrungszeichen stehen m√ºssen.\n\n\n\n\n\n\nL√∂sung\n\n\n\n\n\n\nmein_name = \"Ihr Name hier\"\nprint(\"Hallo \" + mein_name + \"!\")\n\nHallo Ihr Name hier!\n\n\n\n\n\nErweitern Sie Ihr Programm so, dass es eine Begr√º√üung inklusive Alter ausgibt:\nHallo Frau M√ºller!\nSie sind 32 Jahre alt.\nTipp: Verwenden Sie print(...) mehrmals oder f√ºgen Sie Texte zusammen.\n\n\n\n\n\n\nL√∂sung\n\n\n\n\n\n\nname = \"Frau M√ºller\"\nalter = 32\n\nprint(\"Hallo \" + name + \"!\")\nprint(\"Sie sind \" + str(alter) + \" Jahre alt.\")\n\nHallo Frau M√ºller!\nSie sind 32 Jahre alt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html",
    "href": "skript/datentypen.html",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "",
    "text": "2.1 Lernziele dieses Kapitels\nAm Ende dieses Kapitels k√∂nnen Sie: - die wichtigsten Datentypen unterscheiden, - mit Zahlen und Texten rechnen bzw. arbeiten, - einfache Berechnungen und Ausgaben erstellen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#einleitung",
    "href": "skript/datentypen.html#einleitung",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "2.2 Einleitung",
    "text": "2.2 Einleitung\nIn Python gibt es verschiedene Datentypen. Diese beschreiben, welche Art von Daten Sie in Variablen speichern. Das ist wichtig, weil viele Operationen ‚Äì wie zum Beispiel + ‚Äì je nach Datentyp etwas anderes bedeuten:\n\n+ bei Zahlen bedeutet Addition,\n+ bei Text bedeutet Zusammenf√ºgen (Konkatenation).\n\nBevor wir also mit komplexeren Programmen arbeiten, sollten wir verstehen, welche Datentypen es gibt und wie man mit ihnen umgeht.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#die-wichtigsten-datentypen",
    "href": "skript/datentypen.html#die-wichtigsten-datentypen",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "2.3 Die wichtigsten Datentypen",
    "text": "2.3 Die wichtigsten Datentypen\nHier sind die grundlegenden Datentypen in Python:\n\n\n\nTyp\nBeispiel\nBedeutung\n\n\n\n\nint\n10\nGanze Zahl\n\n\nfloat\n3.14\nKommazahl\n\n\nstr\n\"Hallo\"\nText (String)\n\n\nbool\nTrue, False\nWahrheitswert (Ja/Nein)\n\n\n\nSie k√∂nnen den Typ einer Variable mit der Funktion type(...) herausfinden:\n\nwert = 42\nprint(type(wert))  # Ausgabe: &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#unterschiede-zwischen-int-und-float",
    "href": "skript/datentypen.html#unterschiede-zwischen-int-und-float",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "2.4 üîç Unterschiede zwischen int und float",
    "text": "2.4 üîç Unterschiede zwischen int und float\nIn Python unterscheidet man zwischen ganzen Zahlen (int) und Kommazahlen (float):\n\nint steht f√ºr ‚Äûinteger‚Äú ‚Äì also ganze Zahlen wie 1, 0, -10\nfloat steht f√ºr ‚Äûfloating point number‚Äú ‚Äì also Zahlen mit Dezimalstellen wie 3.14, 0.5, -2.0\n\n\na = 10       # int\nb = 2.5      # float\n\nprint(\"a:\", a, \"| Typ:\", type(a))\nprint(\"b:\", b, \"| Typ:\", type(b))\n\na: 10 | Typ: &lt;class 'int'&gt;\nb: 2.5 | Typ: &lt;class 'float'&gt;\n\n\nüí° Die Unterscheidung ist wichtig: Manche Rechenoperationen verhalten sich je nach Datentyp leicht unterschiedlich.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#was-sind-booleans-bool",
    "href": "skript/datentypen.html#was-sind-booleans-bool",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "2.5 üîç Was sind Booleans (bool)?",
    "text": "2.5 üîç Was sind Booleans (bool)?\nEin Boolean ist ein Wahrheitswert: Er kann nur zwei Zust√§nde annehmen:\n\nTrue (wahr)\nFalse (falsch)\n\nSolche Werte begegnen uns zum Beispiel bei Fragen wie:\n\nIst die Temperatur √ºber 30‚ÄØ¬∞C?\nHat die Datei einen bestimmten Namen?\nIst die Liste leer?\n\n\nist_sonnig = True\nhat_regenschirm = False\n\nprint(\"Sonnig:\", ist_sonnig)\nprint(\"Regenschirm dabei?\", hat_regenschirm)\nprint(\"Typ von 'ist_sonnig':\", type(ist_sonnig))\n\nSonnig: True\nRegenschirm dabei? False\nTyp von 'ist_sonnig': &lt;class 'bool'&gt;\n\n\nBooleans werden besonders in Bedingungen und Vergleichen verwendet, was Sie in Kapitel 4 genauer kennenlernen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#rechnen-mit-zahlen",
    "href": "skript/datentypen.html#rechnen-mit-zahlen",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "2.6 Rechnen mit Zahlen",
    "text": "2.6 Rechnen mit Zahlen\nPython kann wie ein Taschenrechner verwendet werden:\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\n\na = 10\nb = 3\n\nprint(\"Addition:\", a + b)\nprint(\"Subtraktion:\", a - b)\nprint(\"Multiplikation:\", a * b)\nprint(\"Potenzieren\", a**b)\nprint(\"Division:\", a / b)\nprint(\"Ganzzahlige Division:\", a // b)\nprint(\"Division mit Rest:\", a % b)\n\nAddition: 13\nSubtraktion: 7\nMultiplikation: 30\nPotenzieren 1000\nDivision: 3.3333333333333335\nGanzzahlige Division: 3\nDivision mit Rest: 1\n\n\nüí° // bedeutet: Ganzzahldivision, das Ergebnis wird abgerundet. Alternativ gibt es auch %. Hier wird eine Ganzzahldivision durchgef√ºhrt und der Rest ausgegeben.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#arbeiten-mit-text",
    "href": "skript/datentypen.html#arbeiten-mit-text",
    "title": "2¬† Einf√ºhrung: Datentypen verstehen",
    "section": "2.7 Arbeiten mit Text",
    "text": "2.7 Arbeiten mit Text\nTexte (Strings) k√∂nnen miteinander kombiniert werden:\n\nvorname = \"Anna\"\nnachname = \"Beispiel\"\nprint(\"Willkommen, \" + vorname + \" \" + nachname + \"!\")\n\nWillkommen, Anna Beispiel!\n\n\nWenn Sie Text und Zahlen kombinieren wollen, m√ºssen Sie die Zahl in einen String umwandeln:\n\npunkte = 95\nprint(\"Sie haben \" + str(punkte) + \" Punkte erreicht.\")\n\nSie haben 95 Punkte erreicht.\n\n\n\n\n\n\n\n\n\n‚úèÔ∏è Aufgabe: Alter in Tagen\n\n\n\n\n\nBerechnen Sie, wie alt eine Person in Tagen ist.\n\nalter_jahre = 32\ntage = alter_jahre * 365\nprint(\"Sie sind ungef√§hr \" + str(tage) + \" Tage alt.\")\n\nSie sind ungef√§hr 11680 Tage alt.\n\n\nTipp: Denken Sie an die Umwandlung in einen String, wenn Sie die Zahl ausgeben m√∂chten.\n\n\n\n\n\n\nL√∂sung\n\n\n\n\n\n\nalter = 32\ntage = alter * 365\nprint(\"Sie sind ungef√§hr \" + str(tage) + \" Tage alt.\")\n\nSie sind ungef√§hr 11680 Tage alt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Einf√ºhrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html",
    "href": "skript/funktionen.html",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "",
    "text": "3.1 Funktionen und Methoden\nIn Python gibt es zwei Arten von Funktionen: Funktionen und Methoden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html#funktionen-und-methoden",
    "href": "skript/funktionen.html#funktionen-und-methoden",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "",
    "text": "Funktionen\nFunktionen k√∂nnen Objekte unabh√§ngig von ihrem Datentyp √ºbergeben werden. Funktionen werden √ºber ihren Funktionsnamen gefolgt von runden Klammern () aufgerufen. Ein Beispiel ist die Funktion print():\n\nvar_str = 'ABC'\nvar_int = 26\nvar_bool = True\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_str))\nprint(\"Die Variable var_2 hat den Typ\", type(var_int))\nprint(\"Die Variable var_3 hat den Typ\", type(var_bool))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nFunktionen m√ºssen immer einen Wert zur√ºckgeben. Wenn Funktionen keinen Wert zur√ºckgeben k√∂nnen oder sollen, wird der Wert None zur√ºckgegeben, der nicht existente Werte kennzeichnet.\n\nres = print( 15 )\nprint(res)\n\n15\nNone\n\n\nFunktionen k√∂nnen verschachtelt und so von innen nach au√üen nacheinander ausgef√ºhrt werden. In diesem Code-Beispiel wird zun√§chst die Summe zweier Zahlen und anschlie√üend der Wahrheitswert des Ergebnisses gebildet. Dieser wird anschlie√üend mit der Funktion print ausgegeben.\n\nprint(bool(sum([1, 2])))\n\nTrue\n\n\n\n\nMethoden\nMethoden sind eine Besonderheit objektorientierter Programmiersprachen. Im vorherigen Kapitel wurde erl√§utert, dass in Python Objekte zu einem bestimmten Typ bzw. zu einer Klasse geh√∂ren und abh√§ngig von den in ihnen gespeicherten Werte einen passenden Datentyp erhalten. Methoden sind Funktionen, die zu einer bestimmten Klasse geh√∂ren und nur f√ºr Objekte dieser Klasse verf√ºgbar sind. Methoden k√∂nnen auch f√ºr mehrere Klassen definiert sein. Methoden werden getrennt durch einen Punkt . hinter Objekten mit ihrem Namen aufgerufen: variable.methode bzw. (wert).methode. Beispielsweise sind .upper(), .lower() und .title f√ºr Zeichenfolgen definierte Methoden.\n\ntoller_text = \"Python 3.12 ist gro√üartig.\"\n\nprint(toller_text.upper())\nprint(toller_text.lower())\nprint(toller_text.title(), \"\\n\")\n\nprint((\"Mit in Klammern gesetzten Werten klappt es auch.\").upper())\n\nPYTHON 3.12 IST GROSSARTIG.\npython 3.12 ist gro√üartig.\nPython 3.12 Ist Gro√üartig. \n\nMIT IN KLAMMERN GESETZTEN WERTEN KLAPPT ES AUCH.\n\n\nF√ºr Objekte mit einem unpassenden Datentyp sind Methoden wie .lower() nicht verf√ºgbar.\n\nprint((1).upper())\n\n\n\n'int' object has no attribute 'upper'\n\n\nMethoden k√∂nnen verkettet und so nacheinander ausgef√ºhrt werden. In diesem Beispiel wird die Zeichenfolge ‚ÄòKatze‚Äô klein geschrieben, dann die H√§ufigkeit des Buchstabens ‚Äòk‚Äô gez√§hlt.\n\nprint('Katze'.lower().count('k'))\n\n1\n\n\nWelche Methoden f√ºr ein Objekt verf√ºgbar sind, kann mit der Funktion dir(objekt) bestimmt werden. Die Ausgabe der Funktion ist aber h√§ufig sehr umfangreich. Um die relevanten Eintr√§ge auszuw√§hlen, muss die Ausgabe gefiltert werden. Notwendig ist das aber nicht - Interessierte schauen in Beispiel¬†3.1.\n\n\n\n\n\n\nBeispiel¬†3.1: Methoden eines Objekts bestimmen\n\n\n\n\n\nMit der Funktion dir(objekt) k√∂nnen die verf√ºgbaren Methoden eines Objekts ausgegeben werden. Dabei werden jedoch auch die Attribute und die Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel f√ºr die Ganzzahl 1:\n\nprint(dir(1))\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n\n\nUm die Ausgabe auf Methoden einzugrenzen, kann folgende Funktion in Listenschreibweise verwendet werden:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if callable (getattr(objekt, attr))]\nprint(attribute)\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'from_bytes', 'to_bytes']\n\n\nMit doppelten Unterstrichen umschlossene Methoden sind f√ºr die Klasse definierte Methoden. Folgende Funktion entfernt Methoden mit doppelten Unterstrichen aus der Ausgabe:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(attribute)\n\n['as_integer_ratio', 'bit_length', 'conjugate', 'from_bytes', 'to_bytes']\n\n\nIm Fall einer Ganzzahl k√∂nnen Methoden (zur Abgrenzung von Gleitkommazahlen in umschlie√üenden Klammern) wie folgt aufgerufen werden:\n\n(1).as_integer_ratio()\n\n(1, 1)\n\n\nDie Methoden des Objekts ‚Äòtoller_text‚Äô:\n\nobjekt = toller_text\n\nattribute = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(attribute)\n\n['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html#parameter",
    "href": "skript/funktionen.html#parameter",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.2 Parameter",
    "text": "3.2 Parameter\nVielen Funktionen und Methoden k√∂nnen getrennt durch Kommata mehrere Parameter √ºbergeben werden. Die Werte, die als Parameter √ºbergeben werden, werden Argumente genannt (Python-Dokumentation). Parameter steuern die Programmausf√ºhrung. Die f√ºr die Funktion print() verf√ºgbaren Parameter stehen in der Dokumentation der Funktion:\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n*objects, sep, end, file und flush sind die Parameter der Funktion print().\n\nParameter ohne Gleichheitszeichen = m√ºssen beim Funktions- bzw. Methodenaufruf √ºbergeben werden. Parameter mit Gleichheitszeichen = k√∂nnen beim Aufruf √ºbergeben werden, es handelt sich um optionale Parameter.\nDie Werte hinter dem Gleichheitszeichen zeigen die Standardwerte (default value) der Parameter an. Diese werden verwendet, wenn ein Argument nicht explizit beim Aufruf √ºbergeben wird.\n\n\n\n\n\n\n\nTipp¬†3.2: Ausnahmen bei Standardwerten\n\n\n\n\n\nBei den in der Funktionsdefinition genannten Werten handelt es sich nicht immer um die tats√§chlichen Standardwerte. Es empfiehlt sich deshalb, wenn eine Funktion verwendet wird, die Beschreibung der Parameter zu lesen.\nEinige Funktionen verwenden das Schl√ºsselwort None zur Kennzeichnung des Standardwerts. Der Wert None dient dabei als Platzhalter. Ein Beispiel ist die NumPy-Funktion numpy.loadtxt().\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, /\n              skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, /\n              *, quotechar=None, like=None)\n\nF√ºr den Parameter delimiter ist als Standardwert das Schl√ºsselwort None eingetragen. Wie der Funktionsbeschreibung zu entnehmen ist, ist der Standartwert tats√§chlich das Leerzeichen: ‚ÄúThe default is whitespace.‚Äù\nAuch der Parameter usecols hat den Standarwert None: ‚ÄúThe default, None, results in all columns being read.‚Äù\n\nEin weiteres Beispiel ist die Funktion pandas.read_csv(). Einige Argumente haben den Standardwert &lt;no_default&gt;. (Im Folgenden werden nur ausgew√§hlte Parameter gezeigt).\npandas.read_csv(sep=&lt;no_default&gt;, verbose=&lt;no_default&gt;)\nAus der Beschreibung k√∂nnen die tats√§chlichen Standardwerte abgelesen werden:\nsep : str, default ‚Äò,‚Äô\nverbose : bool, default False\n\n\n\n\nArgumente k√∂nnen in Python entweder als positionales Argument √ºbergeben werden Das hei√üt, Python erwartet Argumente in einer feststehenden Reihenfolge entsprechend der Parameter der Funktionsdefinition. Alternativ k√∂nnen Argumente als Schl√ºsselwort √ºbergeben werden, die Zuordnung von Eingaben erfolgt √ºber den Namen des Parameters. Standardm√§√üig k√∂nnen Argumente positional oder per Schl√ºsselwort √ºbergeben werden. Abweichungen davon werden durch die Symbole * und / gekennzeichnet (siehe folgenden Tipp).\n\n\n\n\n\n\n\nTipp¬†3.3: Positionale und Schl√ºsselwortargumente, *args und **kwargs\n\n\n\n\n\nDie Symbole * und / zeigen an, welche Parameter positional und welche per Schl√ºsselwort √ºbergeben werden k√∂nnen bzw. m√ºssen.\n\n\n\n\n\n\n\n\n\nLinke Seite\nTrennzeichen\nRechte Seite\n\n\n\n\nnur positionale Argumente\n/\npositionale oder Schl√ºsselwortargumente\n\n\npositionale oder Schl√ºsselwortargumente\n*\nnur Schl√ºsselwortargumente\n\n\n\n(https://realpython.com/python-asterisk-and-slash-special-parameters/)\n\n¬†\nEin Beispiel f√ºr das Trennzeichen * ist die Funktion glob aus dem gleichnamigen Modul. Der Parameter pathname kann positional (an erster Stelle) oder als Schl√ºsselwort √ºbergeben werden. Die √ºbrigen Parameter m√ºssen als Schl√ºsselwortargumente √ºbergeben werden.\nglob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)\nBeide Steuerzeichen k√∂nnen innerhalb einer Funktionsdefinition vorkommen, allerdings nur in der Reihenfolge / und *. Im umgekehrten Fall w√§re es unm√∂glich, Argumente zu √ºbergeben. Ein Beispiel ist die Funktion sorted. Der erste Parameter muss positional √ºbergeben werden, die Parameter key und reverse m√ºssen als Schl√ºsselworte √ºbergeben werden.\nsorted(iterable, /, *, key=None, reverse=False)¬∂\n\n\n\n\n\n\nAusnahmen\n\n\n\nEinige Funktionen weichen von der Systematik ab, beispielsweise die Funktionen min() und max(). Diese sind (u. a.) in der Form definiert:\nmin(iterable, *, key=None)\nmax(iterable, *, key=None)\nBeide Funktionen akzeptieren den Parameter iterable aber nicht als Schl√ºsselwort.\n\n\nVielen Funktionen k√∂nnen beliebig viele Argumente positional oder als Schl√ºsselwort √ºbergeben werden. Im Allgemeinen wird dies durch die Schl√ºsselw√∂rter *args (positionale Argumente) und **kwargs (key word arguments, Schl√ºsselwortargumente) angezeigt. Der Unterschied wird durch das eine bzw. die beiden Sternchen markiert, die Schl√ºsselw√∂rter selbst sind austauschbar (wie bei der Funktion print(*objects)). Das Schl√ºsselwort *args entspricht zugleich dem Symbol * in der Funktionsdefinition, d.¬†h. rechts davon d√ºrfen nur Schl√ºsselwortargumente stehen. Weitere Informationen dazu finden Sie hier.\n\n\n\nIn der Funktionsdefinition von print() ist *objects also ein positionaler Parameter (dieser steht immer an erster Stelle), der keinen Standardwert hat und dem beliebig viele Argumente √ºbergeben werden k√∂nnen (n Eingaben stehen an den ersten n-Stellen). Die weiteren Parameter der Funktion print() sind optional und m√ºssen als Schl√ºsselwort √ºbergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html#aufgaben-funktionen",
    "href": "skript/funktionen.html#aufgaben-funktionen",
    "title": "3¬† Funktionen: Grundlagen",
    "section": "3.3 Aufgaben Funktionen",
    "text": "3.3 Aufgaben Funktionen\n\nRichtig oder falsch: Methoden stehen abh√§ngig vom Datentyp eines Werts oder eines Objekts zur Verf√ºgung.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n\n1_x_2_x_3\n\n\n\nSchlagen Sie in der Dokumentation die Funktion bool() nach.\n\n\nWelche Parameter nimmt die Funktion entgegen und welche davon sind optional?\nWelche Argumente werden positional und welche als Schl√ºssel√ºbergeben? Ist die Art der √úbergabe w√§hlbar oder festgelegt?\n\n\n\n\n\n\n\nL√∂sungen\n\n\n\n\n\nAufgabe 1: richtig\nAufgabe 2\n\nprint(1, 2, 3, sep = \"_x_\")\n\nAufgabe 3: Die Funktion bool() hat ein optionales Argument object mit dem Standardwert False. Das Argument muss positional √ºbergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html",
    "href": "skript/flusskontrolle.html",
    "title": "4¬† Flusskontrolle",
    "section": "",
    "text": "Abzweigungen\nAbzweigungen erm√∂glichen eine Fallunterscheidung, bei der abh√§ngig von einer oder mehreren Bedingungen verschiedene Teile des Skripts ausgef√ºhrt werden.\nIn Python werden Abzweigungen mit dem Schl√ºsselwort if eingeleitet. Dieses wird von der Abzweigbedingung gefolgt und mit einem Doppelpunkt : abgeschlossen. Falls die Abzweigbedingung wahr ist, wird der einger√ºckte Anweisungsblock ausgef√ºhrt.\n# Beispiel: Zahl kleiner als ein Schwellwert\n\na = 7\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\n\nDie Zahl 7 ist kleiner als 10.\nEs ist auch m√∂glich einen alternativen Anweisungsblock zu definieren, welcher ausgef√ºhrt wird, wenn die Bedingung falsch ist. Dieser wird mit dem else Schl√ºsselwort umgesetzt.\n# Beispiel: Zahl kleiner als ein Schwellwert mit alternativer Ausgabe\n\na = 13\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\nelse:\n    print( 'Die Zahl', a, 'ist nicht kleiner als 10.')\n\nDie Zahl 13 ist nicht kleiner als 10.\nEs k√∂nnen auch mehrere Bedingungen √ºbergeben werden.\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20\n\na = 1\nif a &lt; 20 and a &gt; 10:\n    print( 'Die Zahl', a, 'liegt zwischen 10 und 20.')\nelse:\n    print( 'Die Zahl', a, 'liegt nicht zwischen 10 und 20.')\n\nDie Zahl 1 liegt nicht zwischen 10 und 20.\nSchlie√ülich k√∂nnen mehrere alternative Bedingungen gepr√ºft werden. Dies ist zum einen durch das Verschachteln von Abzweigungen m√∂glich.\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit verschachtelten Abzweigungen\n\na = 12\nif a &gt; 10:\n    print( 'Die Zahl', a, 'ist gr√∂√üer als 10.' )\n    \n    if a &lt; 20:\n        print( 'Die Zahl', a, 'ist kleiner als 20.' )\n        print( 'Damit liegt die Zahl zwischen 10 und 20.')\n    else:\n        print( 'Die Zahl', a, 'ist gr√∂√üer als 20 und liegt nicht im gesuchten Wertebereich.' )\nelse:\n        print( 'Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\n\nDie Zahl 12 ist gr√∂√üer als 10.\nDie Zahl 12 ist kleiner als 20.\nDamit liegt die Zahl zwischen 10 und 20.\nZum anderen ist dies mit dem Schl√ºsselwort elif m√∂glich.\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit elif\n\na = 112\nif a &lt; 20 and a &gt; 10:\n  print('Die Zahl', a, 'liegt zwischen 10 und 20.')\nelif a &lt; 10:\n  print('Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\nelif a &gt; 20 and a &lt;= 100:\n  print('Die Zahl', a, 'ist gr√∂√üer als 20, aber nicht gr√∂√üer als 100.')\nelif a &gt; 20 and a &lt;= 1000:\n  print('Die Zahl', a, 'ist gr√∂√üer als 20, aber nicht gr√∂√üer als 1000.')\nelse:\n  print('Die Zahl', a, 'liegt nicht zwischen 10 und 20 und ist gr√∂√üer als 1000.')\n\nDie Zahl 112 ist gr√∂√üer als 20, aber nicht gr√∂√üer als 1000.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flusskontrolle</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html#aufgaben-flusskontrolle",
    "href": "skript/flusskontrolle.html#aufgaben-flusskontrolle",
    "title": "4¬† Flusskontrolle",
    "section": "4.1 Aufgaben Flusskontrolle",
    "text": "4.1 Aufgaben Flusskontrolle\n\nSchreiben Sie ein Programm, dass von 1 bis 25 und von 38 bis 50 z√§hlt und jeden Wert, der ganzzahlig durch 7 teilbar ist, mit print() ausgibt.\nRoulette: Schreiben Sie ein Programm, dass f√ºr eine Zahl pr√ºft, ob diese im Wertebereich des Spieltischs liegt. Falls nein, soll eine Fehlermeldung ausgegeben werden. Falls ja, soll das Programm ausgeben, ob die Zahl\n\n\ngerade oder ungerade ist,\nrot oder schwarz ist,\nniedrig (1-18) oder hoch (19-36) ist und\nim 1., 2. oder 3. Dutzend liegt.\n\n\n\n\n\nRoulette Tableau\n\n\nEuropean roulette von Betzaar.com ist lizensiert unter CC 3.0 BY-SA und verf√ºgbar auf wikimedia.org. 2010\n\n¬†\nDie Musterl√∂sung kann Marc machen.\n\n\n\n\n\n\nMusterl√∂sung Aufgaben Flusskontrolle\n\n\n\n\n\n\n\n\n\n¬†\n(Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Schleifen und Abzweigungen.‚Äú Fachhochschule Dortmund.\n\n\nMatthes, Eric. 2017. Python Crashkurs: Eine praktische, projektbasierte Programmiereinf√ºhrung. 1. Aufl. Heidelberg: dpunkt.verlag.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Flusskontrolle</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html",
    "href": "skript/sammeltypen.html",
    "title": "5¬† Sammeltypen",
    "section": "",
    "text": "5.1 Listen\nWie alle Typen in Python werden Listen durch Zuweisung erstellt. Bei der Definition einer Liste werden die Elemente durch eckige Klammern [] eingeklammert und mit Kommata , getrennt. Listen k√∂nnen mit dem +-Operator verkettet werden. * verkettet eine Liste n-mal.\ntext_variable = 'abc'\n\nliste1 = [1, 'xy', True, text_variable]\nprint(liste1)\n\n# Listen k√∂nnen auch Listen enthalten\nliste2 = [None, liste1]\nprint(liste2)\n\n# Listen k√∂nnen mit + und * verkettet werden\nprint(liste1 + liste2)\nprint(liste1 * 2)\n\n[1, 'xy', True, 'abc']\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', 1, 'xy', True, 'abc']\nEine leere Liste kann durch Zuweisung von [] erstellt werden.\nleere_liste = []\nprint(leere_liste)\n\n[]",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#listen",
    "href": "skript/sammeltypen.html#listen",
    "title": "5¬† Sammeltypen",
    "section": "",
    "text": "Slicing: der Zugriffsoperator []\nDer Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere Sammeltypen) erfolgt √ºber den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator hei√üt deshalb auch Slice Operator.\n\nZugriff auf einzelne Elemente\nElemente werden √ºber ihren Index, bei 0 beginnend, angesprochen.\n\nprint(liste1)\nprint(liste1[0])\nprint(liste1[3])\n\n[1, 'xy', True, 'abc']\n1\nabc\n\n\nAuf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste liste2 enth√§lt an Indexposition 1 eine Liste mit 4 Elementen.\n\nprint(liste2)\nprint(liste2[1])\nprint(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])\n\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc']\n1 xy True abc\n\n\nMit negativen Indizes k√∂nnen Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.\n\nprint(liste1)\nprint(liste1[-1], liste1[-3])\n\n[1, 'xy', True, 'abc']\nabc xy\n\n\n\n\nZugriff auf mehrere Elemente\nIndexbereiche k√∂nnen in der Form [start:stop:step] angesprochen werden. start ist das erste adressierte Element, stop das erste nicht mehr adressierte Element und step die Schrittweite.\n\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[start:stop]\nElemente von start bis stop - 1\n\n\nliste[:]\nAlle Elemente der Liste\n\n\nliste[start:]\nElemente von start bis zum Ende der Liste\n\n\nliste[:stop]\nElemente vom Anfang der Liste bis stop - 1\n\n\nliste[::3]\nAuswahl jedes dritten Elements\n\n\n\n¬†\nNegative Werte f√ºr start, stop oder step bewirken eine R√ºckw√§rtsauswahl von Elementen.\n\n\n\n\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[-1]\ndas letzte Element der Liste\n\n\nliste[-2:]\ndie letzten beiden Elemente der Liste\n\n\nliste[:-2]\nalle bis auf die beiden letzten Elemente\n\n\nliste[::-1]\nalle Elemente in umgekehrter Reihenfolge\n\n\nliste[1::-1]\ndie ersten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[:-3:-1]\ndie letzten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[-3::-1]\nalle au√üer die letzten beiden Elemente in umgekehrter Reihenfolge\n\n\n\n¬†\n(Beispiele von Greg Hewgill unter der Lizenz CC BY-SA 4.0 verf√ºgbar auf stackoverflow. 2009)\n\n\n\nZeichenfolgen\nAuch aus Zeichenfolgen k√∂nnen mit dem Slice Operator Ausschnitte ausgew√§hlt werden.\n\nprint('Ich bin ein string'[::2])\nprint('Hallo Welt'[0:6])\nprint('abc'[::-1])\n\nIhbnensrn\nHallo \ncba\n\n\n\n\n\nListenmethoden\nF√ºr den Listentyp sind verschiedene Methoden definiert.\n\nElemente bestimmen\n\nlist.index(x, start, stop) gibt die Indexposition des ersten Elements x aus. Die optionalen Argumente start und stop erlauben es, den Suchbereich einzuschr√§nken.\nlist.count(x) gibt die H√§ufigkeit von x in der Liste aus.\nlist.reverse() kehrt die Reihenfolge der Listenelemente um (die Liste wird dadurch ver√§ndert!).\nlist.sort(reverse = False) sortiert die Liste, mit dem optionalen Argument reverse = True absteigend (die Liste wird dadurch ver√§ndert!). Die Datentypen innerhalb der Liste m√ºssen sortierbar sein (d.¬†h. alle Elemente sind numerisch oder Zeichen).\n\n\nprint(liste1)\n\nliste1.reverse()\nprint(liste1)\n\n# True wird als 1 gez√§hlt\nprint(\"True wird als 1 gez√§hlt:\", liste1.index(1), liste1.count(1))\n\n[1, 'xy', True, 'abc']\n['abc', True, 'xy', 1]\nTrue wird als 1 gez√§hlt: 1 2\n\n\n\n\nElemente einf√ºgen\n\nlist.append(x) h√§ngt ein einzelnes Element an das Ende der Liste an.\nlist.extend(sammeltyp) h√§ngt alle mit sammeltyp √ºbergebenen Elemente an das Ende der Liste an. Der Sammeltyp kann eine Liste, ein Tupel, eine Menge oder ein Dictionary sein.\nlist.insert(i, x) f√ºgt an der Position i Element x ein.\n\n\nprint(liste1, \"\\n\")\n\nliste1.append('Hallo')\nliste1.extend(['Hallo', 'Welt!'])\nliste1.insert(2, '12345')\n\nprint(liste1)\n\n['abc', True, 'xy', 1] \n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Hallo', 'Welt!']\n\n\n\n\nElemente entfernen\n\nlist.remove(x) entfernt das erste Element x in der Liste und gibt einen ValueError zur√ºck, wenn x nicht in der Liste enthalten ist.\nliste.pop(i) entfernt das Element an der Indexposition i. Wird kein Index angegeben, wird das letzte Element entfernt. Die Methode liste.pop(i) gibt die entfernten Elemente zur√ºck.\nliste.clear() entfernt alle Elemente einer Liste.\n\n\nliste1.remove('Hallo')\nprint(liste1)\n\nliste1.pop(2)\n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Welt!']\n\n\n'12345'\n\n\n\n\nListen und Listenelemente kopieren\nIn Python enthalten Listen Daten nicht direkt, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. Wird eine Liste durch Zuweisung einer anderen Liste angelegt, dann werden nicht die Elemente der Liste kopiert, sondern beide Listen greifen dann auf den selben Speicherort zu.\n\n# Kopieren durch Zuweisung\nliste1 = [1, 'xy', True, text_variable]\nprint(\"liste1:\", liste1, \"\\n\")\nliste2 = liste1\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"Auch liste1 hat sich durch die Zuweisung in liste2 ver√§ndert:\", liste1, \"\\n\")\n\nliste1: [1, 'xy', True, 'abc'] \n\nAuch liste1 hat sich durch die Zuweisung in liste2 ver√§ndert: ['ABC', 'xy', True, 'abc'] \n\n\n\nUm eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen, kann die Methode liste.copy() verwendet werden. Auch durch die Verwendung des Zugriffsoperators [:] wird eine neue Liste im Speicher angelegt.\n\n# Verwendung der Methode liste.copy()\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1.copy()\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1, \"\\n\")\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[:]\n\n## √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1)\n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc']\n\n\nDie Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[0:2]\n\n# √Ñndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unver√§ndert:\", liste1)\n\nliste1 bleibt durch die Zuweisung in liste2 unver√§ndert: [1, 'xy', True, 'abc']\n\n\nUm zu √ºberpr√ºfen, ob sich zwei Objekte den Speicherbereich teilen, kann die Objekt-ID mit der Funktion id() verglichen oder die Operatoren is bzw. is not verwendet werden, die die Funktion id() aufrufen.\n\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1\n\nprint(\"ID liste1:\", id(liste1))\nprint(\"ID liste2:\", id(liste2))\nprint(\"ID liste1 gleich ID list2:\", liste1 is liste2)\n\nID liste1: 4355438848\nID liste2: 4355438848\nID liste1 gleich ID list2: True\n\n\n\n\n\n\n\n\nIdentit√§t vs.¬†Wertgleichheit\n\n\n\n\n\nDer Operator is pr√ºft die Identit√§t zweier Objekte und unterscheidet sich dadurch vom logischen Operator ==, der auf Wertgleichheit pr√ºft. Da liste1 und liste2 die gleichen Elemente enthalten, liegen sowohl Identit√§t und Wertgleichheit vor. Der Unterschied von Identit√§t und Wertgleichheit kann anhand eines Werts verdeutlicht werden (Im Code-Beispiel wird eine Syntax-Warnung unterdr√ºckt.).\n\n# Wertgleichheit\nprint(1 == 1.0)\nprint(liste1 == liste2, \"\\n\")\n\n# Identit√§t\nprint(1 is 1.0)\nprint(liste1 is liste2)\n\nTrue\nTrue \n\nFalse\nTrue\n\n\n\n\n\n\n\n\nAufgaben Listen\n\nErstellen Sie eine Liste ‚Äòwochentage‚Äô, die die sieben Tage der Woche enth√§lt. Verwenden Sie den Slice-Operator, um eine neue Liste ‚Äòwochenende‚Äô mit den Tagen des Wochenendes zu erstellen. Entfernen Sie die Tage des Wochenendes aus der Liste ‚Äòwochentage‚Äô.\n4-Tage-Woche: Verwenden Sie Listenmethoden, um den Freitag aus der Liste ‚Äòwochentage‚Äô zu entfernen und der Liste ‚Äòwochenende‚Äô vor dem Samstag hinzuzuf√ºgen.\nBestimmen Sie in der Liste zahlen = [34, 12, 0, 67, 23] die Position des Werts 0. Entfernen Sie den Wert aus der Liste und geben Sie die Liste aufsteigend sortiert aus.\nGeben Sie nun mit Hilfe des Zugriffsoperators [] die Indexpositionen 1 und 3 der sortierten Liste ‚Äòzahlen‚Äô aus.\n\nMusterl√∂sung kann Marc machen.\n\n\n\n\n\n\nTipp¬†5.1: Musterl√∂sung",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#tupel",
    "href": "skript/sammeltypen.html#tupel",
    "title": "5¬† Sammeltypen",
    "section": "5.2 Tupel",
    "text": "5.2 Tupel\nTupel sind Listen sehr √§hnlich, jedoch sind Tupel unver√§nderbare Datenobjekte. Das hei√üt, die Elemente eines angelegten Tupels k√∂nnen weder ge√§ndert, noch entfernt werden. Auch k√∂nnen keine neuen Elemente zum Tupel hinzugef√ºgt werden.\nTupel werdem mit runden Klammern () erzeugt, die Elemente werden mit einem Komma , getrennt. Ein Tupel mit einem Wert wird mit einem Komma in der Form (wert, ) angelegt. Der Zugriff auf die Elemente eines Tupels ist mit dem Slice-Operator [start:stop:step] m√∂glich. Tupel k√∂nnen mit den Operatoren + und * verkettet werden.\n\ntupel1 = (2, 7.8, 'Feuer', True, text_variable)\ntupel2 = (1, )\n\nprint(tupel1)\nprint(tupel1[2:4])\nprint(tupel1[::2])\nprint(tupel1[-1])\nprint(tupel1[2:4] + tupel2)\nprint(3 * tupel2)\n\n(2, 7.8, 'Feuer', True, 'abc')\n('Feuer', True)\n(2, 'Feuer', 'abc')\nabc\n('Feuer', True, 1)\n(1, 1, 1)\n\n\n\nTupel kopieren\nTupel verhalten sich beim Kopieren gegens√§tzlich zu Listen. F√ºr Tupel ist die Methode .copy() nicht definiert. Dagegen bewirkt die Kopie mittels dem Zugriffsoperator [:] zwar, dass zwei Tupel auf den selben Speicherplatz zugreifen. Bei der Neuzuweisung eines Tupels legt Python, wie f√ºr jedes Objekt, ein neues Objekt im Speicher an.\n\n# Kopieren durch Zuweisung\ntupel1 = (1, 2, 3)\ntupel2 = tupel1\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(f\"Die in tupel2 gespeicherten Werte sind unver√§ndert:\\n{tupel1} {tupel2}\\n\")\n\n# Kopieren mit Slice Operator\ntupel1 = (1, 2, 3)\ntupel2 = tupel1[:]\nprint(tupel2 is tupel1)\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(tupel1, tupel2)\n\nDie in tupel2 gespeicherten Werte sind unver√§ndert:\n(4, 5, 6) (1, 2, 3)\n\nTrue\n(4, 5, 6) (1, 2, 3)",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#mengen",
    "href": "skript/sammeltypen.html#mengen",
    "title": "5¬† Sammeltypen",
    "section": "5.3 Mengen",
    "text": "5.3 Mengen\nIn Python k√∂nnen Mengen mit der set() Funktion z. B. aus einer Liste oder aus einem Tupel erzeugt oder durch geschweiften Klammern {} erstellt werden (eine leere Menge kann nur mit set() erzeugt werden, da {} ein leeres Dictionary anlegt). Mengen sind ungeordnete Sammelung, dementsprechend haben die Elemente keine Reihenfolge.\n\nliste = [1, 1, 5, 3, 3, 4, 2, 'a', 123, 1000, ('tupel', 5)]\nprint(\"Das Objekt liste als Menge:\\n\", set(liste))\n\nmenge = {1, 2, 3, 4, 5, 1000, ('tupel', 5), 'a', 123}\nprint(\"Die Menge kann auch mit geschweiften Klammern erzeugt werden:\", menge)\n\nDas Objekt liste als Menge:\n {1, 2, 3, 4, 5, ('tupel', 5), 1000, 'a', 123}\nDie Menge kann auch mit geschweiften Klammern erzeugt werden: {1, 2, 3, 4, 5, ('tupel', 5), 1000, 'a', 123}\n\n\nMengen k√∂nnen beispielsweise f√ºr Vergleichsoperationen verwendet werden.\n\nmenge_a = set('Python')\nmenge_b = set('ist super')\n\n# einzigartige Zeichen in a\nprint(\"Menge a:\", menge_a)\n\n# Zeichen in a, aber nicht in b\nprint(\"Menge a - b:\", menge_a - menge_b)\n\n# Zeichen in a oder b\nprint(\"Menge a | b:\", menge_a | menge_b)\n\n# Zeichen in a und b\nprint(\"Menge a & b:\", menge_a & menge_b)\n\n# Zeichen in a oder b, aber nicht in beiden (XOR)\nprint(\"Menge a ^ b:\", menge_a ^ menge_b)\n\nMenge a: {'y', 't', 'o', 'n', 'h', 'P'}\nMenge a - b: {'y', 'o', 'n', 'h', 'P'}\nMenge a | b: {'y', 's', 't', 'u', 'o', 'n', 'p', ' ', 'h', 'e', 'i', 'r', 'P'}\nMenge a & b: {'t'}\nMenge a ^ b: {'s', 'y', 'u', 'o', 'n', 'p', 'r', 'h', 'e', 'i', ' ', 'P'}\n\n\n\nMengen kopieren\nMengen verhalten sich wie Tupel mit dem Unterschied, dass die Methode .copy() f√ºr Mengen definiert ist. Allerdings kann der Zugriffsoperator [] nicht auf Mengen angewendet werden.\n\n# Kopieren durch Zuweisung\nset1 = {1, 2, 3}\nset2 = set1\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unver√§ndert:\\n{set1} {set2}\")\n\n# Kopieren durch Methode .copy()\nset1 = {1, 2, 3}\nset2 = set1.copy()\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unver√§ndert:\\n{set1} {set2}\")\n\nTrue\nDie in set2 gespeicherten Werte sind unver√§ndert:\n{4, 5, 6} {1, 2, 3}\nFalse\nDie in set2 gespeicherten Werte sind unver√§ndert:\n{4, 5, 6} {1, 2, 3}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#dictionaries",
    "href": "skript/sammeltypen.html#dictionaries",
    "title": "5¬† Sammeltypen",
    "section": "5.4 Dictionaries",
    "text": "5.4 Dictionaries\nDictionaries bestehen aus Schl√ºssel-Wert-Paaren. Die Schl√ºssel k√∂nnen Zahlen oder Zeichenketten sein, jeder Schl√ºssel darf nur einmal vorkommen. Dictionaries werden mit geschweiften Klammern {} definiert. Die Schl√ºssel und deren zugeh√∂rigen Werte werden mit einem Doppelpunkt : getrennt. Der Zugriff auf die Werte erfolgt mit dem Zugriffsoperator [], welcher den oder die Schl√ºssel beinhaltet. Ein Zugriff √ºber die Indexposition der Schl√ºssel ist nicht m√∂glich, da Zahlen als Schl√ºssel interpretiert werden.\n\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nprint(dictionary1, \"\\n\")\n\nprint(\"Werte des Schl√ºssels 1:\", dictionary1[1])\nprint(\"Werte des Schl√ºssels 'b':\",  dictionary1['b'])\n\n{1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nWerte des Schl√ºssels 1: abc\nWerte des Schl√ºssels 'b': [1, 2, 3]\n\n\nAuf die Schl√ºssel eines Dictionaries kann √ºber die Methode dictionary.keys(), auf die Werte mittels der Methode dictionary.values() zugegriffen werden.\n\nprint(\"Schl√ºssel:\", dictionary1.keys(), \"\\n\")\nprint(\"Werte:\", dictionary1.values())\n\nSchl√ºssel: dict_keys([1, 'b', 'c']) \n\nWerte: dict_values(['abc', [1, 2, 3], ('tupel', 5, 6)])\n\n\n\nDictionaries kopieren\nDictionaries verhalten sich beim Kopieren wie Listen, das hei√üt beim Kopieren durch Zuweisung teilen sich Dictionaries den Speicherbereich.\n\n# Kopieren durch Zuweisung\nprint(\"dictionary:\", dictionary1, \"\\n\")\ndictionary2 = dictionary1\n\n## √Ñndern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"Auch dictionary1 hat sich durch die Zuweisung in dictionary2 ver√§ndert:\\n\",\n       dictionary1, \"\\n\")\n\n# Verwendung der Methode dictionary.copy()\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\ndictionary2 = dictionary1.copy()\n\n## √Ñndern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"dictionary1 bleibt durch die Zuweisung in dictionary2 unver√§ndert:\\n\",\n       dictionary1, \"\\n\")\n\ndictionary: {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nAuch dictionary1 hat sich durch die Zuweisung in dictionary2 ver√§ndert:\n {1: 'ABC', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\ndictionary1 bleibt durch die Zuweisung in dictionary2 unver√§ndert:\n {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#√ºbersicht-sammeltypen",
    "href": "skript/sammeltypen.html#√ºbersicht-sammeltypen",
    "title": "5¬† Sammeltypen",
    "section": "5.5 √úbersicht Sammeltypen",
    "text": "5.5 √úbersicht Sammeltypen\n\n\n\n\n\n\n\n\n\n\nMerkmal\nListen\nTupel\nMengen\nDictionary\n\n\n\n\nBeschreibung\nflexible Anzahl von Elementen beliebigen Typs\nElemente beliebigen Typs, unver√§nderlich\nungeordnete Sammlung, jedes Element nur einmal enthalten\nZuordnungstabelle aus Schl√ºssel-Wert-Paaren\n\n\nSpeicherbereich bei Zuweisung geteilt\nja\nja (aber unver√§nderlich)\nja (aber Zugriffsoperator nicht anwendbar)\nja\n\n\nMethode .copy() definiert\nja\nnein\nja\nja\n\n\nSlice-Operator anwendbar\nja\nja\nnein\nja (nach Schl√ºssel)",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#l√∂schen-das-schl√ºsselwort-del",
    "href": "skript/sammeltypen.html#l√∂schen-das-schl√ºsselwort-del",
    "title": "5¬† Sammeltypen",
    "section": "5.6 L√∂schen: das Schl√ºsselwort del",
    "text": "5.6 L√∂schen: das Schl√ºsselwort del\nUm Sammeltypen, Elemente oder Slices zu l√∂schen kann das Schl√ºsselwort del verwendet werden.\n\n# L√∂schen einer Liste\ndel liste1\n\n# L√∂schen eines Indexbereichs aus einer Liste\nprint(\"Liste vor dem L√∂schen:\", liste2)\ndel liste2[1:3]\nprint(\"Liste nach dem L√∂schen:\", liste2)\n\n# L√∂schen eines Schl√ºsselworts aus einem Dictionary\nprint(\"Dictionary vor dem L√∂schen\", dictionary1)\ndel dictionary1[1]\nprint(\"Dictionary nach dem L√∂schen\", dictionary1)\n\nListe vor dem L√∂schen: [1, 'xy', True, 'abc']\nListe nach dem L√∂schen: [1, 'abc']\nDictionary vor dem L√∂schen {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nDictionary nach dem L√∂schen {'b': [1, 2, 3], 'c': ('tupel', 5, 6)}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#funktionen",
    "href": "skript/sammeltypen.html#funktionen",
    "title": "5¬† Sammeltypen",
    "section": "5.7 Funktionen",
    "text": "5.7 Funktionen\nDie Sammeltypen k√∂nnen ineinander umgewandelt werden.\n\ndictionary = {1: 'Kater', 2: 'F√§hre', 3: 'Ricke'}\nprint( (liste := list(dictionary)) )\nprint( (menge := set(liste)) )\nprint( (tupel := tuple(menge)) )\n\n[1, 2, 3]\n{1, 2, 3}\n(1, 2, 3)\n\n\nEinige praktische Funktionen lassen sich auch auf Sammeltypen anwenden:\n\nlen() gibt die Anzahl der Elemente in einem Sammeltyp zur√ºck.\nmin(), max(), sum() gibt das Minimum, Maximum bzw. die Summe eines Sammeltyps zur√ºck (bei Dictionaries wird die Anzahl der Schl√ºssel gez√§hlt).",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#operationen-verwendung-von-schleifen",
    "href": "skript/sammeltypen.html#operationen-verwendung-von-schleifen",
    "title": "5¬† Sammeltypen",
    "section": "5.8 Operationen: Verwendung von Schleifen",
    "text": "5.8 Operationen: Verwendung von Schleifen\nUm arithmetische und logische Operatoren auf die in einem Sammeltyp gespeicherten Elemente anzuwenden, wird eine for-Schleife verwendet. Im folgenden Beispiel wird eine Liste ‚Äòzahlen‚Äô durchlaufen, die darin gespeicherten Zahlen quadriert und das jeweilige Ergebnis an die Liste ‚Äòquadratzahlen‚Äô angeh√§ngt. Auch wird gepr√ºft, ob die quadrierten Zahlen ganzzahlig durch 3 teilbar sind und das Pr√ºfergebnis in einer Liste ‚Äòmodulo_3‚Äô gespeichert.\n\n\n\n\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  quadratzahlen.append(quadratzahl)\n  modulo_3.append(quadratzahl % 3 == 0)\n\nprint(quadratzahlen)\nprint(modulo_3)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n[False, False, True, False, False, True, False, False, True, False]\n\n\n\n\nCode-Block¬†5.1",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#aufgaben-sammeltypen",
    "href": "skript/sammeltypen.html#aufgaben-sammeltypen",
    "title": "5¬† Sammeltypen",
    "section": "5.9 Aufgaben Sammeltypen",
    "text": "5.9 Aufgaben Sammeltypen\n\nModifizieren Sie den Programmcode in Code-Block¬†5.1 so, dass nur die Quadratzahlen gespeichert werden, die ganzzahlig durch 3 teilbar sind.\nUmrechnung von Geschwindigkeiten Erstellen Sie ein Skript, welches eine Umrechnungstabelle f√ºr Geschwindigkeiten erzeugt. Folgende Randbedingungen sollen beachtet werden:\n\n\nDie Umrechnung soll von km/h in m/s erfolgen.\nDer Start- und Endwert soll in km/h frei w√§hlbar sein, wobei beide ganzzahlig sein sollen.\nDie Anzahl der Umrechnungspunkte soll definiert werden k√∂nnen und die Zwischenschritte (in km/h) immer als ganze Zahlen ausgegeben werden.\n\nTipp: In Ihrem Skript k√∂nnen Sie die Funktion input() verwenden, um Werte per Eingabe zu erfassen.\n\nSortieren: Gegeben ist die Liste meine_liste = list(range(9, 0, -1)). Diese soll mittels for-Schleifen sortiert werden.\n\n\n\n\n\n\n\nTipp¬†5.2: Musterl√∂sung Aufgaben Sammeltypen\n\n\n\n\n\n\nGanzzahlig durch 3 teilbare Quadratzahlen\n\n\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  if quadratzahl % 3 == 0:\n    quadratzahlen.append(quadratzahl)\n\nprint(quadratzahlen)\n\n[9, 36, 81]\n\n\n\nUmrechnung von Geschwindigkeiten\n\n\n# Freie Eingabe\n## start = int(input(\"Startwert in Kilometer pro Stunde eingeben.\"))\n## ende = int(input(\"Endwert in Kilometer pro Stunde eingeben.\"))\n## ausgabeschritte =  int(input(\"Anzahl auszugebener Schritte ein geben.\"))\n\n# Fixe Werte f√ºr die L√∂sung\nstart = 5\nende = 107\nausgabeschritte = 8\n\n# Liste f√ºr km erstellen\nschrittweite = (ende - start) / (ausgabeschritte - 1)\nliste_km = []\nfor i in range(ausgabeschritte):\n    liste_km.append(round(start + i * schrittweite))\n\n# Umrechnung\n# meter = 1000 * kilometer\n# Sekunde = Stunde * 60 * 60\nliste_m = []\nfor wert in liste_km:\n    liste_m.append(round((wert * 1000) / (60 * 60), 2))\n\n# Ausgabe\nprint(f\"Schrittweite: {schrittweite:.2f}\")\nprint(\"Kilometer pro Stunde\")\nprint(liste_km)\nprint(\"Meter pro Sekunde\")\nprint(liste_m)\n\nSchrittweite: 14.57\nKilometer pro Stunde\n[5, 20, 34, 49, 63, 78, 92, 107]\nMeter pro Sekunde\n[1.39, 5.56, 9.44, 13.61, 17.5, 21.67, 25.56, 29.72]\n\n\n\nSortieren: Bubble Sort Algorithmus\n\n\n# statische Liste, Textausgabe\nmeine_liste = list(range(9, 0, -1))\n\nif len(meine_liste) &gt; 1: \n\n    print(\"Liste zu Beginn\\t\\t  :\", meine_liste)\n\n    # √§u√üere Schleife\n    Schritt = 0\n    for i in range(len(meine_liste) - 1):\n\n    # innere Schleife\n        for j in range(len(meine_liste) - 1):\n            if meine_liste[j] &gt; meine_liste[j + 1]:\n                meine_liste[j], meine_liste[j + 1] = meine_liste[j + 1], meine_liste[j]\n\n        Schritt += 1\n        print(\"Liste nach Schritt \", Schritt, \":\", meine_liste)\n\n    print(\"\\nListe sortiert:\", *meine_liste) # * unterdr√ºckt die Kommas zwischen den Listenelementen\n\nelse:\n    print(\"Die Liste muss mindenstens zwei Elemente enthalten!\")\n\nListe zu Beginn       : [9, 8, 7, 6, 5, 4, 3, 2, 1]\nListe nach Schritt  1 : [8, 7, 6, 5, 4, 3, 2, 1, 9]\nListe nach Schritt  2 : [7, 6, 5, 4, 3, 2, 1, 8, 9]\nListe nach Schritt  3 : [6, 5, 4, 3, 2, 1, 7, 8, 9]\nListe nach Schritt  4 : [5, 4, 3, 2, 1, 6, 7, 8, 9]\nListe nach Schritt  5 : [4, 3, 2, 1, 5, 6, 7, 8, 9]\nListe nach Schritt  6 : [3, 2, 1, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  7 : [2, 1, 3, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  8 : [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nListe sortiert: 1 2 3 4 5 6 7 8 9\n\n\n\n\n\n¬†\n(Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Schleifen und Abzweigungen.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html",
    "href": "skript/funktionen-definieren.html",
    "title": "6¬† Eigene Funktionen definieren",
    "section": "",
    "text": "6.1 Syntax\nDas Schl√ºsselwort def leitet die Funktionsdefinition ein. Es wird gefolgt vom Funktionsnamen und den Funktionsparametern, welche in runden Klammern () eingeschlossen sind. Der Funktionskopf wird mit einem Doppelpunkt : beendet. Der Anweisungsblock der Funktion ist einger√ºckt. Jede Funktion liefert einen R√ºckgabewert, welche durch das Schl√ºsselwort return an die aufrufende Stelle zur√ºckgegeben wird. return beendet die Ausf√ºhrung der Schleife, auch wenn es nicht am Ende des Anweisungsblocks steht.\ndef Funktionsname(Parameter1, Parameter2):\n    Anweisungsblock\n    return R√ºckgabewert\nDamit die Funktion ausgef√ºhrt wird, muss der definierte Funktionsname aufgerufen werden. In der Funktion ist nach dem Schl√ºsselwort return eine weitere Anweisung enthalten, die nicht mehr ausgef√ºhrt wird.\n# Beispiel 1: Summe der Quadrate\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b):\n    print('Argument a:', a)\n    print('Argument b:', b)\n    print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n    print(\"Anweisungen nach dem Schl√ºsselwort return werden nicht mehr ausgef√ºhrt.\")\n\nprint(sum_quadrate(6, 7))\n\nArgument a: 6\nArgument b: 7\n==================\n85\nDer R√ºckgabewert kann in einer Variablen gespeichert werden.\nergebnis = sum_quadrate(6, 7)\nprint(ergebnis)\n\nArgument a: 6\nArgument b: 7\n==================\n85",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html#optionale-parameter",
    "href": "skript/funktionen-definieren.html#optionale-parameter",
    "title": "6¬† Eigene Funktionen definieren",
    "section": "6.2 Optionale Parameter",
    "text": "6.2 Optionale Parameter\nMit Hilfe von optionalen Parametern kann die Programmausf√ºhrung gesteuert werden. Optionale Parameter m√ºssen nach verpflichtend zu √ºbergebenen Parametern definiert werden. In diesem Beispiel wird die print-Ausgabe der Funktion mit dem Parameter ausgabe gesteuert.\n\n# Beispiel 2: optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n\nprint(sum_quadrate(42, 7), \"\\n\")\nprint(sum_quadrate(42, 7, ausgabe = True))\n\n1813 \n\nWert Argument a: 42\nWert Argument b: 7\n==================\n1813\n\n\nGibt es mehrere optionale Parameter, so erfolgt die Zuweisung von Argumenten positional oder √ºber das Schl√ºsselwort.\n\n# Beispiel 3: mehrere optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return summe\n\n# positionale √úbergabe\nprint(sum_potenzen(42, 7, 3, True), \"\\n\")\n\n# √úbergabe per Schl√ºsselwort\nprint(sum_potenzen(42, 7, ausgabe = True, p = 4))\n\nArgument a: 42\nArgument b: 7\nArgument p: 3\n==================\n74431 \n\nArgument a: 42\nArgument b: 7\nArgument p: 4\n==================\n3114097",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html#r√ºckgabewerte",
    "href": "skript/funktionen-definieren.html#r√ºckgabewerte",
    "title": "6¬† Eigene Funktionen definieren",
    "section": "6.3 R√ºckgabewert(e)",
    "text": "6.3 R√ºckgabewert(e)\nFunktionen k√∂nnen in Python nur einen einzigen R√ºckgabewert haben. Trotzdem k√∂nnen mehrere R√ºckgabewerte mit einem Komma getrennt werden. Python gibt diese als Tupel zur√ºck.\n\n# Beispiel 4: mehrere R√ºckgabewerte\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return a, b, summe\n\nergebnis = sum_potenzen(2, 7, ausgabe = False, p = 4)\nprint(ergebnis, type(ergebnis))\n\n(2, 7, 2417) &lt;class 'tuple'&gt;\n\n\nMit dem Slice Operator kann ein bestimmter R√ºckgabewert ausgew√§hlt werden.\n\nprint(ergebnis[2])\n\nsumme_potenzen = sum_potenzen(2, 7, ausgabe = False, p = 4)[2]\nprint(summe_potenzen, type(summe_potenzen))\n\n2417\n2417 &lt;class 'int'&gt;",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html#aufgaben-funktionen-definieren",
    "href": "skript/funktionen-definieren.html#aufgaben-funktionen-definieren",
    "title": "6¬† Eigene Funktionen definieren",
    "section": "6.4 Aufgaben Funktionen definieren",
    "text": "6.4 Aufgaben Funktionen definieren\n\nPalindrom\nSchreiben Sie eine Funktion is_palindrome(), die pr√ºft, ob es sich bei einer √ºbergebenen Zeichenkette um ein Palindrom handelt.\n\nHinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise ‚ÄòAnna‚Äô, ‚ÄòOtto‚Äô, ‚ÄòLagerregal‚Äô. Palindrome m√ºssen nicht aus Buchstaben bestehen, sie k√∂nnen sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise ‚Äò345g543‚Äô.\n\nFibonacci-Zahlenreihe\n\nEntwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der Fibonacci-Reihe generiert und als Liste zur√ºckgibt. Die Fibonacci-Reihe beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden vorhergehenden Zahlen.\n\nVerschl√ºsselung\n\nBei Geocachen werden oft verschl√ºsselte Botschaften als R√§tsel verwendet. Oft wird folgende Logik zur Verschl√ºsselung angewendet:\n\nA -&gt; Z\nB -&gt; Y\nC -&gt; X\n‚Ä¶\n\nSchreiben Sie eine Funktion verschluesseln(str), die einen String als Eingabewert bekommt und einen verschl√ºsselten String zur√ºckgibt. Wie k√∂nnen Sie einen verschl√ºsselten String am einfachsten wieder entschl√ºsseln?\n\nTemperaturkonverter\n\nEntwickeln Sie eine Funktion temperatur_umrechnen(wert, von_einheit, nach_einheit), die eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion soll folgende Parameter verwenden:\n\nwert: Der Temperaturwert, der umgewandelt werden soll.\nvon_einheit / nach_einheit: Die Einheit des Ausgangs- bzw. des Zielwerts als string. M√∂gliche Werte sind ‚ÄòC‚Äô f√ºr Celsius, ‚ÄòF‚Äô f√ºr Fahrenheit und ‚ÄòK‚Äô f√ºr Kelvin.\n\nEs gelten die folgenden Umrechnungsformeln zwischen den Einheiten:\n\nCelsius nach Fahrenheit: F = C * 9/5 + 32\nFahrenheit nach Celsius: C = (F - 32) * 5/9\nCelsius nach Kelvin: K = C + 273.15\nKelvin nach Celsius: C = K - 273.15\nFahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15\nKelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32\n\nDie Musterl√∂sung kann Marc machen\n\n\n\n\n\n\nMusterl√∂sung Aufgaben Funktionen definieren\n\n\n\n\n\n\n\n\n\n¬† (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html",
    "href": "skript/dateien-lesen-und-schreiben.html",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "",
    "text": "7.1 Dateiobjekte\nUm mit Python auf eine Datei zuzugreifen, muss diese f√ºrs Lesen oder Schreiben ge√∂ffnet werden. Dazu wird in Python die Funktion open verwendet. Diese nimmt zwei Argumente, den Pfad der Datei und den Zugriffsmodus, an und liefert ein Dateiobjekt zur√ºck. Aus dem Dateiobjekt werden dann die Inhalte der Datei ausgelesen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#dateiobjekte",
    "href": "skript/dateien-lesen-und-schreiben.html#dateiobjekte",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "",
    "text": "Dateipfad\nDer lokale Dateipfad wird ausgehend vom aktuellen Arbeitsverzeichnis angegeben.\n\npfad_maya = \"01-daten/dice-maya.txt\"\npfad_hans = \"01-daten/dice-hans.txt\"\n\n\n\n\n\n\n\nTipp¬†7.1: Arbeitsverzeichnis in Python ermitteln und wechseln\n\n\n\n\n\nDer Pfad des aktuellen Arbeitsverzeichnisses kann mit dem Modul os mittels os.getcwd() ermittelt werden (hier ohne Ausgabe). Mit os.chdir('neuer_pfad') kann das Arbeitsverzeichnis ggf. gewechselt werden. Die korrekte Formatierung des Pfads erkennen Sie an der Ausgabe von os.getcwd().\n\nimport os\nprint(os.getcwd())\n\nDas Importieren von Modulen wird in einem sp√§teren Kapitel behandelt.\n\n\n\n\n\nZugriffsmodus\nAls Zugriffsmodus stehen unter anderem folgende Optionen zur Verf√ºgung:\n\n\n\n\n\n\n\nModus\nBeschreibung\n\n\n\n\nr\nlesender Zugriff\n\n\nw\nSchreibzugriff, Datei wird √ºberschrieben\n\n\nx\nErzeugt die Datei, Fehlermeldung, wenn die Datei bereits existiert\n\n\na\nSchreibzugriff, Inhalte werden angeh√§ngt\n\n\nb\nBin√§rmodus (z. B. f√ºr Grafiken)\n\n\nt\nTextmodus, default\n\n\n\n¬†\nDie Zugriffsmodi k√∂nnen auch kombiniert werden. Weitere Informationen dazu finden Sie in der Dokumentation. Sofern nicht im Bin√§rmodus auf Dateien zugegriffen wird, liefert die Funktion open() den Dateiinhalt als string zur√ºck.\nIm Lesemodus wird ein Datenobjekt erzeugt.\n\ndaten_maya = open(pfad_maya, mode = 'r')\nprint(daten_maya)\n\n&lt;_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'&gt;\n\n\nWenn das Datenobjekt daten_maya der Funktion print() √ºbergeben wird, gibt Python die Klasse des Objekts zur√ºck, in diesem Fall also _io.TextIOWrapper. Diese Klasse stammt aus dem Modul io und ist f√ºr das Lesen und Schreiben von Textdateien zust√§ndig. Ebenfalls werden als Attribute des Dateiobjekts der Dateipfad, der Zugriffsmodus und die Enkodierung der Datei ausgegeben (siehe Beispiel¬†7.1). Sollte die Enkodierung nicht automatisch als UTF-8 erkannt werden, kann diese mit dem Argument encoding = 'UTF-8' √ºbergeben werden.\n\ndaten_maya = open(pfad_maya, mode = 'r', encoding = 'UTF-8')\nprint(daten_maya)\n\n&lt;_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'&gt;\n\n\n\n\n\n\n\n\nBeispiel¬†7.1: Attribute eines Objekts bestimmen\n\n\n\n\n\nMit der Funktion dir(objekt) k√∂nnen die verf√ºgbaren Attribute eines Objekts ausgegeben werden. Dabei werden jedoch auch die vererbten Attribute und Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel f√ºr die Ganzzahl 1:\n\nprint(dir(1))\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n\n\nUm die Ausgabe auf Attribute einzugrenzen, kann folgende Funktion verwendet werden:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not callable (getattr(objekt, attr))]\nprint(attribute)\n\n['__doc__', 'denominator', 'imag', 'numerator', 'real']\n\n\nMit doppelten Unterstrichen umschlossene Attribute sind f√ºr Python reserviert und nicht f√ºr den:die Nutzer:in gedacht. Folgende Funktion entfernt Attribute mit doppelten Unterstrichen aus der Ausgabe:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n\n['denominator', 'imag', 'numerator', 'real']\n\n\nIm Fall einer Ganzzahl k√∂nnen Attribute (zur Abgrenzung von Gleitkommazahlen in umschlie√üenden Klammern) wie folgt aufgerufen werden:\n\n(1).numerator\n\n1\n\n\nWenn wir uns die Attribute des Dateiobjekts ‚Äòdaten_maya‚Äô ansehen, fallen Attribute mit einem einzelnen f√ºhrenden Unterstrich auf.\n\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n\n['_CHUNK_SIZE', '_finalizing', 'buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n\n\nHierbei handelt es sich um Attribute, die nicht durch den:die Nutzer:in aufgerufen werden sollen (weitere Informationen dazu finden Sie hier). Folgender Programmcode gibt alle Attribute ohne f√ºhrende Unterstriche aus:\n\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('_'))]\nprint(attribute)\n\n['buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n\n\n\n\n\nDie Attribute der Datei k√∂nnen mit entsprechenden Befehlen abgerufen werden.\n\nprint(f\"Dateipfad: {daten_maya.name}\\n\"\n      f\"Dateiname: {os.path.basename(daten_maya.name)}\\n\"\n      f\"Datei ist geschlossen: {daten_maya.closed}\\n\"\n      f\"Zugriffsmodus: {daten_maya.mode}\"\n      f\"Enkodierung: : {daten_maya.encoding}\")\n\nDateipfad: 01-daten/dice-maya.txt\nDateiname: dice-maya.txt\nDatei ist geschlossen: False\nZugriffsmodus: rEnkodierung: : UTF-8\n\n\n\n\n\n\n\n\nTipp¬†7.2: R√ºckfalloption\n\n\n\n\n\nIn der Datenanalyse werden in der Regel spezialisierte Pakete wie NumPy oder Pandas verwendet. Diese vereinfachen das Einlesen von Dateien gegen√ºber der Pythonbasis erheblich. Dennoch ist es sinnvoll, sich mit den Methoden der Pythonbasis zum Einlesen von Dateien vertraut zu machen. Denn das Einlesen mit der Funktion open() klappt so gut wie immer - es ist eine gute R√ºckfalloption.\n\n\n\n\n\nDateiinhalt ausgeben\nUm den Dateiinhalt auszugeben, kann das Datenobjekt mit einer Schleife zeilenweise durchlaufen und ausgegeben werden. (Die Datei dice-maya hat nur eine Zeile.)\n\ni = 0\nfor zeile in daten_maya:\n    print(f\"Inhalt Zeile {i}, mit {len(zeile)} Zeichen:\")\n    print(zeile)\n    i += 1\n\nInhalt Zeile 0, mit 28 Zeichen:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nDies ist jedoch f√ºr gr√∂√üere Dateien nicht sonderlich praktikabel. Die Ausgabe einzelner Zeilen mit der Funktion print() kann aber n√ºtzlich sein, um die genaue Formatierung der Zeichenkette zu pr√ºfen. In diesem Fall hat Maya ihre Daten in Anf√ºhrungszeichen gesetzt und mit einem Komma voneinander getrennt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#dateien-einlesen",
    "href": "skript/dateien-lesen-und-schreiben.html#dateien-einlesen",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.2 Dateien einlesen",
    "text": "7.2 Dateien einlesen\nUm den gesamten Inhalt einer Datei einzulesen, kann die Methode datenobjekt.read() verwendet werden. Die Methode hat als optionalen Parameter .read(size). size wird als Ganzzahl √ºbergeben und entsprechend viele Zeichen (im Bin√§rmodus entsprechend viele Bytes) werden ggf. bis zum Dateiende ausgelesen. Der Parameter size ist n√ºtzlich, um die Formatierung des Inhalts einer gro√üen Datei zu pr√ºfen und dabei die Ausgabe auf eine √ºberschaubare Anzahl von Zeichen zu begrenzen.\n\naugen_maya = daten_maya.read()\n\nprint(f\"len(augen_maya): {len(augen_maya)}\\n\\n\"\n      f\"Inhalt der Datei augen_maya:\\n{augen_maya}\")\n\nlen(augen_maya): 0\n\nInhalt der Datei augen_maya:\n\n\n\nDas hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist leer! Der Grund daf√ºr ist, dass beim Lesen (und beim Schreiben) einer Datei der Dateizeiger die Datei durchl√§uft. Nachdem die Datei daten_maya in Kapitel 7.1.3 zeilenweise ausgegeben wurde, steht der Dateizeiger am Ende der Datei.\n\n\n\n\n\n\nHinweis¬†7.1: Dateizeiger in Python\n\n\n\nWird eine Datei zeilenweise oder mit der Methode .read() ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz ‚Äòdaten‚Äô ge√∂ffnet und mit der Methode daten.read(3) die ersten drei Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0 zur Indexposition 3 (bzw. steht jeweils davor).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung¬†7.1: Bewegung des Dateizeigers beim Auslesen von drei Zeichen\n\n\n\nDie Methode daten.tell() gibt zur√ºck, an welcher Position sich der Dateizeiger befindet.\nMit der Methode daten.seek(offset, whence = 0) wird der Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das Argument offset (Versatz) und das optionale Argument whence (woher), dessen Standardwert 0 (Dateianfang) ist. F√ºr Zugriffe im Bin√§rmodus (open(pfad, mode = 'rb')) kann das Argument whence au√üerdem die Werte 1 (aktuelle Position) oder 2 (Dateiende) annehmen.\n\ndaten.seek(0, 0) bezeichnet den Dateianfang\ndaten.seek(0, 1) bezeichnet die aktuelle Position in der Datei\ndaten.seek(0, 2) bezeichnet das Dateiende\ndaten.seek(-3, 2) bezeichnet das dritte Zeichen vor dem Dateiende\n\n\n\nWird der Dateizeiger mit der Methode datenobjekt.seek(0) an den Dateianfang gestellt, gelingt das Auslesen der Datei.\n\nprint(f\"Position des Dateizeigers vor dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\ndaten_maya.seek(0);\nprint(f\"Position des Dateizeigers nach dem Zur√ºcksetzen auf 0: {daten_maya.tell()}\")\n\naugen_maya = daten_maya.read()\n\nprint(f\"Inhalt des Objekts augen_maya:\\n{augen_maya}\")\n\nPosition des Dateizeigers vor dem Zur√ºcksetzen auf 0: 28\nPosition des Dateizeigers nach dem Zur√ºcksetzen auf 0: 0\nInhalt des Objekts augen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nGeben Sie aus dem Datenobjekt daten_maya mit den Methoden .seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6 und 2, aus.\n\n\n\n\n\n\nTipp¬†7.3: Musterl√∂sung Dateizeiger bewegen\n\n\n\n\n\n\ndaten_maya.seek(6, 0);\nprint(daten_maya.read(1))\n\ndaten_maya.seek(daten_maya.tell() + 4, 0);\nprint(daten_maya.read(1))\n\n6\n2\n\n\n\n\n\nUm Mayas W√ºrfelergebnisse zu addieren, m√ºssen die Zahlen extrahiert und in Ganzzahlen umgewandelt werden, da im Textmodus stets eine Zeichenfolge zur√ºckgegeben wird.\n\nprint(type(augen_maya))\n\n&lt;class 'str'&gt;\n\n\nDazu werden mit der Methode str.strip(\") das f√ºhrende und abschlie√üende Anf√ºhrungszeichen entfernt sowie anschlie√üend mit der Methode str.split('\", \"') die Zeichenfolge √ºber das Trennzeichen in eine Liste aufgeteilt. Anschlie√üend werden die Listenelemente in Ganzzahlen umgewandelt und summiert. (Methoden der string-Bearbeitung werden im n√§chsten Abschnitt ausf√ºhrlich behandelt.)\n\nprint(f\"augen_maya:\\n{augen_maya}\")\n\naugen_maya = augen_maya.strip('\"')\nprint(f\"\\naugen_maya.strip('\\\"'):\\n{augen_maya}\")\n\naugen_maya = augen_maya.split('\", \"')\nprint(f\"\\naugen_maya.split('\\\", \\\"'):\\n{augen_maya}\")\n\naugen_maya_int = []\nfor i in augen_maya:\n  augen_maya_int.append(int(i))\n\nprint(f\"\\naugen_maya_int:\\n{augen_maya_int}\\n\\nSumme Augen: {sum(augen_maya_int)}\")\n\naugen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\naugen_maya.strip('\"'):\n5\", \"6\", \"2\", \"1\", \"4\", \"5\n\naugen_maya.split('\", \"'):\n['5', '6', '2', '1', '4', '5']\n\naugen_maya_int:\n[5, 6, 2, 1, 4, 5]\n\nSumme Augen: 23\n\n\n\nDatei schlie√üen\nNach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um diese f√ºr andere Programme freizugeben.\n\ndaten_maya.close()\n\n\n\n\n\n\n\nHinweis¬†7.2: Schreiboperationen mit Python\n\n\n\nDas Schlie√üen einer Datei ist besonders f√ºr Schreiboperationen auf Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit datenobjekt.write() nicht vollst√§ndig auf den Datentr√§ger geschrieben werden. Siehe dazu die Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-einlesen",
    "href": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-einlesen",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.3 Aufgabe Dateien einlesen",
    "text": "7.3 Aufgabe Dateien einlesen\nWelche Augenzahl hat Hans erreicht?\n\n\n\n\n\n\nTipp¬†7.4: Musterl√∂sung Augenzahlvergleich\n\n\n\n\n\n\n\n# Erst Einlesen der Datei:\ndaten_hans = open(pfad_hans, mode = 'r', encoding = 'UTF-8')\naugen_hans = daten_hans.read()\nprint(augen_hans)\n# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!\n\naugen_hans = augen_hans.strip('\"Hans\", ')\naugen_hans = augen_hans.strip('\"')\naugen_hans = augen_hans.split('\", \"')\nprint(augen_hans)\n# print-Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese k√∂nnen summiert werden\n\n# Neue (leere) Liste f√ºr die W√ºrfe von Hans anlegen:\naugen_hans_int = []\nfor i in augen_hans:\n   augen_hans_int.append(int(i))\n\nprint(f\"Summe Augenzahl von Hans: {sum(augen_hans_int)}\")\n\n\"Hans\", \"3\", \"5\", \"1\", \"3\", \"2\", \"5\"\n['3', '5', '1', '3', '2', '5']\nSumme Augenzahl von Hans: 19\n\n\nMusterl√∂sung von Marc S√∂nnecken.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#daten-interpretieren",
    "href": "skript/dateien-lesen-und-schreiben.html#daten-interpretieren",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.4 Daten interpretieren",
    "text": "7.4 Daten interpretieren\nDatens√§tze liegen typischerweise wenigstens in zweidimensionaler Form vor, d.¬†h. die Daten sind in Zeilen und Spalten organisiert. Au√üerdem weisen Datens√§tze in der Regel auch unterschiedliche Datentypen auf. Die Funktion open(datei) gibt ein Dateiobjekt zur√ºck, das mit Methoden wie zum Beispiel dateiobjekt.read() als Zeichenfolge eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu k√∂nnen, ist es deshalb notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden.\nF√ºr die Bearbeitung von Zeichenfolgen bietet Python eine Reihe von String-Methoden. Einige davon werden in diesem Kapitel exemplarisch verwendet. String-Methoden werden in der Regel mit einem f√ºhrenden ‚Äòstr‚Äô in der Form str.methode() genannt.\nBeispielsweise soll eine Datei mit den Einwohnerzahlen der europ√§ischen L√§nder eingelesen werden.\n\n\n\nDaten\nDateiname\n\n\n\n\nEinwohner Europas\neinwohner_europa_2019.csv\n\n\n\n¬†\nUm einen √úberblick √ºber den Aufbau der Datei zu erhalten, werden die ersten drei Zeilen der Datei ausgegeben. Daf√ºr kann die Datei zeilenweise mit einer for-Schleife durchlaufen werden, die mit dem Schl√ºsselwort break abgebrochen wird, wenn die Laufvariable den Wert 3 erreicht hat. Eine andere M√∂glichkeit ist die Methode dateiobjekt.readline(), die eine einzelne Zeile ausliest. Hier wird die H√§ufigkeit der Schleifenausf√ºhrung √ºber die Laufvariable mit for i in range(3): gesteuert.\n\nfor-Schleife mit breakMethode dateiobjekt.readline()\n\n\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# erste 3 Zeilen anschauen\ni = 0\nfor zeile in dateiobjekt_einwohner:\n  \n  print(zeile)\n  i += 1\n  if i == 3:\n    break\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\nMit der Methode dateiobjekt.readline() kann eine einzelne Zeile eingelesen werden.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\nfor i in range(3):\n  print(dateiobjekt_einwohner.readline())\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\n\nDie Datei hat also zwei Spalten. In der ersten Spalte sind die L√§ndernamen eingetragen, in der zweiten Spalte die Werte. Als Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die Spaltenbeschriftungen eingetragen.\nIm vorherigen Abschnitt haben wir die Methode dateiobjekt.read() kennengelernt, mit der eine Datei vollst√§ndig als string eingelesen wird. Zun√§chst wird die Datei mit der Methode dateiobjekt.read() in das Objekt einwohner eingelesen und wieder geschlossen.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n\n\nAnschlie√üend k√∂nnen die eingelesenen Daten mit der Methode str.split('\\n') zeilweise aufgeteilt werden. Mit '\\n' wird als Argument der Zeilenumbruch √ºbergeben. Die Methode liefert eine Liste zur√ºck.\n\nliste_einwohner_zeilenweise = einwohner.split(\"\\n\")\nprint(liste_einwohner_zeilenweise[0:3])\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']\n\n\nDie Liste enth√§lt an der Indexposition die Spaltenbeschriftungen. Diese k√∂nnen mit der Methode liste.pop(index) aus der Liste entfernt und zugleich in einem neuen Objekt gespeichert werden.\n\nspaltennamen = liste_einwohner_zeilenweise.pop(0)\nspaltennamen = spaltennamen.split(',')\nprint(f\"√úberschrift Spalte 0: {spaltennamen[0]}\\t√úberschrift Spalte 1: {spaltennamen[1]}\")\n\n√úberschrift Spalte 0: GEO   √úberschrift Spalte 1: Value\n\n\nAnschlie√üend kann die Liste mit der Methode str.split(',') nach L√§ndern und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per Ausnahmebehandlung abgefangen. Neben der Fehlermeldung werden der verursachende Listeneintrag und dessen Indexposition ausgegeben.\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept Exception as error:\n  # print Fehlermeldung\n  print(f\"Fehlermeldung: {error}\")\n  \n  # print Eintrag und Index\n  print(f\"Eintrag: {eintrag}\\t Zeilenindex: {liste_einwohner_zeilenweise.index(zeile)}\")\n\nFehlermeldung: list index out of range\nEintrag: ['']    Zeilenindex: 29\n\n\nDie Fehlermeldung ist so zu deuten, dass eine der Listenoperationen mit dem Slice Operator einen ung√ºltigen Index anspricht. Leicht angepasst, liefert der Code-Block auch die Ursache der Fehlermeldung.\nWird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der L√§ndernamen und der Werte.\n\n# leere Zeile entfernen\nliste_einwohner_zeilenweise.remove('')\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nGEO\n['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] \n\nValue\n['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#aufgabe-daten-interpretieren",
    "href": "skript/dateien-lesen-und-schreiben.html#aufgabe-daten-interpretieren",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.5 Aufgabe Daten interpretieren",
    "text": "7.5 Aufgabe Daten interpretieren\n\nBestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die dazugeh√∂rigen L√§nder.\nBereinigen Sie ggf. fehlerhafte Werte.\nWie viele Einwohner leben in Europa insgesamt?\n\n\nWelchen Datentyp hat die Liste einwohnerzahl?\nWelchen Datentyp haben die Eintr√§ge der Liste einwohnerzahl?\n\nDie Musterl√∂sung kann Marc machen\n\n\n\n\n\n\nMusterl√∂sung vollst√§ndiges Einlesen",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#einlesen-als-liste",
    "href": "skript/dateien-lesen-und-schreiben.html#einlesen-als-liste",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.6 Einlesen als Liste",
    "text": "7.6 Einlesen als Liste\nEin Dateiobjekt kann auch direkt als Liste eingelesen werden. Die Methode dateiobjekt.readlines() gibt eine Liste zur√ºck, in der jede Zeile einen Eintrag darstellt. Ebenso kann die Listenfunktion list() auf Dateiobjekte angewendet werden. Beide Vorgehensweisen liefern die gleiche Liste zur√ºck, in der der Zeilenumbruch \\n mit ausgelesen wird.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\nprint(einwohner)\n\n## Dateizeiger zur√ºcksetzen\ndateiobjekt_einwohner.seek(0);\n\n# Funktion list\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\nUm den Zeilenumbruch zu entfernen, k√∂nnte mit dem Slice Operator das letzte Zeichen jedes Listeneintrags entfernt werden.\nEine andere M√∂glichkeit ist die Methode str.replace(old, new, count=-1), mit der Zeichen ersetzt oder gel√∂scht werden k√∂nnen. Die Parameter old und new geben die zu ersetzende bzw. die einzusetzende Zeichenfolge an und m√ºssen positional √ºbergeben werden. √úber den Parameter count kann eingestellt werden, wie oft die Zeichenfolge old ersetzt werden soll. Standardm√§√üig wird jedes Vorkommen ersetzt.\n\nprint('Hund'.replace('Hu', 'Mu'))\n\nzeichenfolge = 'Ein  kurzer Text ohne  doppelte Leerzeichen.'\n\nprint(zeichenfolge.replace('  ', ' '))\n\nMund\nEin kurzer Text ohne doppelte Leerzeichen.\n\n\nDie Methode str.replace() kann auch zum L√∂schen verwendet werden. Wird f√ºr den Parameter new eine leere Zeichenfolge √ºbergeben, wird die in old √ºbergebene Zeichenfolge gel√∂scht.\n\nprint(zeichenfolge.replace(' ', '').replace('doppelte', ''))\n\nEinkurzerTextohneLeerzeichen.\n\n\nMit der Methode str.replace() kann die eingelesene Liste um den Zeilenumbruch bereinigt werden.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\neinwohner_neu = []\n\nfor element in einwohner:\n  einwohner_neu.append(element.replace('\\n', ''))\n\neinwohner = einwohner_neu\nprint(einwohner)\n\n# Datei schlie√üen\ndateiobjekt_einwohner.close();\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039', 'Tschechien,10528984', 'Daenemark,5799763', 'Deutschland einschliesslich ehemalige DDR,82940663', 'Estland,1324820', 'Irland,4904240', 'Griechenland,10722287', 'Spanien,46934632', 'Frankreich,67028048', 'Kroatien,4076246', 'Italien,61068437', 'Zypern,875898', 'Lettland,1919968', 'Litauen,2794184', 'Luxemburg,612179', 'Uganda,-1', 'Ungarn,9772756', 'Malta,493559', 'Niederlande,17423013', 'Oesterreich,8842000', 'Polen,37972812', 'Portugal,10276617', 'Rumaenien,19405156', 'Slowenien,2080908', 'Slowakei,5450421', 'Finnland,5512119', 'Schweden,10243000', 'Vereinigtes Koenigreich,66647112']",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#dateien-schreiben",
    "href": "skript/dateien-lesen-und-schreiben.html#dateien-schreiben",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.7 Dateien schreiben",
    "text": "7.7 Dateien schreiben\nUm Dateien zu schreiben, m√ºssen diese mit der write-Methode eines Dateiobjekts verwendet werden. Dieser Methode wird als Argument die zu schreibende Zeichenfolge √ºbergeben.\n\ndateipfad = \"01-daten/neue_datei.txt\"\n\n# √ñffne Datei zum Schreiben √∂ffnen\ndatei = open(dateipfad, mode = 'w')\n\n# Inhalt in die Datei schreiben\ndatei.write(\"Prokrastination an Hochschulen\\n\\n\".upper())\ndatei.write(\"KAPITEL 1: Aller Anfang ist schwer\\nPlatzhalter: Den Rest schreibe ich sp√§ter.\")\n\n# Datei schlie√üen\n\ndatei.close()\n\nDie Datei kann nun ausgelesen werden.\n\ndateiinhalt = open(dateipfad, mode = 'r')\ntext = dateiinhalt.read()\nprint(text)\n\ndateiinhalt.close()\n\nPROKRASTINATION AN HOCHSCHULEN\n\nKAPITEL 1: Aller Anfang ist schwer\nPlatzhalter: Den Rest schreibe ich sp√§ter.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-schreiben",
    "href": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-schreiben",
    "title": "7¬† Dateien lesen und schreiben",
    "section": "7.8 Aufgabe Dateien schreiben",
    "text": "7.8 Aufgabe Dateien schreiben\n\nErzeugen Sie eine neue Datei mit der Endung .txt, die den Namen ihrer Heimatstadt hat. Schreiben Sie in diese Datei 10 Zeilen mit Informationen zur Stadt.\n\n¬† (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/module-und-pakete-importieren.html",
    "href": "skript/module-und-pakete-importieren.html",
    "title": "8¬† Module und Pakete importieren",
    "section": "",
    "text": "8.1 import as\nUm lange Modulnamen zu vereinfachen, kann beim Importieren das Schl√ºsselwort as verwendet werden, um dem Modul einen neuen Namen zuzuweisen.\nimport matplotlib.pyplot as plt\n\nplt.plot(zufallsdaten)\n\n\n\n\nGrafik mit dem Modul pyplot aus dem Paket matplotlib\nF√ºr h√§ufig verwendete Module haben sich bestimmte K√ºrzel etabliert. In den Bausteinen werden h√§ufig die folgenden Pakete und K√ºrzel genutzt:",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  },
  {
    "objectID": "skript/module-und-pakete-importieren.html#import-as",
    "href": "skript/module-und-pakete-importieren.html#import-as",
    "title": "8¬† Module und Pakete importieren",
    "section": "",
    "text": "Modul\nK√ºrzel\nBefehl\n\n\n\n\nNumPy\nnp\nimport numpy as np\n\n\nPandas\npd\nimport pandas as pd\n\n\nmatplotlib.pyplot\nplt\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  },
  {
    "objectID": "skript/module-und-pakete-importieren.html#kleine-modul√ºbersicht",
    "href": "skript/module-und-pakete-importieren.html#kleine-modul√ºbersicht",
    "title": "8¬† Module und Pakete importieren",
    "section": "8.2 Kleine Modul√ºbersicht",
    "text": "8.2 Kleine Modul√ºbersicht\nDa es nicht m√∂glich ist, auf alle diese Module einzugehen, werden im folgenden nur einige wenige Module aufgelistet, welche f√ºr die Zielgruppe dieses Skripts interessant sein k√∂nnten. Hinweis: Die Eigennamen einiger Module weisen eine Gro√ü- und Kleinschreibung auf, bspw. das Modul NumPy. Beim Importieren der Module werden die Modulnamen jedoch klein geschrieben. In der folgenden Liste wird auf die Gro√ü- und Kleinschreibung daher verzichtet.\n\nmath: mathematische Funktionen und Konstanten\nscipy: wissenschaftliche Funktionen\nsys: Interaktion mit dem Python-Interpreter\nos: Interaktion mit dem Betriebssystem\nglob: Durchsuchen von Dateisystempfaden\nmultiprocessing / threading: Parallelprogramierung mit Prozessen / Threads\nmatplotlib: Visualisierung von Daten und Erstellen von Abbildungen\nnumpy: numerische Operationen und Funktionen\npandas: Daten einlesen und auswerten\ntime: Zeitfunktionen\n\n¬† (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. ‚ÄûDatenanalyse mit Python. Funktionen Module Dateien.‚Äú Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  }
]