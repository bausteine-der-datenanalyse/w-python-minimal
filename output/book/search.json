[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine ComputergestÃ¼tzter Datenanalyse",
    "section": "",
    "text": "Werkzeugbaustein Python",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#voraussetzungen",
    "href": "index.html#voraussetzungen",
    "title": "Bausteine ComputergestÃ¼tzter Datenanalyse",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\nKeine Voraussetzungen",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "index.html#lernziele",
    "href": "index.html#lernziele",
    "title": "Bausteine ComputergestÃ¼tzter Datenanalyse",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Bausteine werden die GrundzÃ¼ge der Programmierung mit Python vermittelt. In diesem Baustein lernen Sie â€¦\n\nGrundlagen des Programmierens\nAusgaben in Python, Grundlegende Datentypen, FLusskontrolle\ndie Dokumentation zu lesen und zu verwenden\nModule und Pakete laden",
    "crumbs": [
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "skript/einleitung.html",
    "href": "skript/einleitung.html",
    "title": "1Â  Einleitung: Datenanalyse mit Python",
    "section": "",
    "text": "2 Willkommen bei Python!\nPython ist eine moderne Programmiersprache, die sich besonders gut fÃ¼r Einsteigerinnen und Einsteiger eignet. Sie ist leicht verstÃ¤ndlich und wird in vielen Bereichen eingesetzt â€“ von der Datenanalyse bis hin zur Webentwicklung.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#lernziele-dieses-kapitels",
    "href": "skript/einleitung.html#lernziele-dieses-kapitels",
    "title": "1Â  Einleitung: Datenanalyse mit Python",
    "section": "2.1 Lernziele dieses Kapitels",
    "text": "2.1 Lernziele dieses Kapitels\nAm Ende dieses Kapitels kÃ¶nnen Sie: - einfache Python-Programme schreiben, - Text auf dem Bildschirm ausgeben, - erste Variablen definieren und verwenden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#ihr-erstes-programm",
    "href": "skript/einleitung.html#ihr-erstes-programm",
    "title": "1Â  Einleitung: Datenanalyse mit Python",
    "section": "2.2 Ihr erstes Programm",
    "text": "2.2 Ihr erstes Programm\nDie ersten Schritte in einer neuen Programmiersprache sind immer die gleichen. WIr lassen uns die Worte â€˜Hello Worldâ€™ ausgeben. Dazu nutzen wir den print-Befehl print(...):\n\nprint(\"Hallo Welt!\")\n\nHallo Welt!\n\n\nWas passiert hier? - print(...) ist eine sogenannte Funktion, die etwas auf dem Bildschirm ausgibt. - Der Text \"Hello World!\" wird angezeigt. - Texte (auch â€Stringsâ€œ genannt) stehen immer in AnfÃ¼hrungszeichen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/einleitung.html#variablen-namen-fÃ¼r-werte",
    "href": "skript/einleitung.html#variablen-namen-fÃ¼r-werte",
    "title": "1Â  Einleitung: Datenanalyse mit Python",
    "section": "2.3 Variablen â€“ Namen fÃ¼r Werte",
    "text": "2.3 Variablen â€“ Namen fÃ¼r Werte\nVariablen sind wie beschriftete Schubladen: Sie speichern Informationen unter einem Namen.\n\nname = \"Frau MÃ¼ller\"\nalter = 32\n\nSie kÃ¶nnen diese Variablen verwenden, um dynamische Ausgaben zu erzeugen:\n\nprint(name + \" ist \" + str(alter) + \" Jahre alt.\")\n\nFrau MÃ¼ller ist 32 Jahre alt.\n\n\nZu beachten ist hier, dass sie versuchen sowohl eine Zahl, als auch Text auszugeben. Daher mÃ¼ssen wir mit der Funktion â€˜str()â€™ die Zahl in Text umwandeln.\n\n\n\n\n\n\nâœï¸ Aufgabe: BegrÃ¼ÃŸung mit Alter\n\n\n\n\n\nSchreiben Sie ein Programm, das Sie mit Ihrem Namen begrÃ¼ÃŸt:\nHallo Frau MÃ¼ller!\nTipp: In Python kÃ¶nnen Sie Texte mit + zusammenfÃ¼gen. Denken Sie daran, dass Strings in AnfÃ¼hrungszeichen stehen mÃ¼ssen.\n\n\n\n\n\n\nLÃ¶sung\n\n\n\n\n\n\nmein_name = \"Ihr Name hier\"\nprint(\"Hallo \" + mein_name + \"!\")\n\nHallo Ihr Name hier!\n\n\n\n\n\nErweitern Sie Ihr Programm so, dass es eine BegrÃ¼ÃŸung inklusive Alter ausgibt:\nHallo Frau MÃ¼ller!\nSie sind 32 Jahre alt.\nTipp: Verwenden Sie print(...) mehrmals oder fÃ¼gen Sie Texte zusammen.\n\n\n\n\n\n\nLÃ¶sung\n\n\n\n\n\n\nname = \"Frau MÃ¼ller\"\nalter = 32\n\nprint(\"Hallo \" + name + \"!\")\nprint(\"Sie sind \" + str(alter) + \" Jahre alt.\")\n\nHallo Frau MÃ¼ller!\nSie sind 32 Jahre alt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Einleitung: Datenanalyse mit Python</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html",
    "href": "skript/datentypen.html",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "",
    "text": "2.1 Lernziele dieses Kapitels\nAm Ende dieses Kapitels kÃ¶nnen Sie: - die wichtigsten Datentypen unterscheiden, - mit Zahlen und Texten rechnen bzw. arbeiten, - einfache Berechnungen und Ausgaben erstellen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#einleitung",
    "href": "skript/datentypen.html#einleitung",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.2 Einleitung",
    "text": "2.2 Einleitung\nIn Python gibt es verschiedene Datentypen. Diese beschreiben, welche Art von Daten Sie in Variablen speichern. Das ist wichtig, weil viele Operationen â€“ wie zum Beispiel + â€“ je nach Datentyp etwas anderes bedeuten:\n\n+ bei Zahlen bedeutet Addition,\n+ bei Text bedeutet ZusammenfÃ¼gen (Konkatenation).\n\nBevor wir also mit komplexeren Programmen arbeiten, sollten wir verstehen, welche Datentypen es gibt und wie man mit ihnen umgeht.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#die-wichtigsten-datentypen",
    "href": "skript/datentypen.html#die-wichtigsten-datentypen",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.3 Die wichtigsten Datentypen",
    "text": "2.3 Die wichtigsten Datentypen\nHier sind die grundlegenden Datentypen in Python:\n\n\n\nTyp\nBeispiel\nBedeutung\n\n\n\n\nint\n10\nGanze Zahl\n\n\nfloat\n3.14\nKommazahl\n\n\nstr\n\"Hallo\"\nText (String)\n\n\nbool\nTrue, False\nWahrheitswert (Ja/Nein)\n\n\n\nSie kÃ¶nnen den Typ einer Variable mit der Funktion type(...) herausfinden:\n\nwert = 42\nprint(type(wert))  # Ausgabe: &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#unterschiede-zwischen-int-und-float",
    "href": "skript/datentypen.html#unterschiede-zwischen-int-und-float",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.4 ğŸ” Unterschiede zwischen int und float",
    "text": "2.4 ğŸ” Unterschiede zwischen int und float\nIn Python unterscheidet man zwischen ganzen Zahlen (int) und Kommazahlen (float):\n\nint steht fÃ¼r â€integerâ€œ â€“ also ganze Zahlen wie 1, 0, -10\nfloat steht fÃ¼r â€floating point numberâ€œ â€“ also Zahlen mit Dezimalstellen wie 3.14, 0.5, -2.0\n\n\na = 10       # int\nb = 2.5      # float\n\nprint(\"a:\", a, \"| Typ:\", type(a))\nprint(\"b:\", b, \"| Typ:\", type(b))\n\na: 10 | Typ: &lt;class 'int'&gt;\nb: 2.5 | Typ: &lt;class 'float'&gt;\n\n\nğŸ’¡ Die Unterscheidung ist wichtig: Manche Rechenoperationen verhalten sich je nach Datentyp leicht unterschiedlich.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#was-sind-booleans-bool",
    "href": "skript/datentypen.html#was-sind-booleans-bool",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.5 ğŸ” Was sind Booleans (bool)?",
    "text": "2.5 ğŸ” Was sind Booleans (bool)?\nEin Boolean ist ein Wahrheitswert: Er kann nur zwei ZustÃ¤nde annehmen:\n\nTrue (wahr)\nFalse (falsch)\n\nSolche Werte begegnen uns zum Beispiel bei Fragen wie:\n\nIst die Temperatur Ã¼ber 30â€¯Â°C?\nHat die Datei einen bestimmten Namen?\nIst die Liste leer?\n\n\nist_sonnig = True\nhat_regenschirm = False\n\nprint(\"Sonnig:\", ist_sonnig)\nprint(\"Regenschirm dabei?\", hat_regenschirm)\nprint(\"Typ von 'ist_sonnig':\", type(ist_sonnig))\n\nSonnig: True\nRegenschirm dabei? False\nTyp von 'ist_sonnig': &lt;class 'bool'&gt;\n\n\nBooleans werden besonders in Bedingungen und Vergleichen verwendet, was Sie in Kapitel 4 genauer kennenlernen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#rechnen-mit-zahlen",
    "href": "skript/datentypen.html#rechnen-mit-zahlen",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.6 Rechnen mit Zahlen",
    "text": "2.6 Rechnen mit Zahlen\nPython kann wie ein Taschenrechner verwendet werden:\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\n\na = 10\nb = 3\n\nprint(\"Addition:\", a + b)\nprint(\"Subtraktion:\", a - b)\nprint(\"Multiplikation:\", a * b)\nprint(\"Potenzieren\", a**b)\nprint(\"Division:\", a / b)\nprint(\"Ganzzahlige Division:\", a // b)\nprint(\"Division mit Rest:\", a % b)\n\nAddition: 13\nSubtraktion: 7\nMultiplikation: 30\nPotenzieren 1000\nDivision: 3.3333333333333335\nGanzzahlige Division: 3\nDivision mit Rest: 1\n\n\nğŸ’¡ // bedeutet: Ganzzahldivision, das Ergebnis wird abgerundet. Alternativ gibt es auch %. Hier wird eine Ganzzahldivision durchgefÃ¼hrt und der Rest ausgegeben.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#arbeiten-mit-text",
    "href": "skript/datentypen.html#arbeiten-mit-text",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.7 Arbeiten mit Text",
    "text": "2.7 Arbeiten mit Text\nTexte (Strings) kÃ¶nnen miteinander kombiniert werden:\n\nvorname = \"Anna\"\nnachname = \"Beispiel\"\nprint(\"Willkommen, \" + vorname + \" \" + nachname + \"!\")\n\nWillkommen, Anna Beispiel!\n\n\nWenn Sie Text und Zahlen kombinieren wollen, mÃ¼ssen Sie die Zahl in einen String umwandeln:\n\npunkte = 95\nprint(\"Sie haben \" + str(punkte) + \" Punkte erreicht.\")\n\nSie haben 95 Punkte erreicht.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/datentypen.html#umwandlung-von-datentypen-typecasting",
    "href": "skript/datentypen.html#umwandlung-von-datentypen-typecasting",
    "title": "2Â  EinfÃ¼hrung: Datentypen verstehen",
    "section": "2.8 ğŸ” Umwandlung von Datentypen (Typecasting)",
    "text": "2.8 ğŸ” Umwandlung von Datentypen (Typecasting)\nManchmal mÃ¼ssen Sie einen Wert von einem Datentyp in einen anderen umwandeln â€“ z.â€¯B. eine Zahl in einen Text (String), damit sie ausgegeben werden kann.\nDas nennt man Typecasting. Hier sind die wichtigsten Funktionen dafÃ¼r:\n\n\n\nFunktion\nBeschreibung\nBeispiel\n\n\n\n\nstr(...)\nZahl â†’ Text\nstr(42) â†’ \"42\"\n\n\nint(...)\nText/Zahl â†’ ganze Zahl\nint(\"10\") â†’ 10\n\n\nfloat(...)\nText/Zahl â†’ Kommazahl\nfloat(\"3.14\") â†’ 3.14\n\n\n\n\n# Beispiel: Zahl als Text anzeigen\npunkte = 100\nprint(\"Sie haben \" + str(punkte) + \" Punkte.\")\n\n# Beispiel: String in Zahl umwandeln und berechnen\neingabe = \"3.5\"\nwert = float(eingabe) * 2\nprint(\"Doppelt so viel:\", wert)\n\nSie haben 100 Punkte.\nDoppelt so viel: 7.0\n\n\nğŸ’¡ Achten Sie beim Umwandeln darauf, dass der Inhalt auch wirklich passt â€“ int(\"abc\") fÃ¼hrt zu einem Fehler.\n\n\n\n\n\n\nâœï¸ Aufgabe: Alter in Tagen\n\n\n\n\n\nBerechnen Sie, wie alt eine Person in Tagen ist.\n\nalter_jahre = 32\ntage = alter_jahre * 365\nprint(\"Sie sind ungefÃ¤hr \" + str(tage) + \" Tage alt.\")\n\nSie sind ungefÃ¤hr 11680 Tage alt.\n\n\nTipp: Denken Sie an die Umwandlung in einen String, wenn Sie die Zahl ausgeben mÃ¶chten.\n\n\n\n\n\n\nLÃ¶sung\n\n\n\n\n\n\nalter = 32\ntage = alter * 365\nprint(\"Sie sind ungefÃ¤hr \" + str(tage) + \" Tage alt.\")\n\nSie sind ungefÃ¤hr 11680 Tage alt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html",
    "href": "skript/funktionen.html",
    "title": "3Â  Funktionen: Grundlagen",
    "section": "",
    "text": "3.1 Funktionen und Methoden\nFunktionen sind Unterprogramme, die Programmanweisungen bÃ¼ndeln, damit Programmteile mehrfach verwendet werden kÃ¶nnen. Auf diese Weise kann ein Programm schneller geschrieben werden und ist auch leichter lesbar. Python bringt, wie Sie der Dokumentation entnehmen kÃ¶nnen, eine Ã¼berschaubare Anzahl von grundlegenden Funktionen mit. In diesem Kapitel wird die allgemeine Verwendung der in Python enthaltenen Funktionen vermittelt.\nPython wird dynamisch weiterentwickelt: regelmÃ¤ÃŸig erscheinen neue Versionen mit neuen Eigenschaften. In diesem Kapitel wird deshalb mit einer Reihe von Tipps auch vermittelt, wie die Dokumentation von Python zu lesen ist. Dies erfolgt auch in Hinblick auf die MÃ¶glichkeit, Python umfangreich durch Module zu erweitern. So haben beispielsweise die Funktionen des Moduls Pandas nicht selten dutzende dokumentierte Parameter.\nIn Python gibt es zwei Arten von Funktionen: Funktionen und Methoden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html#funktionen-und-methoden",
    "href": "skript/funktionen.html#funktionen-und-methoden",
    "title": "3Â  Funktionen: Grundlagen",
    "section": "",
    "text": "Funktionen\nFunktionen kÃ¶nnen Objekte unabhÃ¤ngig von ihrem Datentyp Ã¼bergeben werden. Funktionen werden Ã¼ber ihren Funktionsnamen gefolgt von runden Klammern () aufgerufen. Ein Beispiel ist die Funktion print():\n\nvar_str = 'ABC'\nvar_int = 26\nvar_bool = True\n\nprint(\"Die Variable var_1 hat den Typ\", type(var_str))\nprint(\"Die Variable var_2 hat den Typ\", type(var_int))\nprint(\"Die Variable var_3 hat den Typ\", type(var_bool))\n\nDie Variable var_1 hat den Typ &lt;class 'str'&gt;\nDie Variable var_2 hat den Typ &lt;class 'int'&gt;\nDie Variable var_3 hat den Typ &lt;class 'bool'&gt;\n\n\nFunktionen mÃ¼ssen immer einen Wert zurÃ¼ckgeben. Wenn Funktionen keinen Wert zurÃ¼ckgeben kÃ¶nnen oder sollen, wird der Wert None zurÃ¼ckgegeben, der nicht existente Werte kennzeichnet.\n\nres = print( 15 )\nprint(res)\n\n15\nNone\n\n\nFunktionen kÃ¶nnen verschachtelt und so von innen nach auÃŸen nacheinander ausgefÃ¼hrt werden. In diesem Code-Beispiel wird zunÃ¤chst die Summe zweier Zahlen und anschlieÃŸend der Wahrheitswert des Ergebnisses gebildet. Dieser wird anschlieÃŸend mit der Funktion print ausgegeben.\n\nprint(bool(sum([1, 2])))\n\nTrue\n\n\n\n\nMethoden\nMethoden sind eine Besonderheit objektorientierter Programmiersprachen. Im vorherigen Kapitel wurde erlÃ¤utert, dass in Python Objekte zu einem bestimmten Typ bzw. zu einer Klasse gehÃ¶ren und abhÃ¤ngig von den in ihnen gespeicherten Werte einen passenden Datentyp erhalten. Methoden sind Funktionen, die zu einer bestimmten Klasse gehÃ¶ren und nur fÃ¼r Objekte dieser Klasse verfÃ¼gbar sind. Methoden kÃ¶nnen auch fÃ¼r mehrere Klassen definiert sein. Methoden werden getrennt durch einen Punkt . hinter Objekten mit ihrem Namen aufgerufen: variable.methode bzw. (wert).methode. Beispielsweise sind .upper(), .lower() und .title fÃ¼r Zeichenfolgen definierte Methoden.\n\ntoller_text = \"Python 3.12 ist groÃŸartig.\"\n\nprint(toller_text.upper())\nprint(toller_text.lower())\nprint(toller_text.title(), \"\\n\")\n\nprint((\"Mit in Klammern gesetzten Werten klappt es auch.\").upper())\n\nPYTHON 3.12 IST GROSSARTIG.\npython 3.12 ist groÃŸartig.\nPython 3.12 Ist GroÃŸartig. \n\nMIT IN KLAMMERN GESETZTEN WERTEN KLAPPT ES AUCH.\n\n\nFÃ¼r Objekte mit einem unpassenden Datentyp sind Methoden wie .lower() nicht verfÃ¼gbar.\n\nprint((1).upper())\n\n\n\n'int' object has no attribute 'upper'\n\n\nMethoden kÃ¶nnen verkettet und so nacheinander ausgefÃ¼hrt werden. In diesem Beispiel wird die Zeichenfolge â€˜Katzeâ€™ klein geschrieben, dann die HÃ¤ufigkeit des Buchstabens â€˜kâ€™ gezÃ¤hlt.\n\nprint('Katze'.lower().count('k'))\n\n1\n\n\nWelche Methoden fÃ¼r ein Objekt verfÃ¼gbar sind, kann mit der Funktion dir(objekt) bestimmt werden. Die Ausgabe der Funktion ist aber hÃ¤ufig sehr umfangreich. Um die relevanten EintrÃ¤ge auszuwÃ¤hlen, muss die Ausgabe gefiltert werden. Notwendig ist das aber nicht - Interessierte schauen in BeispielÂ 3.1.\n\n\n\n\n\n\nBeispielÂ 3.1: Methoden eines Objekts bestimmen\n\n\n\n\n\nMit der Funktion dir(objekt) kÃ¶nnen die verfÃ¼gbaren Methoden eines Objekts ausgegeben werden. Dabei werden jedoch auch die Attribute und die Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel fÃ¼r die Ganzzahl 1:\n\nprint(dir(1))\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n\n\nUm die Ausgabe auf Methoden einzugrenzen, kann folgende Funktion in Listenschreibweise verwendet werden:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if callable (getattr(objekt, attr))]\nprint(attribute)\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'from_bytes', 'to_bytes']\n\n\nMit doppelten Unterstrichen umschlossene Methoden sind fÃ¼r die Klasse definierte Methoden. Folgende Funktion entfernt Methoden mit doppelten Unterstrichen aus der Ausgabe:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(attribute)\n\n['as_integer_ratio', 'bit_length', 'conjugate', 'from_bytes', 'to_bytes']\n\n\nIm Fall einer Ganzzahl kÃ¶nnen Methoden (zur Abgrenzung von Gleitkommazahlen in umschlieÃŸenden Klammern) wie folgt aufgerufen werden:\n\n(1).as_integer_ratio()\n\n(1, 1)\n\n\nDie Methoden des Objekts â€˜toller_textâ€™:\n\nobjekt = toller_text\n\nattribute = [attr for attr in dir(objekt) if (callable(getattr(objekt, attr)) and not attr.startswith('__'))]\nprint(attribute)\n\n['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html#parameter",
    "href": "skript/funktionen.html#parameter",
    "title": "3Â  Funktionen: Grundlagen",
    "section": "3.2 Parameter",
    "text": "3.2 Parameter\nVielen Funktionen und Methoden kÃ¶nnen getrennt durch Kommata mehrere Parameter Ã¼bergeben werden. Die Werte, die als Parameter Ã¼bergeben werden, werden Argumente genannt (Python-Dokumentation). Parameter steuern die ProgrammausfÃ¼hrung. Die fÃ¼r die Funktion print() verfÃ¼gbaren Parameter stehen in der Dokumentation der Funktion:\nprint(*objects, sep=' ', end='\\n', file=None, flush=False)\n*objects, sep, end, file und flush sind die Parameter der Funktion print().\n\nParameter ohne Gleichheitszeichen = mÃ¼ssen beim Funktions- bzw. Methodenaufruf Ã¼bergeben werden. Parameter mit Gleichheitszeichen = kÃ¶nnen beim Aufruf Ã¼bergeben werden, es handelt sich um optionale Parameter.\nDie Werte hinter dem Gleichheitszeichen zeigen die Standardwerte (default value) der Parameter an. Diese werden verwendet, wenn ein Argument nicht explizit beim Aufruf Ã¼bergeben wird.\n\n\n\n\n\n\n\nTippÂ 3.2: Ausnahmen bei Standardwerten\n\n\n\n\n\nBei den in der Funktionsdefinition genannten Werten handelt es sich nicht immer um die tatsÃ¤chlichen Standardwerte. Es empfiehlt sich deshalb, wenn eine Funktion verwendet wird, die Beschreibung der Parameter zu lesen.\nEinige Funktionen verwenden das SchlÃ¼sselwort None zur Kennzeichnung des Standardwerts. Der Wert None dient dabei als Platzhalter. Ein Beispiel ist die NumPy-Funktion numpy.loadtxt().\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, /\n              skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, /\n              *, quotechar=None, like=None)\n\nFÃ¼r den Parameter delimiter ist als Standardwert das SchlÃ¼sselwort None eingetragen. Wie der Funktionsbeschreibung zu entnehmen ist, ist der Standartwert tatsÃ¤chlich das Leerzeichen: â€œThe default is whitespace.â€\nAuch der Parameter usecols hat den Standarwert None: â€œThe default, None, results in all columns being read.â€\n\nEin weiteres Beispiel ist die Funktion pandas.read_csv(). Einige Argumente haben den Standardwert &lt;no_default&gt;. (Im Folgenden werden nur ausgewÃ¤hlte Parameter gezeigt).\npandas.read_csv(sep=&lt;no_default&gt;, verbose=&lt;no_default&gt;)\nAus der Beschreibung kÃ¶nnen die tatsÃ¤chlichen Standardwerte abgelesen werden:\nsep : str, default â€˜,â€™\nverbose : bool, default False\n\n\n\n\nArgumente kÃ¶nnen in Python entweder als positionales Argument Ã¼bergeben werden Das heiÃŸt, Python erwartet Argumente in einer feststehenden Reihenfolge entsprechend der Parameter der Funktionsdefinition. Alternativ kÃ¶nnen Argumente als SchlÃ¼sselwort Ã¼bergeben werden, die Zuordnung von Eingaben erfolgt Ã¼ber den Namen des Parameters. StandardmÃ¤ÃŸig kÃ¶nnen Argumente positional oder per SchlÃ¼sselwort Ã¼bergeben werden. Abweichungen davon werden durch die Symbole * und / gekennzeichnet (siehe folgenden Tipp).\n\n\n\n\n\n\n\nTippÂ 3.3: Positionale und SchlÃ¼sselwortargumente, *args und **kwargs\n\n\n\n\n\nDie Symbole * und / zeigen an, welche Parameter positional und welche per SchlÃ¼sselwort Ã¼bergeben werden kÃ¶nnen bzw. mÃ¼ssen.\n\n\n\n\n\n\n\n\n\nLinke Seite\nTrennzeichen\nRechte Seite\n\n\n\n\nnur positionale Argumente\n/\npositionale oder SchlÃ¼sselwortargumente\n\n\npositionale oder SchlÃ¼sselwortargumente\n*\nnur SchlÃ¼sselwortargumente\n\n\n\n(https://realpython.com/python-asterisk-and-slash-special-parameters/)\n\nÂ \nEin Beispiel fÃ¼r das Trennzeichen * ist die Funktion glob aus dem gleichnamigen Modul. Der Parameter pathname kann positional (an erster Stelle) oder als SchlÃ¼sselwort Ã¼bergeben werden. Die Ã¼brigen Parameter mÃ¼ssen als SchlÃ¼sselwortargumente Ã¼bergeben werden.\nglob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)\nBeide Steuerzeichen kÃ¶nnen innerhalb einer Funktionsdefinition vorkommen, allerdings nur in der Reihenfolge / und *. Im umgekehrten Fall wÃ¤re es unmÃ¶glich, Argumente zu Ã¼bergeben. Ein Beispiel ist die Funktion sorted. Der erste Parameter muss positional Ã¼bergeben werden, die Parameter key und reverse mÃ¼ssen als SchlÃ¼sselworte Ã¼bergeben werden.\nsorted(iterable, /, *, key=None, reverse=False)Â¶\n\n\n\n\n\n\nAusnahmen\n\n\n\nEinige Funktionen weichen von der Systematik ab, beispielsweise die Funktionen min() und max(). Diese sind (u. a.) in der Form definiert:\nmin(iterable, *, key=None)\nmax(iterable, *, key=None)\nBeide Funktionen akzeptieren den Parameter iterable aber nicht als SchlÃ¼sselwort.\n\n\nVielen Funktionen kÃ¶nnen beliebig viele Argumente positional oder als SchlÃ¼sselwort Ã¼bergeben werden. Im Allgemeinen wird dies durch die SchlÃ¼sselwÃ¶rter *args (positionale Argumente) und **kwargs (key word arguments, SchlÃ¼sselwortargumente) angezeigt. Der Unterschied wird durch das eine bzw. die beiden Sternchen markiert, die SchlÃ¼sselwÃ¶rter selbst sind austauschbar (wie bei der Funktion print(*objects)). Das SchlÃ¼sselwort *args entspricht zugleich dem Symbol * in der Funktionsdefinition, d.Â h. rechts davon dÃ¼rfen nur SchlÃ¼sselwortargumente stehen. Weitere Informationen dazu finden Sie hier.\n\n\n\nIn der Funktionsdefinition von print() ist *objects also ein positionaler Parameter (dieser steht immer an erster Stelle), der keinen Standardwert hat und dem beliebig viele Argumente Ã¼bergeben werden kÃ¶nnen (n Eingaben stehen an den ersten n-Stellen). Die weiteren Parameter der Funktion print() sind optional und mÃ¼ssen als SchlÃ¼sselwort Ã¼bergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen.html#aufgaben-funktionen",
    "href": "skript/funktionen.html#aufgaben-funktionen",
    "title": "3Â  Funktionen: Grundlagen",
    "section": "3.3 Aufgaben Funktionen",
    "text": "3.3 Aufgaben Funktionen\n\nRichtig oder falsch: Methoden stehen abhÃ¤ngig vom Datentyp eines Werts oder eines Objekts zur VerfÃ¼gung.\nGeben Sie die drei Werte 1, 2 und 3 mit print() aus. Parametrisieren Sie die Funktion so, dass ihre Ausgabe wie folgt aussieht:\n\n\n\n1_x_2_x_3\n\n\n\nSchlagen Sie in der Dokumentation die Funktion bool() nach.\n\n\nWelche Parameter nimmt die Funktion entgegen und welche davon sind optional?\nWelche Argumente werden positional und welche als SchlÃ¼sselÃ¼bergeben? Ist die Art der Ãœbergabe wÃ¤hlbar oder festgelegt?\n\n\n\n\n\n\n\nLÃ¶sungen\n\n\n\n\n\nAufgabe 1: richtig\nAufgabe 2\n\nprint(1, 2, 3, sep = \"_x_\")\n\nAufgabe 3: Die Funktion bool() hat ein optionales Argument object mit dem Standardwert False. Das Argument muss positional Ã¼bergeben werden.",
    "crumbs": [
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Funktionen: Grundlagen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html",
    "href": "skript/flusskontrolle.html",
    "title": "4Â  EinfÃ¼hrung: Entscheidungen und Wiederholungen",
    "section": "",
<<<<<<< Updated upstream
    "text": "4.1 Lernziele dieses Kapitels\nProgramme mÃ¼ssen oft Entscheidungen treffen â€“ zum Beispiel abhÃ¤ngig von einer Benutzereingabe oder einem bestimmten Wert. Ebenso mÃ¼ssen bestimmte Aktionen mehrfach durchgefÃ¼hrt werden.\nDafÃ¼r gibt es zwei zentrale Elemente in Python:\nAm Ende dieses Kapitels kÃ¶nnen Sie: - Bedingungen formulieren und mit if, elif, else nutzen, - Vergleichsoperatoren verwenden (==, &lt;, !=, â€¦), - Wiederholungen mit while und for umsetzen.",
=======
    "text": "Abzweigungen\nDie Flusskontrolle ermÃ¶glicht es, die AusfÃ¼hrung von Programmteilen zu steuern. Anweisungen kÃ¶nnen Ã¼bersprungen oder mehrfach ausgefÃ¼hrt werden.\nAbzweigungen ermÃ¶glichen eine Fallunterscheidung, bei der abhÃ¤ngig von einer oder mehreren Bedingungen verschiedene Teile des Skripts ausgefÃ¼hrt werden.\nIn Python werden Abzweigungen mit dem SchlÃ¼sselwort if eingeleitet. Dieses wird von der Abzweigbedingung gefolgt und mit einem Doppelpunkt : abgeschlossen. Falls die Abzweigbedingung wahr ist, wird der eingerÃ¼ckte Anweisungsblock ausgefÃ¼hrt.\n# Beispiel: Zahl kleiner als ein Schwellwert\n\na = 7\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\n\nDie Zahl 7 ist kleiner als 10.\nEs ist auch mÃ¶glich einen alternativen Anweisungsblock zu definieren, welcher ausgefÃ¼hrt wird, wenn die Bedingung falsch ist. Dieser wird mit dem else SchlÃ¼sselwort umgesetzt.\n# Beispiel: Zahl kleiner als ein Schwellwert mit alternativer Ausgabe\n\na = 13\nif a &lt; 10:\n    print( 'Die Zahl', a, 'ist kleiner als 10.')\nelse:\n    print( 'Die Zahl', a, 'ist nicht kleiner als 10.')\n\nDie Zahl 13 ist nicht kleiner als 10.\nEs kÃ¶nnen auch mehrere Bedingungen Ã¼bergeben werden.\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20\n\na = 1\nif a &lt; 20 and a &gt; 10:\n    print( 'Die Zahl', a, 'liegt zwischen 10 und 20.')\nelse:\n    print( 'Die Zahl', a, 'liegt nicht zwischen 10 und 20.')\n\nDie Zahl 1 liegt nicht zwischen 10 und 20.\nSchlieÃŸlich kÃ¶nnen mehrere alternative Bedingungen geprÃ¼ft werden. Dies ist zum einen durch das Verschachteln von Abzweigungen mÃ¶glich.\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit verschachtelten Abzweigungen\n\na = 12\nif a &gt; 10:\n    print( 'Die Zahl', a, 'ist grÃ¶ÃŸer als 10.' )\n    \n    if a &lt; 20:\n        print( 'Die Zahl', a, 'ist kleiner als 20.' )\n        print( 'Damit liegt die Zahl zwischen 10 und 20.')\n    else:\n        print( 'Die Zahl', a, 'ist grÃ¶ÃŸer als 20 und liegt nicht im gesuchten Wertebereich.' )\nelse:\n        print( 'Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\n\nDie Zahl 12 ist grÃ¶ÃŸer als 10.\nDie Zahl 12 ist kleiner als 20.\nDamit liegt die Zahl zwischen 10 und 20.\nZum anderen ist dies mit dem SchlÃ¼sselwort elif mÃ¶glich.\n# Beispiel: Zahl im Wertebereich zwischen 10 und 20 mit elif\n\na = 112\nif a &lt; 20 and a &gt; 10:\n  print('Die Zahl', a, 'liegt zwischen 10 und 20.')\nelif a &lt; 10:\n  print('Die Zahl', a, 'ist kleiner als 10 und liegt nicht im gesuchten Wertebereich.' )\nelif a &gt; 20 and a &lt;= 100:\n  print('Die Zahl', a, 'ist grÃ¶ÃŸer als 20, aber nicht grÃ¶ÃŸer als 100.')\nelif a &gt; 20 and a &lt;= 1000:\n  print('Die Zahl', a, 'ist grÃ¶ÃŸer als 20, aber nicht grÃ¶ÃŸer als 1000.')\nelse:\n  print('Die Zahl', a, 'liegt nicht zwischen 10 und 20 und ist grÃ¶ÃŸer als 1000.')\n\nDie Zahl 112 ist grÃ¶ÃŸer als 20, aber nicht grÃ¶ÃŸer als 1000.",
>>>>>>> Stashed changes
    "crumbs": [
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html#bedingungen-mit-if-elif-else",
    "href": "skript/flusskontrolle.html#bedingungen-mit-if-elif-else",
    "title": "4Â  EinfÃ¼hrung: Entscheidungen und Wiederholungen",
    "section": "4.2 Bedingungen mit if, elif, else",
    "text": "4.2 Bedingungen mit if, elif, else\n\nalter = 17\n\nif alter &gt;= 18:\n    print(\"Sie sind volljÃ¤hrig.\")\nelse:\n    print(\"Sie sind minderjÃ¤hrig.\")\n\nSie sind minderjÃ¤hrig.\n\n\nMehrere FÃ¤lle unterscheiden:\n\nnote = 2.3\n\nif note &lt;= 1.5:\n    print(\"Sehr gut\")\nelif note &lt;= 2.5:\n    print(\"Gut\")\nelif note &lt;= 3.5:\n    print(\"Befriedigend\")\nelse:\n    print(\"Ausreichend oder schlechter\")\n\nGut",
    "crumbs": [
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html#vergleichsoperatoren",
    "href": "skript/flusskontrolle.html#vergleichsoperatoren",
    "title": "4Â  EinfÃ¼hrung: Entscheidungen und Wiederholungen",
    "section": "4.3 Vergleichsoperatoren",
    "text": "4.3 Vergleichsoperatoren\n\n\n\nAusdruck\nBedeutung\n\n\n\n\na == b\ngleich\n\n\na != b\nungleich\n\n\na &lt; b\nkleiner als\n\n\na &gt; b\ngrÃ¶ÃŸer als\n\n\na &lt;= b\nkleiner oder gleich\n\n\na &gt;= b\ngrÃ¶ÃŸer oder gleich",
    "crumbs": [
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html#wiederholungen-mit-while",
    "href": "skript/flusskontrolle.html#wiederholungen-mit-while",
    "title": "4Â  EinfÃ¼hrung: Entscheidungen und Wiederholungen",
    "section": "4.4 Wiederholungen mit while",
    "text": "4.4 Wiederholungen mit while\n\nzÃ¤hler = 0\n\nwhile zÃ¤hler &lt; 5:\n    print(\"ZÃ¤hler ist:\", zÃ¤hler)\n    zÃ¤hler += 1\n\nZÃ¤hler ist: 0\nZÃ¤hler ist: 1\nZÃ¤hler ist: 2\nZÃ¤hler ist: 3\nZÃ¤hler ist: 4\n\n\nğŸ’¡ Achten Sie auf eine Abbruchbedingung â€“ sonst lÃ¤uft die Schleife endlos!",
    "crumbs": [
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html#schleifen-mit-for-und-range...",
    "href": "skript/flusskontrolle.html#schleifen-mit-for-und-range...",
    "title": "4Â  EinfÃ¼hrung: Entscheidungen und Wiederholungen",
    "section": "4.5 Schleifen mit for und range(...)",
    "text": "4.5 Schleifen mit for und range(...)\nWenn Sie eine Schleife genau eine bestimmte Anzahl von Malen durchlaufen mÃ¶chten, nutzen Sie for mit range(...):\n\nfor i in range(5):\n    print(\"Durchlauf:\", i)\n\nDurchlauf: 0\nDurchlauf: 1\nDurchlauf: 2\nDurchlauf: 3\nDurchlauf: 4\n\n\nStart- und Endwert festlegen:\n\nfor i in range(1, 6):\n    print(i)\n\n1\n2\n3\n4\n5",
    "crumbs": [
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "skript/flusskontrolle.html#was-macht-range...-genau",
    "href": "skript/flusskontrolle.html#was-macht-range...-genau",
    "title": "4Â  EinfÃ¼hrung: Entscheidungen und Wiederholungen",
    "section": "4.6 Was macht range(...) genau?",
    "text": "4.6 Was macht range(...) genau?\nDie Funktion range(...) erzeugt eine Abfolge von Zahlen, Ã¼ber die Sie mit einer for-Schleife iterieren kÃ¶nnen.\n\nğŸ”¢ Varianten:\nrange(5)\nâ¡ï¸ ergibt: 0, 1, 2, 3, 4 (startet bei 0, endet vor 5)\nrange(2, 6)\nâ¡ï¸ ergibt: 2, 3, 4, 5 (startet bei 2, endet vor 6)\nrange(1, 10, 2)\nâ¡ï¸ ergibt: 1, 3, 5, 7, 9 (Schrittweite = 2)\nğŸ’¡ range(...) erzeugt keine echte Liste, sondern ein sogenanntes â€range-Objektâ€œ, das wie eine Liste verwendet werden kann.\n\n\n\n\n\n\nâœï¸ Aufgabe: ZÃ¤hle von 1 bis 10\n\n\n\n\n\nNutzen Sie eine for-Schleife, um die Zahlen von 1 bis 10 auszugeben.\n\n\n\n\n\n\nLÃ¶sung\n\n\n\n\n\n\nfor i in range(1, 11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nâœï¸ Aufgabe: Gerade Zahlen ausgeben\n\n\n\n\n\nGeben Sie alle geraden Zahlen von 0 bis 20 aus. Tipp: Eine Zahl ist gerade, wenn zahl % 2 == 0.\n\n\n\n\n\n\nLÃ¶sung\n\n\n\n\n\n\nfor zahl in range(0, 21):\n    if zahl % 2 == 0:\n        print(zahl)\n\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20",
    "crumbs": [
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>EinfÃ¼hrung: Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html",
    "href": "skript/sammeltypen.html",
    "title": "5Â  Sammeltypen",
    "section": "",
    "text": "5.1 Listen\nSammeltypen werden benutzt, um mehrere Werte in einer Variablen zu speichern und zu verarbeiten. In Python gibt es vier Sammeltypen, die jeweils eine eigene Klasse sind:\nIn diesem Kapitel werden die vier Sammeltypen zunÃ¤chst kurz vorgestellt. AnschlieÃŸend wird die Arbeitsweise insbesondere mit Listen erlÃ¤utert.\nWie alle Typen in Python werden Listen durch Zuweisung erstellt. Bei der Definition einer Liste werden die Elemente durch eckige Klammern [] eingeklammert und mit Kommata , getrennt. Listen kÃ¶nnen mit dem +-Operator verkettet werden. * verkettet eine Liste n-mal.\ntext_variable = 'abc'\n\nliste1 = [1, 'xy', True, text_variable]\nprint(liste1)\n\n# Listen kÃ¶nnen auch Listen enthalten\nliste2 = [None, liste1]\nprint(liste2)\n\n# Listen kÃ¶nnen mit + und * verkettet werden\nprint(liste1 + liste2)\nprint(liste1 * 2)\n\n[1, 'xy', True, 'abc']\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc', 1, 'xy', True, 'abc']\nEine leere Liste kann durch Zuweisung von [] erstellt werden.\nleere_liste = []\nprint(leere_liste)\n\n[]",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#listen",
    "href": "skript/sammeltypen.html#listen",
    "title": "5Â  Sammeltypen",
    "section": "",
    "text": "Slicing: der Zugriffsoperator []\nDer Zugriff auf einzelne oder mehrere Elemente einer Liste (und andere Sammeltypen) erfolgt Ã¼ber den Zugriffsoperator []. Ein Ausschnitt aus einem Objekt wird Slice genannt, der Operator heiÃŸt deshalb auch Slice Operator.\n\nZugriff auf einzelne Elemente\nElemente werden Ã¼ber ihren Index, bei 0 beginnend, angesprochen.\n\nprint(liste1)\nprint(liste1[0])\nprint(liste1[3])\n\n[1, 'xy', True, 'abc']\n1\nabc\n\n\nAuf verschachtelte Listen kann mit zwei aufeinanderfolgenden Zugriffsoperatoren zugegriffen werden. Die Liste liste2 enthÃ¤lt an Indexposition 1 eine Liste mit 4 Elementen.\n\nprint(liste2)\nprint(liste2[1])\nprint(liste2[1][0], liste2[1][1], liste2[1][2], liste2[1][3])\n\n[None, [1, 'xy', True, 'abc']]\n[1, 'xy', True, 'abc']\n1 xy True abc\n\n\nMit negativen Indizes kÃ¶nnen Elemente vom Ende aus angesprochen werden. So entspricht z. B. die -1 dem letzten Element.\n\nprint(liste1)\nprint(liste1[-1], liste1[-3])\n\n[1, 'xy', True, 'abc']\nabc xy\n\n\n\n\nZugriff auf mehrere Elemente\nIndexbereiche kÃ¶nnen in der Form [start:stop:step] angesprochen werden. start ist das erste adressierte Element, stop das erste nicht mehr adressierte Element und step die Schrittweite.\n\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[start:stop]\nElemente von start bis stop - 1\n\n\nliste[:]\nAlle Elemente der Liste\n\n\nliste[start:]\nElemente von start bis zum Ende der Liste\n\n\nliste[:stop]\nElemente vom Anfang der Liste bis stop - 1\n\n\nliste[::3]\nAuswahl jedes dritten Elements\n\n\n\nÂ \nNegative Werte fÃ¼r start, stop oder step bewirken eine RÃ¼ckwÃ¤rtsauswahl von Elementen.\n\n\n\n\n\n\n\nZugriffsoperator\nAusschnitt\n\n\n\n\nliste[-1]\ndas letzte Element der Liste\n\n\nliste[-2:]\ndie letzten beiden Elemente der Liste\n\n\nliste[:-2]\nalle bis auf die beiden letzten Elemente\n\n\nliste[::-1]\nalle Elemente in umgekehrter Reihenfolge\n\n\nliste[1::-1]\ndie ersten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[:-3:-1]\ndie letzten beiden Elemente in umgekehrter Reihenfolge\n\n\nliste[-3::-1]\nalle auÃŸer die letzten beiden Elemente in umgekehrter Reihenfolge\n\n\n\nÂ \n(Beispiele von Greg Hewgill unter der Lizenz CC BY-SA 4.0 verfÃ¼gbar auf stackoverflow. 2009)\n\n\n\nZeichenfolgen\nAuch aus Zeichenfolgen kÃ¶nnen mit dem Slice Operator Ausschnitte ausgewÃ¤hlt werden.\n\nprint('Ich bin ein string'[::2])\nprint('Hallo Welt'[0:6])\nprint('abc'[::-1])\n\nIhbnensrn\nHallo \ncba\n\n\n\n\n\nListenmethoden\nFÃ¼r den Listentyp sind verschiedene Methoden definiert.\n\nElemente bestimmen\n\nlist.index(x, start, stop) gibt die Indexposition des ersten Elements x aus. Die optionalen Argumente start und stop erlauben es, den Suchbereich einzuschrÃ¤nken.\nlist.count(x) gibt die HÃ¤ufigkeit von x in der Liste aus.\nlist.reverse() kehrt die Reihenfolge der Listenelemente um (die Liste wird dadurch verÃ¤ndert!).\nlist.sort(reverse = False) sortiert die Liste, mit dem optionalen Argument reverse = True absteigend (die Liste wird dadurch verÃ¤ndert!). Die Datentypen innerhalb der Liste mÃ¼ssen sortierbar sein (d.Â h. alle Elemente sind numerisch oder Zeichen).\n\n\nprint(liste1)\n\nliste1.reverse()\nprint(liste1)\n\n# True wird als 1 gezÃ¤hlt\nprint(\"True wird als 1 gezÃ¤hlt:\", liste1.index(1), liste1.count(1))\n\n[1, 'xy', True, 'abc']\n['abc', True, 'xy', 1]\nTrue wird als 1 gezÃ¤hlt: 1 2\n\n\n\n\nElemente einfÃ¼gen\n\nlist.append(x) hÃ¤ngt ein einzelnes Element an das Ende der Liste an.\nlist.extend(sammeltyp) hÃ¤ngt alle mit sammeltyp Ã¼bergebenen Elemente an das Ende der Liste an. Der Sammeltyp kann eine Liste, ein Tupel, eine Menge oder ein Dictionary sein.\nlist.insert(i, x) fÃ¼gt an der Position i Element x ein.\n\n\nprint(liste1, \"\\n\")\n\nliste1.append('Hallo')\nliste1.extend(['Hallo', 'Welt!'])\nliste1.insert(2, '12345')\n\nprint(liste1)\n\n['abc', True, 'xy', 1] \n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Hallo', 'Welt!']\n\n\n\n\nElemente entfernen\n\nlist.remove(x) entfernt das erste Element x in der Liste und gibt einen ValueError zurÃ¼ck, wenn x nicht in der Liste enthalten ist.\nliste.pop(i) entfernt das Element an der Indexposition i. Wird kein Index angegeben, wird das letzte Element entfernt. Die Methode liste.pop(i) gibt die entfernten Elemente zurÃ¼ck.\nliste.clear() entfernt alle Elemente einer Liste.\n\n\nliste1.remove('Hallo')\nprint(liste1)\n\nliste1.pop(2)\n\n['abc', True, '12345', 'xy', 1, 'Hallo', 'Welt!']\n\n\n'12345'\n\n\n\n\nListen und Listenelemente kopieren\nIn Python enthalten Listen Daten nicht direkt, sondern bestehen aus Zeigern auf die Speicherorte der enthaltenen Elemente. Wird eine Liste durch Zuweisung einer anderen Liste angelegt, dann werden nicht die Elemente der Liste kopiert, sondern beide Listen greifen dann auf den selben Speicherort zu.\n\n# Kopieren durch Zuweisung\nliste1 = [1, 'xy', True, text_variable]\nprint(\"liste1:\", liste1, \"\\n\")\nliste2 = liste1\n\n## Ã„ndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"Auch liste1 hat sich durch die Zuweisung in liste2 verÃ¤ndert:\", liste1, \"\\n\")\n\nliste1: [1, 'xy', True, 'abc'] \n\nAuch liste1 hat sich durch die Zuweisung in liste2 verÃ¤ndert: ['ABC', 'xy', True, 'abc'] \n\n\n\nUm eine Liste zu kopieren und ein neues Objekt im Speicher anzulegen, kann die Methode liste.copy() verwendet werden. Auch durch die Verwendung des Zugriffsoperators [:] wird eine neue Liste im Speicher angelegt.\n\n# Verwendung der Methode liste.copy()\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1.copy()\n\n## Ã„ndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unverÃ¤ndert:\", liste1, \"\\n\")\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[:]\n\n## Ã„ndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unverÃ¤ndert:\", liste1)\n\nliste1 bleibt durch die Zuweisung in liste2 unverÃ¤ndert: [1, 'xy', True, 'abc'] \n\nliste1 bleibt durch die Zuweisung in liste2 unverÃ¤ndert: [1, 'xy', True, 'abc']\n\n\nDie Kopie von Listenelementen ist in dieser Hinsicht unproblematisch.\n\n# Verwendung des Slice Operators\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1[0:2]\n\n# Ã„ndern eines Elements in liste2\nliste2[0] = 'ABC'\nprint(\"liste1 bleibt durch die Zuweisung in liste2 unverÃ¤ndert:\", liste1)\n\nliste1 bleibt durch die Zuweisung in liste2 unverÃ¤ndert: [1, 'xy', True, 'abc']\n\n\nUm zu Ã¼berprÃ¼fen, ob sich zwei Objekte den Speicherbereich teilen, kann die Objekt-ID mit der Funktion id() verglichen oder die Operatoren is bzw. is not verwendet werden, die die Funktion id() aufrufen.\n\nliste1 = [1, 'xy', True, text_variable]\nliste2 = liste1\n\nprint(\"ID liste1:\", id(liste1))\nprint(\"ID liste2:\", id(liste2))\nprint(\"ID liste1 gleich ID list2:\", liste1 is liste2)\n\nID liste1: 4355438848\nID liste2: 4355438848\nID liste1 gleich ID list2: True\n\n\n\n\n\n\n\n\nIdentitÃ¤t vs.Â Wertgleichheit\n\n\n\n\n\nDer Operator is prÃ¼ft die IdentitÃ¤t zweier Objekte und unterscheidet sich dadurch vom logischen Operator ==, der auf Wertgleichheit prÃ¼ft. Da liste1 und liste2 die gleichen Elemente enthalten, liegen sowohl IdentitÃ¤t und Wertgleichheit vor. Der Unterschied von IdentitÃ¤t und Wertgleichheit kann anhand eines Werts verdeutlicht werden (Im Code-Beispiel wird eine Syntax-Warnung unterdrÃ¼ckt.).\n\n# Wertgleichheit\nprint(1 == 1.0)\nprint(liste1 == liste2, \"\\n\")\n\n# IdentitÃ¤t\nprint(1 is 1.0)\nprint(liste1 is liste2)\n\nTrue\nTrue \n\nFalse\nTrue\n\n\n\n\n\n\n\n\nAufgaben Listen\n\nErstellen Sie eine Liste â€˜wochentageâ€™, die die sieben Tage der Woche enthÃ¤lt. Verwenden Sie den Slice-Operator, um eine neue Liste â€˜wochenendeâ€™ mit den Tagen des Wochenendes zu erstellen. Entfernen Sie die Tage des Wochenendes aus der Liste â€˜wochentageâ€™.\n4-Tage-Woche: Verwenden Sie Listenmethoden, um den Freitag aus der Liste â€˜wochentageâ€™ zu entfernen und der Liste â€˜wochenendeâ€™ vor dem Samstag hinzuzufÃ¼gen.\nBestimmen Sie in der Liste zahlen = [34, 12, 0, 67, 23] die Position des Werts 0. Entfernen Sie den Wert aus der Liste und geben Sie die Liste aufsteigend sortiert aus.\nGeben Sie nun mit Hilfe des Zugriffsoperators [] die Indexpositionen 1 und 3 der sortierten Liste â€˜zahlenâ€™ aus.\n\nMusterlÃ¶sung kann Marc machen.\n\n\n\n\n\n\nTippÂ 5.1: MusterlÃ¶sung",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#tupel",
    "href": "skript/sammeltypen.html#tupel",
    "title": "5Â  Sammeltypen",
    "section": "5.2 Tupel",
    "text": "5.2 Tupel\nTupel sind Listen sehr Ã¤hnlich, jedoch sind Tupel unverÃ¤nderbare Datenobjekte. Das heiÃŸt, die Elemente eines angelegten Tupels kÃ¶nnen weder geÃ¤ndert, noch entfernt werden. Auch kÃ¶nnen keine neuen Elemente zum Tupel hinzugefÃ¼gt werden.\nTupel werdem mit runden Klammern () erzeugt, die Elemente werden mit einem Komma , getrennt. Ein Tupel mit einem Wert wird mit einem Komma in der Form (wert, ) angelegt. Der Zugriff auf die Elemente eines Tupels ist mit dem Slice-Operator [start:stop:step] mÃ¶glich. Tupel kÃ¶nnen mit den Operatoren + und * verkettet werden.\n\ntupel1 = (2, 7.8, 'Feuer', True, text_variable)\ntupel2 = (1, )\n\nprint(tupel1)\nprint(tupel1[2:4])\nprint(tupel1[::2])\nprint(tupel1[-1])\nprint(tupel1[2:4] + tupel2)\nprint(3 * tupel2)\n\n(2, 7.8, 'Feuer', True, 'abc')\n('Feuer', True)\n(2, 'Feuer', 'abc')\nabc\n('Feuer', True, 1)\n(1, 1, 1)\n\n\n\nTupel kopieren\nTupel verhalten sich beim Kopieren gegensÃ¤tzlich zu Listen. FÃ¼r Tupel ist die Methode .copy() nicht definiert. Dagegen bewirkt die Kopie mittels dem Zugriffsoperator [:] zwar, dass zwei Tupel auf den selben Speicherplatz zugreifen. Bei der Neuzuweisung eines Tupels legt Python, wie fÃ¼r jedes Objekt, ein neues Objekt im Speicher an.\n\n# Kopieren durch Zuweisung\ntupel1 = (1, 2, 3)\ntupel2 = tupel1\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(f\"Die in tupel2 gespeicherten Werte sind unverÃ¤ndert:\\n{tupel1} {tupel2}\\n\")\n\n# Kopieren mit Slice Operator\ntupel1 = (1, 2, 3)\ntupel2 = tupel1[:]\nprint(tupel2 is tupel1)\n\n## Neuzuweisung der Werte von tupel1\ntupel1 = (4, 5, 6)\nprint(tupel1, tupel2)\n\nDie in tupel2 gespeicherten Werte sind unverÃ¤ndert:\n(4, 5, 6) (1, 2, 3)\n\nTrue\n(4, 5, 6) (1, 2, 3)",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#mengen",
    "href": "skript/sammeltypen.html#mengen",
    "title": "5Â  Sammeltypen",
    "section": "5.3 Mengen",
    "text": "5.3 Mengen\nIn Python kÃ¶nnen Mengen mit der set() Funktion z. B. aus einer Liste oder aus einem Tupel erzeugt oder durch geschweiften Klammern {} erstellt werden (eine leere Menge kann nur mit set() erzeugt werden, da {} ein leeres Dictionary anlegt). Mengen sind ungeordnete Sammelung, dementsprechend haben die Elemente keine Reihenfolge.\n\nliste = [1, 1, 5, 3, 3, 4, 2, 'a', 123, 1000, ('tupel', 5)]\nprint(\"Das Objekt liste als Menge:\\n\", set(liste))\n\nmenge = {1, 2, 3, 4, 5, 1000, ('tupel', 5), 'a', 123}\nprint(\"Die Menge kann auch mit geschweiften Klammern erzeugt werden:\", menge)\n\nDas Objekt liste als Menge:\n {1, 2, 3, 4, 5, ('tupel', 5), 1000, 'a', 123}\nDie Menge kann auch mit geschweiften Klammern erzeugt werden: {1, 2, 3, 4, 5, ('tupel', 5), 1000, 'a', 123}\n\n\nMengen kÃ¶nnen beispielsweise fÃ¼r Vergleichsoperationen verwendet werden.\n\nmenge_a = set('Python')\nmenge_b = set('ist super')\n\n# einzigartige Zeichen in a\nprint(\"Menge a:\", menge_a)\n\n# Zeichen in a, aber nicht in b\nprint(\"Menge a - b:\", menge_a - menge_b)\n\n# Zeichen in a oder b\nprint(\"Menge a | b:\", menge_a | menge_b)\n\n# Zeichen in a und b\nprint(\"Menge a & b:\", menge_a & menge_b)\n\n# Zeichen in a oder b, aber nicht in beiden (XOR)\nprint(\"Menge a ^ b:\", menge_a ^ menge_b)\n\nMenge a: {'y', 't', 'o', 'n', 'h', 'P'}\nMenge a - b: {'y', 'o', 'n', 'h', 'P'}\nMenge a | b: {'y', 's', 't', 'u', 'o', 'n', 'p', ' ', 'h', 'e', 'i', 'r', 'P'}\nMenge a & b: {'t'}\nMenge a ^ b: {'s', 'y', 'u', 'o', 'n', 'p', 'r', 'h', 'e', 'i', ' ', 'P'}\n\n\n\nMengen kopieren\nMengen verhalten sich wie Tupel mit dem Unterschied, dass die Methode .copy() fÃ¼r Mengen definiert ist. Allerdings kann der Zugriffsoperator [] nicht auf Mengen angewendet werden.\n\n# Kopieren durch Zuweisung\nset1 = {1, 2, 3}\nset2 = set1\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unverÃ¤ndert:\\n{set1} {set2}\")\n\n# Kopieren durch Methode .copy()\nset1 = {1, 2, 3}\nset2 = set1.copy()\nprint(set1 is set2)\n\n## Neuzuweisen von set1\nset1 = {4, 5, 6}\nprint(f\"Die in set2 gespeicherten Werte sind unverÃ¤ndert:\\n{set1} {set2}\")\n\nTrue\nDie in set2 gespeicherten Werte sind unverÃ¤ndert:\n{4, 5, 6} {1, 2, 3}\nFalse\nDie in set2 gespeicherten Werte sind unverÃ¤ndert:\n{4, 5, 6} {1, 2, 3}",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#dictionaries",
    "href": "skript/sammeltypen.html#dictionaries",
    "title": "5Â  Sammeltypen",
    "section": "5.4 Dictionaries",
    "text": "5.4 Dictionaries\nDictionaries bestehen aus SchlÃ¼ssel-Wert-Paaren. Die SchlÃ¼ssel kÃ¶nnen Zahlen oder Zeichenketten sein, jeder SchlÃ¼ssel darf nur einmal vorkommen. Dictionaries werden mit geschweiften Klammern {} definiert. Die SchlÃ¼ssel und deren zugehÃ¶rigen Werte werden mit einem Doppelpunkt : getrennt. Der Zugriff auf die Werte erfolgt mit dem Zugriffsoperator [], welcher den oder die SchlÃ¼ssel beinhaltet. Ein Zugriff Ã¼ber die Indexposition der SchlÃ¼ssel ist nicht mÃ¶glich, da Zahlen als SchlÃ¼ssel interpretiert werden.\n\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nprint(dictionary1, \"\\n\")\n\nprint(\"Werte des SchlÃ¼ssels 1:\", dictionary1[1])\nprint(\"Werte des SchlÃ¼ssels 'b':\",  dictionary1['b'])\n\n{1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nWerte des SchlÃ¼ssels 1: abc\nWerte des SchlÃ¼ssels 'b': [1, 2, 3]\n\n\nAuf die SchlÃ¼ssel eines Dictionaries kann Ã¼ber die Methode dictionary.keys(), auf die Werte mittels der Methode dictionary.values() zugegriffen werden.\n\nprint(\"SchlÃ¼ssel:\", dictionary1.keys(), \"\\n\")\nprint(\"Werte:\", dictionary1.values())\n\nSchlÃ¼ssel: dict_keys([1, 'b', 'c']) \n\nWerte: dict_values(['abc', [1, 2, 3], ('tupel', 5, 6)])\n\n\n\nDictionaries kopieren\nDictionaries verhalten sich beim Kopieren wie Listen, das heiÃŸt beim Kopieren durch Zuweisung teilen sich Dictionaries den Speicherbereich.\n\n# Kopieren durch Zuweisung\nprint(\"dictionary:\", dictionary1, \"\\n\")\ndictionary2 = dictionary1\n\n## Ã„ndern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"Auch dictionary1 hat sich durch die Zuweisung in dictionary2 verÃ¤ndert:\\n\",\n       dictionary1, \"\\n\")\n\n# Verwendung der Methode dictionary.copy()\ndictionary1 = {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\ndictionary2 = dictionary1.copy()\n\n## Ã„ndern eines Elements in dictionary2\ndictionary2[1] = 'ABC'\nprint(\"dictionary1 bleibt durch die Zuweisung in dictionary2 unverÃ¤ndert:\\n\",\n       dictionary1, \"\\n\")\n\ndictionary: {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\nAuch dictionary1 hat sich durch die Zuweisung in dictionary2 verÃ¤ndert:\n {1: 'ABC', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)} \n\ndictionary1 bleibt durch die Zuweisung in dictionary2 unverÃ¤ndert:\n {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#Ã¼bersicht-sammeltypen",
    "href": "skript/sammeltypen.html#Ã¼bersicht-sammeltypen",
    "title": "5Â  Sammeltypen",
    "section": "5.5 Ãœbersicht Sammeltypen",
    "text": "5.5 Ãœbersicht Sammeltypen\n\n\n\n\n\n\n\n\n\n\nMerkmal\nListen\nTupel\nMengen\nDictionary\n\n\n\n\nBeschreibung\nflexible Anzahl von Elementen beliebigen Typs\nElemente beliebigen Typs, unverÃ¤nderlich\nungeordnete Sammlung, jedes Element nur einmal enthalten\nZuordnungstabelle aus SchlÃ¼ssel-Wert-Paaren\n\n\nSpeicherbereich bei Zuweisung geteilt\nja\nja (aber unverÃ¤nderlich)\nja (aber Zugriffsoperator nicht anwendbar)\nja\n\n\nMethode .copy() definiert\nja\nnein\nja\nja\n\n\nSlice-Operator anwendbar\nja\nja\nnein\nja (nach SchlÃ¼ssel)",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#lÃ¶schen-das-schlÃ¼sselwort-del",
    "href": "skript/sammeltypen.html#lÃ¶schen-das-schlÃ¼sselwort-del",
    "title": "5Â  Sammeltypen",
    "section": "5.6 LÃ¶schen: das SchlÃ¼sselwort del",
    "text": "5.6 LÃ¶schen: das SchlÃ¼sselwort del\nUm Sammeltypen, Elemente oder Slices zu lÃ¶schen kann das SchlÃ¼sselwort del verwendet werden.\n\n# LÃ¶schen einer Liste\ndel liste1\n\n# LÃ¶schen eines Indexbereichs aus einer Liste\nprint(\"Liste vor dem LÃ¶schen:\", liste2)\ndel liste2[1:3]\nprint(\"Liste nach dem LÃ¶schen:\", liste2)\n\n# LÃ¶schen eines SchlÃ¼sselworts aus einem Dictionary\nprint(\"Dictionary vor dem LÃ¶schen\", dictionary1)\ndel dictionary1[1]\nprint(\"Dictionary nach dem LÃ¶schen\", dictionary1)\n\nListe vor dem LÃ¶schen: [1, 'xy', True, 'abc']\nListe nach dem LÃ¶schen: [1, 'abc']\nDictionary vor dem LÃ¶schen {1: 'abc', 'b': [1, 2, 3], 'c': ('tupel', 5, 6)}\nDictionary nach dem LÃ¶schen {'b': [1, 2, 3], 'c': ('tupel', 5, 6)}",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#funktionen",
    "href": "skript/sammeltypen.html#funktionen",
    "title": "5Â  Sammeltypen",
    "section": "5.7 Funktionen",
    "text": "5.7 Funktionen\nDie Sammeltypen kÃ¶nnen ineinander umgewandelt werden.\n\ndictionary = {1: 'Kater', 2: 'FÃ¤hre', 3: 'Ricke'}\nprint( (liste := list(dictionary)) )\nprint( (menge := set(liste)) )\nprint( (tupel := tuple(menge)) )\n\n[1, 2, 3]\n{1, 2, 3}\n(1, 2, 3)\n\n\nEinige praktische Funktionen lassen sich auch auf Sammeltypen anwenden:\n\nlen() gibt die Anzahl der Elemente in einem Sammeltyp zurÃ¼ck.\nmin(), max(), sum() gibt das Minimum, Maximum bzw. die Summe eines Sammeltyps zurÃ¼ck (bei Dictionaries wird die Anzahl der SchlÃ¼ssel gezÃ¤hlt).",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#operationen-verwendung-von-schleifen",
    "href": "skript/sammeltypen.html#operationen-verwendung-von-schleifen",
    "title": "5Â  Sammeltypen",
    "section": "5.8 Operationen: Verwendung von Schleifen",
    "text": "5.8 Operationen: Verwendung von Schleifen\nUm arithmetische und logische Operatoren auf die in einem Sammeltyp gespeicherten Elemente anzuwenden, wird eine for-Schleife verwendet. Im folgenden Beispiel wird eine Liste â€˜zahlenâ€™ durchlaufen, die darin gespeicherten Zahlen quadriert und das jeweilige Ergebnis an die Liste â€˜quadratzahlenâ€™ angehÃ¤ngt. Auch wird geprÃ¼ft, ob die quadrierten Zahlen ganzzahlig durch 3 teilbar sind und das PrÃ¼fergebnis in einer Liste â€˜modulo_3â€™ gespeichert.\n\n\n\n\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  quadratzahlen.append(quadratzahl)\n  modulo_3.append(quadratzahl % 3 == 0)\n\nprint(quadratzahlen)\nprint(modulo_3)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n[False, False, True, False, False, True, False, False, True, False]\n\n\n\n\nCode-BlockÂ 5.1",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/sammeltypen.html#aufgaben-sammeltypen",
    "href": "skript/sammeltypen.html#aufgaben-sammeltypen",
    "title": "5Â  Sammeltypen",
    "section": "5.9 Aufgaben Sammeltypen",
    "text": "5.9 Aufgaben Sammeltypen\n\nModifizieren Sie den Programmcode in Code-BlockÂ 5.1 so, dass nur die Quadratzahlen gespeichert werden, die ganzzahlig durch 3 teilbar sind.\nUmrechnung von Geschwindigkeiten Erstellen Sie ein Skript, welches eine Umrechnungstabelle fÃ¼r Geschwindigkeiten erzeugt. Folgende Randbedingungen sollen beachtet werden:\n\n\nDie Umrechnung soll von km/h in m/s erfolgen.\nDer Start- und Endwert soll in km/h frei wÃ¤hlbar sein, wobei beide ganzzahlig sein sollen.\nDie Anzahl der Umrechnungspunkte soll definiert werden kÃ¶nnen und die Zwischenschritte (in km/h) immer als ganze Zahlen ausgegeben werden.\n\nTipp: In Ihrem Skript kÃ¶nnen Sie die Funktion input() verwenden, um Werte per Eingabe zu erfassen.\n\nSortieren: Gegeben ist die Liste meine_liste = list(range(9, 0, -1)). Diese soll mittels for-Schleifen sortiert werden.\n\n\n\n\n\n\n\nTippÂ 5.2: MusterlÃ¶sung Aufgaben Sammeltypen\n\n\n\n\n\n\nGanzzahlig durch 3 teilbare Quadratzahlen\n\n\nzahlen = list(range(1, 11))\n\nquadratzahlen = [] # die Liste muss vor der Schleife angelegt werden\nmodulo_3 = [] # leere Liste vor der Schleife anlegen\n\nfor zahl in zahlen:\n  quadratzahl = zahl ** 2\n  if quadratzahl % 3 == 0:\n    quadratzahlen.append(quadratzahl)\n\nprint(quadratzahlen)\n\n[9, 36, 81]\n\n\n\nUmrechnung von Geschwindigkeiten\n\n\n# Freie Eingabe\n## start = int(input(\"Startwert in Kilometer pro Stunde eingeben.\"))\n## ende = int(input(\"Endwert in Kilometer pro Stunde eingeben.\"))\n## ausgabeschritte =  int(input(\"Anzahl auszugebener Schritte ein geben.\"))\n\n# Fixe Werte fÃ¼r die LÃ¶sung\nstart = 5\nende = 107\nausgabeschritte = 8\n\n# Liste fÃ¼r km erstellen\nschrittweite = (ende - start) / (ausgabeschritte - 1)\nliste_km = []\nfor i in range(ausgabeschritte):\n    liste_km.append(round(start + i * schrittweite))\n\n# Umrechnung\n# meter = 1000 * kilometer\n# Sekunde = Stunde * 60 * 60\nliste_m = []\nfor wert in liste_km:\n    liste_m.append(round((wert * 1000) / (60 * 60), 2))\n\n# Ausgabe\nprint(f\"Schrittweite: {schrittweite:.2f}\")\nprint(\"Kilometer pro Stunde\")\nprint(liste_km)\nprint(\"Meter pro Sekunde\")\nprint(liste_m)\n\nSchrittweite: 14.57\nKilometer pro Stunde\n[5, 20, 34, 49, 63, 78, 92, 107]\nMeter pro Sekunde\n[1.39, 5.56, 9.44, 13.61, 17.5, 21.67, 25.56, 29.72]\n\n\n\nSortieren: Bubble Sort Algorithmus\n\n\n# statische Liste, Textausgabe\nmeine_liste = list(range(9, 0, -1))\n\nif len(meine_liste) &gt; 1: \n\n    print(\"Liste zu Beginn\\t\\t  :\", meine_liste)\n\n    # Ã¤uÃŸere Schleife\n    Schritt = 0\n    for i in range(len(meine_liste) - 1):\n\n    # innere Schleife\n        for j in range(len(meine_liste) - 1):\n            if meine_liste[j] &gt; meine_liste[j + 1]:\n                meine_liste[j], meine_liste[j + 1] = meine_liste[j + 1], meine_liste[j]\n\n        Schritt += 1\n        print(\"Liste nach Schritt \", Schritt, \":\", meine_liste)\n\n    print(\"\\nListe sortiert:\", *meine_liste) # * unterdrÃ¼ckt die Kommas zwischen den Listenelementen\n\nelse:\n    print(\"Die Liste muss mindenstens zwei Elemente enthalten!\")\n\nListe zu Beginn       : [9, 8, 7, 6, 5, 4, 3, 2, 1]\nListe nach Schritt  1 : [8, 7, 6, 5, 4, 3, 2, 1, 9]\nListe nach Schritt  2 : [7, 6, 5, 4, 3, 2, 1, 8, 9]\nListe nach Schritt  3 : [6, 5, 4, 3, 2, 1, 7, 8, 9]\nListe nach Schritt  4 : [5, 4, 3, 2, 1, 6, 7, 8, 9]\nListe nach Schritt  5 : [4, 3, 2, 1, 5, 6, 7, 8, 9]\nListe nach Schritt  6 : [3, 2, 1, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  7 : [2, 1, 3, 4, 5, 6, 7, 8, 9]\nListe nach Schritt  8 : [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nListe sortiert: 1 2 3 4 5 6 7 8 9\n\n\n\n\n\nÂ \n(Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. â€Datenanalyse mit Python. Schleifen und Abzweigungen.â€œ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Sammeltypen</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html",
    "href": "skript/funktionen-definieren.html",
    "title": "6Â  Eigene Funktionen definieren",
    "section": "",
    "text": "6.1 Syntax\nDas Definieren eigener Funktionen erÃ¶ffnet vielfÃ¤ltige MÃ¶glichkeiten in Python:\nDas SchlÃ¼sselwort def leitet die Funktionsdefinition ein. Es wird gefolgt vom Funktionsnamen und den Funktionsparametern, welche in runden Klammern () eingeschlossen sind. Der Funktionskopf wird mit einem Doppelpunkt : beendet. Der Anweisungsblock der Funktion ist eingerÃ¼ckt. Jede Funktion liefert einen RÃ¼ckgabewert, welche durch das SchlÃ¼sselwort return an die aufrufende Stelle zurÃ¼ckgegeben wird. return beendet die AusfÃ¼hrung der Schleife, auch wenn es nicht am Ende des Anweisungsblocks steht.\ndef Funktionsname(Parameter1, Parameter2):\n    Anweisungsblock\n    return RÃ¼ckgabewert\nDamit die Funktion ausgefÃ¼hrt wird, muss der definierte Funktionsname aufgerufen werden. In der Funktion ist nach dem SchlÃ¼sselwort return eine weitere Anweisung enthalten, die nicht mehr ausgefÃ¼hrt wird.\n# Beispiel 1: Summe der Quadrate\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b):\n    print('Argument a:', a)\n    print('Argument b:', b)\n    print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n    print(\"Anweisungen nach dem SchlÃ¼sselwort return werden nicht mehr ausgefÃ¼hrt.\")\n\nprint(sum_quadrate(6, 7))\n\nArgument a: 6\nArgument b: 7\n==================\n85\nDer RÃ¼ckgabewert kann in einer Variablen gespeichert werden.\nergebnis = sum_quadrate(6, 7)\nprint(ergebnis)\n\nArgument a: 6\nArgument b: 7\n==================\n85",
    "crumbs": [
      "<span class='chapter-number'>6</span>Â  <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html#optionale-parameter",
    "href": "skript/funktionen-definieren.html#optionale-parameter",
    "title": "6Â  Eigene Funktionen definieren",
    "section": "6.2 Optionale Parameter",
    "text": "6.2 Optionale Parameter\nMit Hilfe von optionalen Parametern kann die ProgrammausfÃ¼hrung gesteuert werden. Optionale Parameter mÃ¼ssen nach verpflichtend zu Ã¼bergebenen Parametern definiert werden. In diesem Beispiel wird die print-Ausgabe der Funktion mit dem Parameter ausgabe gesteuert.\n\n# Beispiel 2: optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_quadrate(a, b, ausgabe = False):\n    if ausgabe:\n      print('Wert Argument a:', a)\n      print('Wert Argument b:', b)\n      print(18 * '=')\n    summe = a**2 + b**2\n    return summe\n\nprint(sum_quadrate(42, 7), \"\\n\")\nprint(sum_quadrate(42, 7, ausgabe = True))\n\n1813 \n\nWert Argument a: 42\nWert Argument b: 7\n==================\n1813\n\n\nGibt es mehrere optionale Parameter, so erfolgt die Zuweisung von Argumenten positional oder Ã¼ber das SchlÃ¼sselwort.\n\n# Beispiel 3: mehrere optionale Argumente\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return summe\n\n# positionale Ãœbergabe\nprint(sum_potenzen(42, 7, 3, True), \"\\n\")\n\n# Ãœbergabe per SchlÃ¼sselwort\nprint(sum_potenzen(42, 7, ausgabe = True, p = 4))\n\nArgument a: 42\nArgument b: 7\nArgument p: 3\n==================\n74431 \n\nArgument a: 42\nArgument b: 7\nArgument p: 4\n==================\n3114097",
    "crumbs": [
      "<span class='chapter-number'>6</span>Â  <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html#rÃ¼ckgabewerte",
    "href": "skript/funktionen-definieren.html#rÃ¼ckgabewerte",
    "title": "6Â  Eigene Funktionen definieren",
    "section": "6.3 RÃ¼ckgabewert(e)",
    "text": "6.3 RÃ¼ckgabewert(e)\nFunktionen kÃ¶nnen in Python nur einen einzigen RÃ¼ckgabewert haben. Trotzdem kÃ¶nnen mehrere RÃ¼ckgabewerte mit einem Komma getrennt werden. Python gibt diese als Tupel zurÃ¼ck.\n\n# Beispiel 4: mehrere RÃ¼ckgabewerte\n\n# Definition einer Funktion zur Berechnung der Summe der Quadrate von zwei Argumenten\ndef sum_potenzen(a, b, p = 2, ausgabe = False):\n    if ausgabe:\n      print('Argument a:', a)\n      print('Argument b:', b)\n      print('Argument p:', p)\n      print(18 * '=')\n    summe = a**p + b**p\n    return a, b, summe\n\nergebnis = sum_potenzen(2, 7, ausgabe = False, p = 4)\nprint(ergebnis, type(ergebnis))\n\n(2, 7, 2417) &lt;class 'tuple'&gt;\n\n\nMit dem Slice Operator kann ein bestimmter RÃ¼ckgabewert ausgewÃ¤hlt werden.\n\nprint(ergebnis[2])\n\nsumme_potenzen = sum_potenzen(2, 7, ausgabe = False, p = 4)[2]\nprint(summe_potenzen, type(summe_potenzen))\n\n2417\n2417 &lt;class 'int'&gt;",
    "crumbs": [
      "<span class='chapter-number'>6</span>Â  <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/funktionen-definieren.html#aufgaben-funktionen-definieren",
    "href": "skript/funktionen-definieren.html#aufgaben-funktionen-definieren",
    "title": "6Â  Eigene Funktionen definieren",
    "section": "6.4 Aufgaben Funktionen definieren",
    "text": "6.4 Aufgaben Funktionen definieren\n\nPalindrom\nSchreiben Sie eine Funktion is_palindrome(), die prÃ¼ft, ob es sich bei einer Ã¼bergebenen Zeichenkette um ein Palindrom handelt.\n\nHinweis: Ein Palindrom ist eine Zeichenkette, die von vorne und von hinten gelesen gleich bleibt, wie beispielsweise â€˜Annaâ€™, â€˜Ottoâ€™, â€˜Lagerregalâ€™. Palindrome mÃ¼ssen nicht aus Buchstaben bestehen, sie kÃ¶nnen sich auch aus Zahlen oder Buchstaben und Zahlen zusammensetzen wie beispielsweise â€˜345g543â€™.\n\nFibonacci-Zahlenreihe\n\nEntwickeln Sie eine Funktion fibonacci(n), die die ersten n Zahlen der Fibonacci-Reihe generiert und als Liste zurÃ¼ckgibt. Die Fibonacci-Reihe beginnt mit 0 und 1, jede weitere Zahl ist die Summe der beiden vorhergehenden Zahlen.\n\nVerschlÃ¼sselung\n\nBei Geocachen werden oft verschlÃ¼sselte Botschaften als RÃ¤tsel verwendet. Oft wird folgende Logik zur VerschlÃ¼sselung angewendet:\n\nA -&gt; Z\nB -&gt; Y\nC -&gt; X\nâ€¦\n\nSchreiben Sie eine Funktion verschluesseln(str), die einen String als Eingabewert bekommt und einen verschlÃ¼sselten String zurÃ¼ckgibt. Wie kÃ¶nnen Sie einen verschlÃ¼sselten String am einfachsten wieder entschlÃ¼sseln?\n\nTemperaturkonverter\n\nEntwickeln Sie eine Funktion temperatur_umrechnen(wert, von_einheit, nach_einheit), die eine Temperatur von einer Einheit in eine andere umwandelt. Die Funktion soll folgende Parameter verwenden:\n\nwert: Der Temperaturwert, der umgewandelt werden soll.\nvon_einheit / nach_einheit: Die Einheit des Ausgangs- bzw. des Zielwerts als string. MÃ¶gliche Werte sind â€˜Câ€™ fÃ¼r Celsius, â€˜Fâ€™ fÃ¼r Fahrenheit und â€˜Kâ€™ fÃ¼r Kelvin.\n\nEs gelten die folgenden Umrechnungsformeln zwischen den Einheiten:\n\nCelsius nach Fahrenheit: F = C * 9/5 + 32\nFahrenheit nach Celsius: C = (F - 32) * 5/9\nCelsius nach Kelvin: K = C + 273.15\nKelvin nach Celsius: C = K - 273.15\nFahrenheit nach Kelvin: K = (F - 32) * 5/9 + 273.15\nKelvin nach Fahrenheit: F = (K - 273.15) * 9/5 + 32\n\nDie MusterlÃ¶sung kann Marc machen\n\n\n\n\n\n\nMusterlÃ¶sung Aufgaben Funktionen definieren\n\n\n\n\n\n\n\n\n\nÂ  (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. â€Datenanalyse mit Python. Funktionen Module Dateien.â€œ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>6</span>Â  <span class='chapter-title'>Eigene Funktionen definieren</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html",
    "href": "skript/dateien-lesen-und-schreiben.html",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "",
    "text": "7.1 Dateiobjekte\nMaya und Hans haben je sechs Mal einen WÃ¼rfel geworfen und ihre Wurfergebnisse in einer .txt-Datei protokolliert. Wir wollen mit die Dateien mit Python auswerten, um zu bestimmen, wer von beiden in Summe die hÃ¶chste Augenzahl erreicht hat.\nUm mit Python auf eine Datei zuzugreifen, muss diese fÃ¼rs Lesen oder Schreiben geÃ¶ffnet werden. Dazu wird in Python die Funktion open verwendet. Diese nimmt zwei Argumente, den Pfad der Datei und den Zugriffsmodus, an und liefert ein Dateiobjekt zurÃ¼ck. Aus dem Dateiobjekt werden dann die Inhalte der Datei ausgelesen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#dateiobjekte",
    "href": "skript/dateien-lesen-und-schreiben.html#dateiobjekte",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "",
    "text": "Dateipfad\nDer lokale Dateipfad wird ausgehend vom aktuellen Arbeitsverzeichnis angegeben.\n\npfad_maya = \"01-daten/dice-maya.txt\"\npfad_hans = \"01-daten/dice-hans.txt\"\n\n\n\n\n\n\n\nTippÂ 7.1: Arbeitsverzeichnis in Python ermitteln und wechseln\n\n\n\n\n\nDer Pfad des aktuellen Arbeitsverzeichnisses kann mit dem Modul os mittels os.getcwd() ermittelt werden (hier ohne Ausgabe). Mit os.chdir('neuer_pfad') kann das Arbeitsverzeichnis ggf. gewechselt werden. Die korrekte Formatierung des Pfads erkennen Sie an der Ausgabe von os.getcwd().\n\nimport os\nprint(os.getcwd())\n\nDas Importieren von Modulen wird in einem spÃ¤teren Kapitel behandelt.\n\n\n\n\n\nZugriffsmodus\nAls Zugriffsmodus stehen unter anderem folgende Optionen zur VerfÃ¼gung:\n\n\n\n\n\n\n\nModus\nBeschreibung\n\n\n\n\nr\nlesender Zugriff\n\n\nw\nSchreibzugriff, Datei wird Ã¼berschrieben\n\n\nx\nErzeugt die Datei, Fehlermeldung, wenn die Datei bereits existiert\n\n\na\nSchreibzugriff, Inhalte werden angehÃ¤ngt\n\n\nb\nBinÃ¤rmodus (z. B. fÃ¼r Grafiken)\n\n\nt\nTextmodus, default\n\n\n\nÂ \nDie Zugriffsmodi kÃ¶nnen auch kombiniert werden. Weitere Informationen dazu finden Sie in der Dokumentation. Sofern nicht im BinÃ¤rmodus auf Dateien zugegriffen wird, liefert die Funktion open() den Dateiinhalt als string zurÃ¼ck.\nIm Lesemodus wird ein Datenobjekt erzeugt.\n\ndaten_maya = open(pfad_maya, mode = 'r')\nprint(daten_maya)\n\n&lt;_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'&gt;\n\n\nWenn das Datenobjekt daten_maya der Funktion print() Ã¼bergeben wird, gibt Python die Klasse des Objekts zurÃ¼ck, in diesem Fall also _io.TextIOWrapper. Diese Klasse stammt aus dem Modul io und ist fÃ¼r das Lesen und Schreiben von Textdateien zustÃ¤ndig. Ebenfalls werden als Attribute des Dateiobjekts der Dateipfad, der Zugriffsmodus und die Enkodierung der Datei ausgegeben (siehe BeispielÂ 7.1). Sollte die Enkodierung nicht automatisch als UTF-8 erkannt werden, kann diese mit dem Argument encoding = 'UTF-8' Ã¼bergeben werden.\n\ndaten_maya = open(pfad_maya, mode = 'r', encoding = 'UTF-8')\nprint(daten_maya)\n\n&lt;_io.TextIOWrapper name='01-daten/dice-maya.txt' mode='r' encoding='UTF-8'&gt;\n\n\n\n\n\n\n\n\nBeispielÂ 7.1: Attribute eines Objekts bestimmen\n\n\n\n\n\nMit der Funktion dir(objekt) kÃ¶nnen die verfÃ¼gbaren Attribute eines Objekts ausgegeben werden. Dabei werden jedoch auch die vererbten Attribute und Methoden der Klasse des Objekts ausgegeben, sodass die Ausgabe oft sehr umfangreich ist. Zum Beispiel fÃ¼r die Ganzzahl 1:\n\nprint(dir(1))\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']\n\n\nUm die Ausgabe auf Attribute einzugrenzen, kann folgende Funktion verwendet werden:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not callable (getattr(objekt, attr))]\nprint(attribute)\n\n['__doc__', 'denominator', 'imag', 'numerator', 'real']\n\n\nMit doppelten Unterstrichen umschlossene Attribute sind fÃ¼r Python reserviert und nicht fÃ¼r den:die Nutzer:in gedacht. Folgende Funktion entfernt Attribute mit doppelten Unterstrichen aus der Ausgabe:\n\nobjekt = 1\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n\n['denominator', 'imag', 'numerator', 'real']\n\n\nIm Fall einer Ganzzahl kÃ¶nnen Attribute (zur Abgrenzung von Gleitkommazahlen in umschlieÃŸenden Klammern) wie folgt aufgerufen werden:\n\n(1).numerator\n\n1\n\n\nWenn wir uns die Attribute des Dateiobjekts â€˜daten_mayaâ€™ ansehen, fallen Attribute mit einem einzelnen fÃ¼hrenden Unterstrich auf.\n\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('__'))]\nprint(attribute)\n\n['_CHUNK_SIZE', '_finalizing', 'buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n\n\nHierbei handelt es sich um Attribute, die nicht durch den:die Nutzer:in aufgerufen werden sollen (weitere Informationen dazu finden Sie hier). Folgender Programmcode gibt alle Attribute ohne fÃ¼hrende Unterstriche aus:\n\nobjekt = daten_maya\n\nattribute = [attr for attr in dir(objekt) if not (callable(getattr(objekt, attr)) or attr.startswith('_'))]\nprint(attribute)\n\n['buffer', 'closed', 'encoding', 'errors', 'line_buffering', 'mode', 'name', 'newlines', 'write_through']\n\n\n\n\n\nDie Attribute der Datei kÃ¶nnen mit entsprechenden Befehlen abgerufen werden.\n\nprint(f\"Dateipfad: {daten_maya.name}\\n\"\n      f\"Dateiname: {os.path.basename(daten_maya.name)}\\n\"\n      f\"Datei ist geschlossen: {daten_maya.closed}\\n\"\n      f\"Zugriffsmodus: {daten_maya.mode}\"\n      f\"Enkodierung: : {daten_maya.encoding}\")\n\nDateipfad: 01-daten/dice-maya.txt\nDateiname: dice-maya.txt\nDatei ist geschlossen: False\nZugriffsmodus: rEnkodierung: : UTF-8\n\n\n\n\n\n\n\n\nTippÂ 7.2: RÃ¼ckfalloption\n\n\n\n\n\nIn der Datenanalyse werden in der Regel spezialisierte Pakete wie NumPy oder Pandas verwendet. Diese vereinfachen das Einlesen von Dateien gegenÃ¼ber der Pythonbasis erheblich. Dennoch ist es sinnvoll, sich mit den Methoden der Pythonbasis zum Einlesen von Dateien vertraut zu machen. Denn das Einlesen mit der Funktion open() klappt so gut wie immer - es ist eine gute RÃ¼ckfalloption.\n\n\n\n\n\nDateiinhalt ausgeben\nUm den Dateiinhalt auszugeben, kann das Datenobjekt mit einer Schleife zeilenweise durchlaufen und ausgegeben werden. (Die Datei dice-maya hat nur eine Zeile.)\n\ni = 0\nfor zeile in daten_maya:\n    print(f\"Inhalt Zeile {i}, mit {len(zeile)} Zeichen:\")\n    print(zeile)\n    i += 1\n\nInhalt Zeile 0, mit 28 Zeichen:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nDies ist jedoch fÃ¼r grÃ¶ÃŸere Dateien nicht sonderlich praktikabel. Die Ausgabe einzelner Zeilen mit der Funktion print() kann aber nÃ¼tzlich sein, um die genaue Formatierung der Zeichenkette zu prÃ¼fen. In diesem Fall hat Maya ihre Daten in AnfÃ¼hrungszeichen gesetzt und mit einem Komma voneinander getrennt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#dateien-einlesen",
    "href": "skript/dateien-lesen-und-schreiben.html#dateien-einlesen",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.2 Dateien einlesen",
    "text": "7.2 Dateien einlesen\nUm den gesamten Inhalt einer Datei einzulesen, kann die Methode datenobjekt.read() verwendet werden. Die Methode hat als optionalen Parameter .read(size). size wird als Ganzzahl Ã¼bergeben und entsprechend viele Zeichen (im BinÃ¤rmodus entsprechend viele Bytes) werden ggf. bis zum Dateiende ausgelesen. Der Parameter size ist nÃ¼tzlich, um die Formatierung des Inhalts einer groÃŸen Datei zu prÃ¼fen und dabei die Ausgabe auf eine Ã¼berschaubare Anzahl von Zeichen zu begrenzen.\n\naugen_maya = daten_maya.read()\n\nprint(f\"len(augen_maya): {len(augen_maya)}\\n\\n\"\n      f\"Inhalt der Datei augen_maya:\\n{augen_maya}\")\n\nlen(augen_maya): 0\n\nInhalt der Datei augen_maya:\n\n\n\nDas hat offensichtlich nicht geklappt, der ausgelesene Dateiinhalt ist leer! Der Grund dafÃ¼r ist, dass beim Lesen (und beim Schreiben) einer Datei der Dateizeiger die Datei durchlÃ¤uft. Nachdem die Datei daten_maya in Kapitel 7.1.3 zeilenweise ausgegeben wurde, steht der Dateizeiger am Ende der Datei.\n\n\n\n\n\n\nHinweisÂ 7.1: Dateizeiger in Python\n\n\n\nWird eine Datei zeilenweise oder mit der Methode .read() ausgelesen, wird der Dateizeiger um die angegebene Zeichenzahl bzw. bis ans Ende der Datei bewegt. Wird beispielsweise ein Datensatz â€˜datenâ€™ geÃ¶ffnet und mit der Methode daten.read(3) die ersten drei Zeichen ausgelesen, bewegt sich der Dateizeiger von der Indexposition 0 zur Indexposition 3 (bzw. steht jeweils davor).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildungÂ 7.1: Bewegung des Dateizeigers beim Auslesen von drei Zeichen\n\n\n\nDie Methode daten.tell() gibt zurÃ¼ck, an welcher Position sich der Dateizeiger befindet.\nMit der Methode daten.seek(offset, whence = 0) wird der Zeiger an eine bestimmte Position gesetzt. Die Methode akzeptiert das Argument offset (Versatz) und das optionale Argument whence (woher), dessen Standardwert 0 (Dateianfang) ist. FÃ¼r Zugriffe im BinÃ¤rmodus (open(pfad, mode = 'rb')) kann das Argument whence auÃŸerdem die Werte 1 (aktuelle Position) oder 2 (Dateiende) annehmen.\n\ndaten.seek(0, 0) bezeichnet den Dateianfang\ndaten.seek(0, 1) bezeichnet die aktuelle Position in der Datei\ndaten.seek(0, 2) bezeichnet das Dateiende\ndaten.seek(-3, 2) bezeichnet das dritte Zeichen vor dem Dateiende\n\n\n\nWird der Dateizeiger mit der Methode datenobjekt.seek(0) an den Dateianfang gestellt, gelingt das Auslesen der Datei.\n\nprint(f\"Position des Dateizeigers vor dem ZurÃ¼cksetzen auf 0: {daten_maya.tell()}\")\n\ndaten_maya.seek(0);\nprint(f\"Position des Dateizeigers nach dem ZurÃ¼cksetzen auf 0: {daten_maya.tell()}\")\n\naugen_maya = daten_maya.read()\n\nprint(f\"Inhalt des Objekts augen_maya:\\n{augen_maya}\")\n\nPosition des Dateizeigers vor dem ZurÃ¼cksetzen auf 0: 28\nPosition des Dateizeigers nach dem ZurÃ¼cksetzen auf 0: 0\nInhalt des Objekts augen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\n\nGeben Sie aus dem Datenobjekt daten_maya mit den Methoden .seek() und .read() die Zahlen and zweiter und dritter Stelle, also 6 und 2, aus.\n\n\n\n\n\n\nTippÂ 7.3: MusterlÃ¶sung Dateizeiger bewegen\n\n\n\n\n\n\ndaten_maya.seek(6, 0);\nprint(daten_maya.read(1))\n\ndaten_maya.seek(daten_maya.tell() + 4, 0);\nprint(daten_maya.read(1))\n\n6\n2\n\n\n\n\n\nUm Mayas WÃ¼rfelergebnisse zu addieren, mÃ¼ssen die Zahlen extrahiert und in Ganzzahlen umgewandelt werden, da im Textmodus stets eine Zeichenfolge zurÃ¼ckgegeben wird.\n\nprint(type(augen_maya))\n\n&lt;class 'str'&gt;\n\n\nDazu werden mit der Methode str.strip(\") das fÃ¼hrende und abschlieÃŸende AnfÃ¼hrungszeichen entfernt sowie anschlieÃŸend mit der Methode str.split('\", \"') die Zeichenfolge Ã¼ber das Trennzeichen in eine Liste aufgeteilt. AnschlieÃŸend werden die Listenelemente in Ganzzahlen umgewandelt und summiert. (Methoden der string-Bearbeitung werden im nÃ¤chsten Abschnitt ausfÃ¼hrlich behandelt.)\n\nprint(f\"augen_maya:\\n{augen_maya}\")\n\naugen_maya = augen_maya.strip('\"')\nprint(f\"\\naugen_maya.strip('\\\"'):\\n{augen_maya}\")\n\naugen_maya = augen_maya.split('\", \"')\nprint(f\"\\naugen_maya.split('\\\", \\\"'):\\n{augen_maya}\")\n\naugen_maya_int = []\nfor i in augen_maya:\n  augen_maya_int.append(int(i))\n\nprint(f\"\\naugen_maya_int:\\n{augen_maya_int}\\n\\nSumme Augen: {sum(augen_maya_int)}\")\n\naugen_maya:\n\"5\", \"6\", \"2\", \"1\", \"4\", \"5\"\n\naugen_maya.strip('\"'):\n5\", \"6\", \"2\", \"1\", \"4\", \"5\n\naugen_maya.split('\", \"'):\n['5', '6', '2', '1', '4', '5']\n\naugen_maya_int:\n[5, 6, 2, 1, 4, 5]\n\nSumme Augen: 23\n\n\n\nDatei schlieÃŸen\nNach dem Zugriff auf die Datei, muss diese wieder geschlossen werden, um diese fÃ¼r andere Programme freizugeben.\n\ndaten_maya.close()\n\n\n\n\n\n\n\nHinweisÂ 7.2: Schreiboperationen mit Python\n\n\n\nDas SchlieÃŸen einer Datei ist besonders fÃ¼r Schreiboperationen auf Datenobjekten wichtig. Andernfalls kann es passieren, dass Inhalte mit datenobjekt.write() nicht vollstÃ¤ndig auf den DatentrÃ¤ger geschrieben werden. Siehe dazu die Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-einlesen",
    "href": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-einlesen",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.3 Aufgabe Dateien einlesen",
    "text": "7.3 Aufgabe Dateien einlesen\nWelche Augenzahl hat Hans erreicht?\n\n\n\n\n\n\nTippÂ 7.4: MusterlÃ¶sung Augenzahlvergleich\n\n\n\n\n\n\n\n# Erst Einlesen der Datei:\ndaten_hans = open(pfad_hans, mode = 'r', encoding = 'UTF-8')\naugen_hans = daten_hans.read()\nprint(augen_hans)\n# Hier muss man erkennen, dass Hans seinen Namen an den Anfang seiner Liste gesetzt hat. Dieser String muss also entfernt werden, bevor die Summe gebildet werden kann!\n\naugen_hans = augen_hans.strip('\"Hans\", ')\naugen_hans = augen_hans.strip('\"')\naugen_hans = augen_hans.split('\", \"')\nprint(augen_hans)\n# print-Ausgabe zeigt, dass die Liste nun korrekt bereinigt wurde. Sie besteht nur noch aus Integerwerten und diese kÃ¶nnen summiert werden\n\n# Neue (leere) Liste fÃ¼r die WÃ¼rfe von Hans anlegen:\naugen_hans_int = []\nfor i in augen_hans:\n   augen_hans_int.append(int(i))\n\nprint(f\"Summe Augenzahl von Hans: {sum(augen_hans_int)}\")\n\n\"Hans\", \"3\", \"5\", \"1\", \"3\", \"2\", \"5\"\n['3', '5', '1', '3', '2', '5']\nSumme Augenzahl von Hans: 19\n\n\nMusterlÃ¶sung von Marc SÃ¶nnecken.",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#daten-interpretieren",
    "href": "skript/dateien-lesen-und-schreiben.html#daten-interpretieren",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.4 Daten interpretieren",
    "text": "7.4 Daten interpretieren\nDatensÃ¤tze liegen typischerweise wenigstens in zweidimensionaler Form vor, d.Â h. die Daten sind in Zeilen und Spalten organisiert. AuÃŸerdem weisen DatensÃ¤tze in der Regel auch unterschiedliche Datentypen auf. Die Funktion open(datei) gibt ein Dateiobjekt zurÃ¼ck, das mit Methoden wie zum Beispiel dateiobjekt.read() als Zeichenfolge eingelesen wird. Um die Daten sinnvoll weiterverarbeiten zu kÃ¶nnen, ist es deshalb notwendig, die Zeichenfolge korrekt zu interpretieren und Daten von Trennzeichen zu unterscheiden.\nFÃ¼r die Bearbeitung von Zeichenfolgen bietet Python eine Reihe von String-Methoden. Einige davon werden in diesem Kapitel exemplarisch verwendet. String-Methoden werden in der Regel mit einem fÃ¼hrenden â€˜strâ€™ in der Form str.methode() genannt.\nBeispielsweise soll eine Datei mit den Einwohnerzahlen der europÃ¤ischen LÃ¤nder eingelesen werden.\n\n\n\nDaten\nDateiname\n\n\n\n\nEinwohner Europas\neinwohner_europa_2019.csv\n\n\n\nÂ \nUm einen Ãœberblick Ã¼ber den Aufbau der Datei zu erhalten, werden die ersten drei Zeilen der Datei ausgegeben. DafÃ¼r kann die Datei zeilenweise mit einer for-Schleife durchlaufen werden, die mit dem SchlÃ¼sselwort break abgebrochen wird, wenn die Laufvariable den Wert 3 erreicht hat. Eine andere MÃ¶glichkeit ist die Methode dateiobjekt.readline(), die eine einzelne Zeile ausliest. Hier wird die HÃ¤ufigkeit der SchleifenausfÃ¼hrung Ã¼ber die Laufvariable mit for i in range(3): gesteuert.\n\nfor-Schleife mit breakMethode dateiobjekt.readline()\n\n\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# erste 3 Zeilen anschauen\ni = 0\nfor zeile in dateiobjekt_einwohner:\n  \n  print(zeile)\n  i += 1\n  if i == 3:\n    break\n\n# Datei schlieÃŸen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\nMit der Methode dateiobjekt.readline() kann eine einzelne Zeile eingelesen werden.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\nfor i in range(3):\n  print(dateiobjekt_einwohner.readline())\n\n# Datei schlieÃŸen\ndateiobjekt_einwohner.close()\n\nGEO,Value\n\nBelgien,11467923\n\nBulgarien,7000039\n\n\n\n\n\n\nDie Datei hat also zwei Spalten. In der ersten Spalte sind die LÃ¤ndernamen eingetragen, in der zweiten Spalte die Werte. Als Trennzeichen wird das Komma verwendet. In der ersten Zeile sind die Spaltenbeschriftungen eingetragen.\nIm vorherigen Abschnitt haben wir die Methode dateiobjekt.read() kennengelernt, mit der eine Datei vollstÃ¤ndig als string eingelesen wird. ZunÃ¤chst wird die Datei mit der Methode dateiobjekt.read() in das Objekt einwohner eingelesen und wieder geschlossen.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\neinwohner = dateiobjekt_einwohner.read()\nprint(einwohner)\n\n# Datei schlieÃŸen\ndateiobjekt_einwohner.close();\n\nGEO,Value\nBelgien,11467923\nBulgarien,7000039\nTschechien,10528984\nDaenemark,5799763\nDeutschland einschliesslich ehemalige DDR,82940663\nEstland,1324820\nIrland,4904240\nGriechenland,10722287\nSpanien,46934632\nFrankreich,67028048\nKroatien,4076246\nItalien,61068437\nZypern,875898\nLettland,1919968\nLitauen,2794184\nLuxemburg,612179\nUganda,-1\nUngarn,9772756\nMalta,493559\nNiederlande,17423013\nOesterreich,8842000\nPolen,37972812\nPortugal,10276617\nRumaenien,19405156\nSlowenien,2080908\nSlowakei,5450421\nFinnland,5512119\nSchweden,10243000\nVereinigtes Koenigreich,66647112\n\n\n\nAnschlieÃŸend kÃ¶nnen die eingelesenen Daten mit der Methode str.split('\\n') zeilweise aufgeteilt werden. Mit '\\n' wird als Argument der Zeilenumbruch Ã¼bergeben. Die Methode liefert eine Liste zurÃ¼ck.\n\nliste_einwohner_zeilenweise = einwohner.split(\"\\n\")\nprint(liste_einwohner_zeilenweise[0:3])\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039']\n\n\nDie Liste enthÃ¤lt an der Indexposition die Spaltenbeschriftungen. Diese kÃ¶nnen mit der Methode liste.pop(index) aus der Liste entfernt und zugleich in einem neuen Objekt gespeichert werden.\n\nspaltennamen = liste_einwohner_zeilenweise.pop(0)\nspaltennamen = spaltennamen.split(',')\nprint(f\"Ãœberschrift Spalte 0: {spaltennamen[0]}\\tÃœberschrift Spalte 1: {spaltennamen[1]}\")\n\nÃœberschrift Spalte 0: GEO   Ãœberschrift Spalte 1: Value\n\n\nAnschlieÃŸend kann die Liste mit der Methode str.split(',') nach LÃ¤ndern und Werten aufgeteilt werden. Der Vorgang bricht allerdings mit einer Fehlermeldung ab. Die Fehlermeldung wird im folgenden Code-Block per Ausnahmebehandlung abgefangen. Neben der Fehlermeldung werden der verursachende Listeneintrag und dessen Indexposition ausgegeben.\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept Exception as error:\n  # print Fehlermeldung\n  print(f\"Fehlermeldung: {error}\")\n  \n  # print Eintrag und Index\n  print(f\"Eintrag: {eintrag}\\t Zeilenindex: {liste_einwohner_zeilenweise.index(zeile)}\")\n\nFehlermeldung: list index out of range\nEintrag: ['']    Zeilenindex: 29\n\n\nDie Fehlermeldung ist so zu deuten, dass eine der Listenoperationen mit dem Slice Operator einen ungÃ¼ltigen Index anspricht. Leicht angepasst, liefert der Code-Block auch die Ursache der Fehlermeldung.\nWird die leere Zeile aus der Liste entfernt, klappt das Aufteilen der LÃ¤ndernamen und der Werte.\n\n# leere Zeile entfernen\nliste_einwohner_zeilenweise.remove('')\n\n# Leere Listen vor der Schleife anlegen\ngeo = []\neinwohnerzahl = []\n\ntry:\n  for zeile in liste_einwohner_zeilenweise:\n    eintrag = zeile.split(',')\n    geo.append(eintrag[0])\n    einwohnerzahl.append(eintrag[1])\n\n  print(spaltennamen[0])\n  print(geo, \"\\n\")\n\n  print(spaltennamen[1])\n  print(einwohnerzahl)\n\nexcept IndexError as error:\n  print(error)\n\nGEO\n['Belgien', 'Bulgarien', 'Tschechien', 'Daenemark', 'Deutschland einschliesslich ehemalige DDR', 'Estland', 'Irland', 'Griechenland', 'Spanien', 'Frankreich', 'Kroatien', 'Italien', 'Zypern', 'Lettland', 'Litauen', 'Luxemburg', 'Uganda', 'Ungarn', 'Malta', 'Niederlande', 'Oesterreich', 'Polen', 'Portugal', 'Rumaenien', 'Slowenien', 'Slowakei', 'Finnland', 'Schweden', 'Vereinigtes Koenigreich'] \n\nValue\n['11467923', '7000039', '10528984', '5799763', '82940663', '1324820', '4904240', '10722287', '46934632', '67028048', '4076246', '61068437', '875898', '1919968', '2794184', '612179', '-1', '9772756', '493559', '17423013', '8842000', '37972812', '10276617', '19405156', '2080908', '5450421', '5512119', '10243000', '66647112']",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#aufgabe-daten-interpretieren",
    "href": "skript/dateien-lesen-und-schreiben.html#aufgabe-daten-interpretieren",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.5 Aufgabe Daten interpretieren",
    "text": "7.5 Aufgabe Daten interpretieren\n\nBestimmen Sie das Minimum und das Maximum der Einwohnerzahl und die dazugehÃ¶rigen LÃ¤nder.\nBereinigen Sie ggf. fehlerhafte Werte.\nWie viele Einwohner leben in Europa insgesamt?\n\n\nWelchen Datentyp hat die Liste einwohnerzahl?\nWelchen Datentyp haben die EintrÃ¤ge der Liste einwohnerzahl?\n\nDie MusterlÃ¶sung kann Marc machen\n\n\n\n\n\n\nMusterlÃ¶sung vollstÃ¤ndiges Einlesen",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#einlesen-als-liste",
    "href": "skript/dateien-lesen-und-schreiben.html#einlesen-als-liste",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.6 Einlesen als Liste",
    "text": "7.6 Einlesen als Liste\nEin Dateiobjekt kann auch direkt als Liste eingelesen werden. Die Methode dateiobjekt.readlines() gibt eine Liste zurÃ¼ck, in der jede Zeile einen Eintrag darstellt. Ebenso kann die Listenfunktion list() auf Dateiobjekte angewendet werden. Beide Vorgehensweisen liefern die gleiche Liste zurÃ¼ck, in der der Zeilenumbruch \\n mit ausgelesen wird.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\nprint(einwohner)\n\n## Dateizeiger zurÃ¼cksetzen\ndateiobjekt_einwohner.seek(0);\n\n# Funktion list\neinwohner = list(dateiobjekt_einwohner)\nprint(einwohner)\n\n# Datei schlieÃŸen\ndateiobjekt_einwohner.close();\n\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n['GEO,Value\\n', 'Belgien,11467923\\n', 'Bulgarien,7000039\\n', 'Tschechien,10528984\\n', 'Daenemark,5799763\\n', 'Deutschland einschliesslich ehemalige DDR,82940663\\n', 'Estland,1324820\\n', 'Irland,4904240\\n', 'Griechenland,10722287\\n', 'Spanien,46934632\\n', 'Frankreich,67028048\\n', 'Kroatien,4076246\\n', 'Italien,61068437\\n', 'Zypern,875898\\n', 'Lettland,1919968\\n', 'Litauen,2794184\\n', 'Luxemburg,612179\\n', 'Uganda,-1\\n', 'Ungarn,9772756\\n', 'Malta,493559\\n', 'Niederlande,17423013\\n', 'Oesterreich,8842000\\n', 'Polen,37972812\\n', 'Portugal,10276617\\n', 'Rumaenien,19405156\\n', 'Slowenien,2080908\\n', 'Slowakei,5450421\\n', 'Finnland,5512119\\n', 'Schweden,10243000\\n', 'Vereinigtes Koenigreich,66647112\\n']\n\n\nUm den Zeilenumbruch zu entfernen, kÃ¶nnte mit dem Slice Operator das letzte Zeichen jedes Listeneintrags entfernt werden.\nEine andere MÃ¶glichkeit ist die Methode str.replace(old, new, count=-1), mit der Zeichen ersetzt oder gelÃ¶scht werden kÃ¶nnen. Die Parameter old und new geben die zu ersetzende bzw. die einzusetzende Zeichenfolge an und mÃ¼ssen positional Ã¼bergeben werden. Ãœber den Parameter count kann eingestellt werden, wie oft die Zeichenfolge old ersetzt werden soll. StandardmÃ¤ÃŸig wird jedes Vorkommen ersetzt.\n\nprint('Hund'.replace('Hu', 'Mu'))\n\nzeichenfolge = 'Ein  kurzer Text ohne  doppelte Leerzeichen.'\n\nprint(zeichenfolge.replace('  ', ' '))\n\nMund\nEin kurzer Text ohne doppelte Leerzeichen.\n\n\nDie Methode str.replace() kann auch zum LÃ¶schen verwendet werden. Wird fÃ¼r den Parameter new eine leere Zeichenfolge Ã¼bergeben, wird die in old Ã¼bergebene Zeichenfolge gelÃ¶scht.\n\nprint(zeichenfolge.replace(' ', '').replace('doppelte', ''))\n\nEinkurzerTextohneLeerzeichen.\n\n\nMit der Methode str.replace() kann die eingelesene Liste um den Zeilenumbruch bereinigt werden.\n\ndateipfad = \"01-daten/einwohner_europa_2019.csv\"\ndateiobjekt_einwohner = open(dateipfad, 'r')\n\n# Methode readlines\neinwohner = dateiobjekt_einwohner.readlines()\neinwohner_neu = []\n\nfor element in einwohner:\n  einwohner_neu.append(element.replace('\\n', ''))\n\neinwohner = einwohner_neu\nprint(einwohner)\n\n# Datei schlieÃŸen\ndateiobjekt_einwohner.close();\n\n['GEO,Value', 'Belgien,11467923', 'Bulgarien,7000039', 'Tschechien,10528984', 'Daenemark,5799763', 'Deutschland einschliesslich ehemalige DDR,82940663', 'Estland,1324820', 'Irland,4904240', 'Griechenland,10722287', 'Spanien,46934632', 'Frankreich,67028048', 'Kroatien,4076246', 'Italien,61068437', 'Zypern,875898', 'Lettland,1919968', 'Litauen,2794184', 'Luxemburg,612179', 'Uganda,-1', 'Ungarn,9772756', 'Malta,493559', 'Niederlande,17423013', 'Oesterreich,8842000', 'Polen,37972812', 'Portugal,10276617', 'Rumaenien,19405156', 'Slowenien,2080908', 'Slowakei,5450421', 'Finnland,5512119', 'Schweden,10243000', 'Vereinigtes Koenigreich,66647112']",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#dateien-schreiben",
    "href": "skript/dateien-lesen-und-schreiben.html#dateien-schreiben",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.7 Dateien schreiben",
    "text": "7.7 Dateien schreiben\nUm Dateien zu schreiben, mÃ¼ssen diese mit der write-Methode eines Dateiobjekts verwendet werden. Dieser Methode wird als Argument die zu schreibende Zeichenfolge Ã¼bergeben.\n\ndateipfad = \"01-daten/neue_datei.txt\"\n\n# Ã–ffne Datei zum Schreiben Ã¶ffnen\ndatei = open(dateipfad, mode = 'w')\n\n# Inhalt in die Datei schreiben\ndatei.write(\"Prokrastination an Hochschulen\\n\\n\".upper())\ndatei.write(\"KAPITEL 1: Aller Anfang ist schwer\\nPlatzhalter: Den Rest schreibe ich spÃ¤ter.\")\n\n# Datei schlieÃŸen\n\ndatei.close()\n\nDie Datei kann nun ausgelesen werden.\n\ndateiinhalt = open(dateipfad, mode = 'r')\ntext = dateiinhalt.read()\nprint(text)\n\ndateiinhalt.close()\n\nPROKRASTINATION AN HOCHSCHULEN\n\nKAPITEL 1: Aller Anfang ist schwer\nPlatzhalter: Den Rest schreibe ich spÃ¤ter.",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-schreiben",
    "href": "skript/dateien-lesen-und-schreiben.html#aufgabe-dateien-schreiben",
    "title": "7Â  Dateien lesen und schreiben",
    "section": "7.8 Aufgabe Dateien schreiben",
    "text": "7.8 Aufgabe Dateien schreiben\n\nErzeugen Sie eine neue Datei mit der Endung .txt, die den Namen ihrer Heimatstadt hat. Schreiben Sie in diese Datei 10 Zeilen mit Informationen zur Stadt.\n\nÂ  (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. â€Datenanalyse mit Python. Funktionen Module Dateien.â€œ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>7</span>Â  <span class='chapter-title'>Dateien lesen und schreiben</span>"
    ]
  },
  {
    "objectID": "skript/module-und-pakete-importieren.html",
    "href": "skript/module-und-pakete-importieren.html",
    "title": "8Â  Module und Pakete importieren",
    "section": "",
    "text": "8.1 import as\nDer Funktionsumfang von Python kann erheblich durch das Importieren von Modulen und Paketen erweitert werden. Module und Pakete sind Bibliotheken, die Funktionsdefinitionen enthalten.\nModule und Pakete werden mit dem SchlÃ¼sselwort import in Python geladen. Beispielsweise kann das fÃ¼r die Erzeugung (pseudo-)zufÃ¤lliger Zahlen zustÃ¤ndige Modul random mit dem Befehl import random eingebunden werden. AnschlieÃŸend stehen die Funktionen des Moduls unter dem Modulnamen in der Schreibweise modul.funktion() zur VerfÃ¼gung.\nDas Paket Matplotlib bringt viele Funktionen zur grafischen Darstellung von Daten mit. Das Modul matplotlib.pyplot stellt eine Schnittstelle zu den enthaltenen Funktionen dar.\nUm lange Modulnamen zu vereinfachen, kann beim Importieren das SchlÃ¼sselwort as verwendet werden, um dem Modul einen neuen Namen zuzuweisen.\nimport matplotlib.pyplot as plt\n\nplt.plot(zufallsdaten)\n\n\n\n\nGrafik mit dem Modul pyplot aus dem Paket matplotlib\nFÃ¼r hÃ¤ufig verwendete Module haben sich bestimmte KÃ¼rzel etabliert. In den Bausteinen werden hÃ¤ufig die folgenden Pakete und KÃ¼rzel genutzt:",
    "crumbs": [
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  },
  {
    "objectID": "skript/module-und-pakete-importieren.html#import-as",
    "href": "skript/module-und-pakete-importieren.html#import-as",
    "title": "8Â  Module und Pakete importieren",
    "section": "",
    "text": "Modul\nKÃ¼rzel\nBefehl\n\n\n\n\nNumPy\nnp\nimport numpy as np\n\n\nPandas\npd\nimport pandas as pd\n\n\nmatplotlib.pyplot\nplt\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  },
  {
    "objectID": "skript/module-und-pakete-importieren.html#kleine-modulÃ¼bersicht",
    "href": "skript/module-und-pakete-importieren.html#kleine-modulÃ¼bersicht",
    "title": "8Â  Module und Pakete importieren",
    "section": "8.2 Kleine ModulÃ¼bersicht",
    "text": "8.2 Kleine ModulÃ¼bersicht\nDa es nicht mÃ¶glich ist, auf alle diese Module einzugehen, werden im folgenden nur einige wenige Module aufgelistet, welche fÃ¼r die Zielgruppe dieses Skripts interessant sein kÃ¶nnten. Hinweis: Die Eigennamen einiger Module weisen eine GroÃŸ- und Kleinschreibung auf, bspw. das Modul NumPy. Beim Importieren der Module werden die Modulnamen jedoch klein geschrieben. In der folgenden Liste wird auf die GroÃŸ- und Kleinschreibung daher verzichtet.\n\nmath: mathematische Funktionen und Konstanten\nscipy: wissenschaftliche Funktionen\nsys: Interaktion mit dem Python-Interpreter\nos: Interaktion mit dem Betriebssystem\nglob: Durchsuchen von Dateisystempfaden\nmultiprocessing / threading: Parallelprogramierung mit Prozessen / Threads\nmatplotlib: Visualisierung von Daten und Erstellen von Abbildungen\nnumpy: numerische Operationen und Funktionen\npandas: Daten einlesen und auswerten\ntime: Zeitfunktionen\n\nÂ  (Arnold (2023))\n\n\n\n\nArnold, Simone. 2023. â€Datenanalyse mit Python. Funktionen Module Dateien.â€œ Fachhochschule Dortmund.",
    "crumbs": [
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Module und Pakete importieren</span>"
    ]
  }
]